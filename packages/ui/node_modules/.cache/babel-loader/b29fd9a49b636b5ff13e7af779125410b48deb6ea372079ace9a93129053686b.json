{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractFactory = void 0;\nvar AbstractFactory = function () {\n  function AbstractFactory(nodes) {\n    var e_1, _a;\n    if (nodes === void 0) {\n      nodes = null;\n    }\n    this.defaultKind = 'unknown';\n    this.nodeMap = new Map();\n    this.node = {};\n    if (nodes === null) {\n      nodes = this.constructor.defaultNodes;\n    }\n    try {\n      for (var _b = __values(Object.keys(nodes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var kind = _c.value;\n        this.setNodeClass(kind, nodes[kind]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n  AbstractFactory.prototype.create = function (kind) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    return (this.node[kind] || this.node[this.defaultKind]).apply(void 0, __spreadArray([], __read(args), false));\n  };\n  AbstractFactory.prototype.setNodeClass = function (kind, nodeClass) {\n    this.nodeMap.set(kind, nodeClass);\n    var THIS = this;\n    var KIND = this.nodeMap.get(kind);\n    this.node[kind] = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return new (KIND.bind.apply(KIND, __spreadArray([void 0, THIS], __read(args), false)))();\n    };\n  };\n  AbstractFactory.prototype.getNodeClass = function (kind) {\n    return this.nodeMap.get(kind);\n  };\n  AbstractFactory.prototype.deleteNodeClass = function (kind) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  };\n  AbstractFactory.prototype.nodeIsKind = function (node, kind) {\n    return node instanceof this.getNodeClass(kind);\n  };\n  AbstractFactory.prototype.getKinds = function () {\n    return Array.from(this.nodeMap.keys());\n  };\n  AbstractFactory.defaultNodes = {};\n  return AbstractFactory;\n}();\nexports.AbstractFactory = AbstractFactory;","map":{"version":3,"names":["AbstractFactory","nodes","defaultKind","nodeMap","Map","node","constructor","defaultNodes","_b","__values","Object","keys","_c","next","done","kind","value","setNodeClass","prototype","create","args","_i","arguments","length","apply","__spreadArray","__read","nodeClass","set","THIS","KIND","get","bind","getNodeClass","deleteNodeClass","delete","nodeIsKind","getKinds","Array","from","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/core/Tree/Factory.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The generic Factory class for creating arbitrary objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n/*****************************************************************/\n/**\n * The Factory node interfaces (one for the node instance, one for the node class)\n */\n\nexport interface FactoryNode {\n  readonly kind: string;\n}\n\n/**\n * @template N  The Node type being created by the factory\n */\nexport interface FactoryNodeClass<N extends FactoryNode> {\n  /**\n   * @param {Factory<N, FactoryNodeClass<N>>} factory  The factory for creating more nodes\n   * @param {any[]} args  Any additional arguments needed by the node\n   * @return {N}  The newly created node\n   */\n  new(factory: Factory<N, FactoryNodeClass<N>>, ...args: any[]): N;\n}\n\n/*****************************************************************/\n/**\n * The Factory interface\n *\n * Factory<N, C> takes a node type N and a node class C, which give\n * the interfaces for the node instance and the node constructors. We\n * need both for two reasons: first, you can't use typeof N to get C,\n * since N is a type not an object, and if N has static members, we\n * may want to access them from the results of getNodeClass(kind)\n * (this is done in MmlNodes, for example).\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport interface Factory<N extends FactoryNode, C extends FactoryNodeClass<N>> {\n  /**\n   * @param {string} kind  The kind of node to create\n   * @return {N}  The newly created node of the given kind\n   */\n  create(kind: string): N;\n\n  /**\n   * Defines a class for a given node kind\n   *\n   * @param {string} kind  The kind whose class is being defined\n   * @param {C} nodeClass  The class for the given kind\n   */\n  setNodeClass(kind: string, nodeClass: C): void;\n\n  /**\n   * @param {string} kind  The kind of node whose class is to be returned\n   * @return {C}  The class object for the given kind\n   */\n  getNodeClass(kind: string): C;\n\n  /**\n   * @param {string} kind  The kind whose definition is to be deleted\n   */\n  deleteNodeClass(kind: string): void;\n\n  /**\n   * @param {N} node  The node to test if it is of a given kind\n   * @param {string} kind  The kind to test for\n   * @return {boolean}  True if the node is of the given kind, false otherwise\n   */\n  nodeIsKind(node: N, kind: string): boolean;\n\n  /**\n   * @return {string[]}  The names of all the available kinds of nodes\n   */\n  getKinds(): string[];\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactoryClass interface\n *   (needed for access to defaultNodes via the constructor)\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\ninterface AbstractFactoryClass<N extends FactoryNode, C extends FactoryNodeClass<N>> extends Function {\n  defaultNodes: {[kind: string]: C};\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactory class\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport abstract class AbstractFactory<N extends FactoryNode, C extends FactoryNodeClass<N>> implements Factory<N, C> {\n\n  /**\n   * The default collection of objects to use for the node map\n   */\n  public static defaultNodes = {};\n\n  /**\n   * The default kind\n   */\n  public defaultKind = 'unknown';\n\n  /**\n   * The map of node kinds to node classes\n   */\n  protected nodeMap: Map<string, C> = new Map();\n\n  /**\n   * An object containing functions for creating the various node kinds\n   */\n  protected node: {[kind: string]: (...args: any[]) => N} = {};\n\n  /**\n   * @override\n   */\n  constructor(nodes: {[kind: string]: C} = null) {\n    if (nodes === null) {\n      nodes = (this.constructor as AbstractFactoryClass<N, C>).defaultNodes;\n    }\n    for (const kind of Object.keys(nodes)) {\n      this.setNodeClass(kind, nodes[kind]);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public create(kind: string, ...args: any[]) {\n    return (this.node[kind] || this.node[this.defaultKind])(...args);\n  }\n\n  /**\n   * @override\n   */\n  public setNodeClass(kind: string, nodeClass: C) {\n    this.nodeMap.set(kind, nodeClass);\n    let THIS = this;\n    let KIND = this.nodeMap.get(kind);\n    this.node[kind] = (...args: any[]) => {\n      return new KIND(THIS, ...args);\n    };\n  }\n  /**\n   * @override\n   */\n  public getNodeClass(kind: string): C {\n    return this.nodeMap.get(kind);\n  }\n\n  /**\n   * @override\n   */\n  public deleteNodeClass(kind: string) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  }\n\n  /**\n   * @override\n   */\n  public nodeIsKind(node: N, kind: string) {\n    return (node instanceof this.getNodeClass(kind));\n  }\n\n  /**\n   * @override\n   */\n  public getKinds() {\n    return Array.from(this.nodeMap.keys());\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}