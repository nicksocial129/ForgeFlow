{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar NodeUtil_js_1 = __importDefault(require(\"./NodeUtil.js\"));\nvar FilterUtil;\n(function (FilterUtil) {\n  FilterUtil.cleanStretchy = function (arg) {\n    var e_1, _a;\n    var options = arg.data;\n    try {\n      for (var _b = __values(options.getList('fixStretchy')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mo = _c.value;\n        if (NodeUtil_js_1.default.getProperty(mo, 'fixStretchy')) {\n          var symbol = NodeUtil_js_1.default.getForm(mo);\n          if (symbol && symbol[3] && symbol[3]['stretchy']) {\n            NodeUtil_js_1.default.setAttribute(mo, 'stretchy', false);\n          }\n          var parent_1 = mo.parent;\n          if (!NodeUtil_js_1.default.getTexClass(mo) && (!symbol || !symbol[2])) {\n            var texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n            parent_1.replaceChild(texAtom, mo);\n            texAtom.inheritAttributesFrom(mo);\n          }\n          NodeUtil_js_1.default.removeProperties(mo, 'fixStretchy');\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  FilterUtil.cleanAttributes = function (arg) {\n    var node = arg.data.root;\n    node.walkTree(function (mml, _d) {\n      var e_2, _a;\n      var attribs = mml.attributes;\n      if (!attribs) {\n        return;\n      }\n      var keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));\n      delete attribs.getAllAttributes()['mjx-keep-attrs'];\n      try {\n        for (var _b = __values(attribs.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n          if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {\n            delete attribs.attributes[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }, {});\n  };\n  FilterUtil.combineRelations = function (arg) {\n    var e_3, _a, e_4, _b;\n    var remove = [];\n    try {\n      for (var _c = __values(arg.data.getList('mo')), _e = _c.next(); !_e.done; _e = _c.next()) {\n        var mo = _e.value;\n        if (mo.getProperty('relationsCombined') || !mo.parent || mo.parent && !NodeUtil_js_1.default.isType(mo.parent, 'mrow') || NodeUtil_js_1.default.getTexClass(mo) !== MmlNode_js_1.TEXCLASS.REL) {\n          continue;\n        }\n        var mml = mo.parent;\n        var m2 = void 0;\n        var children = mml.childNodes;\n        var next = children.indexOf(mo) + 1;\n        var variantForm = NodeUtil_js_1.default.getProperty(mo, 'variantForm');\n        while (next < children.length && (m2 = children[next]) && NodeUtil_js_1.default.isType(m2, 'mo') && NodeUtil_js_1.default.getTexClass(m2) === MmlNode_js_1.TEXCLASS.REL) {\n          if (variantForm === NodeUtil_js_1.default.getProperty(m2, 'variantForm') && _compareExplicit(mo, m2)) {\n            NodeUtil_js_1.default.appendChildren(mo, NodeUtil_js_1.default.getChildren(m2));\n            _copyExplicit(['stretchy', 'rspace'], mo, m2);\n            try {\n              for (var _f = (e_4 = void 0, __values(m2.getPropertyNames())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var name_1 = _g.value;\n                mo.setProperty(name_1, m2.getProperty(name_1));\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n            children.splice(next, 1);\n            remove.push(m2);\n            m2.parent = null;\n            m2.setProperty('relationsCombined', true);\n          } else {\n            if (mo.attributes.getExplicit('rspace') == null) {\n              NodeUtil_js_1.default.setAttribute(mo, 'rspace', '0pt');\n            }\n            if (m2.attributes.getExplicit('lspace') == null) {\n              NodeUtil_js_1.default.setAttribute(m2, 'lspace', '0pt');\n            }\n            break;\n          }\n        }\n        mo.attributes.setInherited('form', mo.getForms()[0]);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n  var _copyExplicit = function (attrs, node1, node2) {\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    attrs.forEach(function (x) {\n      var attr = attr2.getExplicit(x);\n      if (attr != null) {\n        attr1.set(x, attr);\n      }\n    });\n  };\n  var _compareExplicit = function (node1, node2) {\n    var e_5, _a;\n    var filter = function (attr, space) {\n      var exp = attr.getExplicitNames();\n      return exp.filter(function (x) {\n        return x !== space && (x !== 'stretchy' || attr.getExplicit('stretchy'));\n      });\n    };\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    var exp1 = filter(attr1, 'lspace');\n    var exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    try {\n      for (var exp1_1 = __values(exp1), exp1_1_1 = exp1_1.next(); !exp1_1_1.done; exp1_1_1 = exp1_1.next()) {\n        var name_2 = exp1_1_1.value;\n        if (attr1.getExplicit(name_2) !== attr2.getExplicit(name_2)) {\n          return false;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (exp1_1_1 && !exp1_1_1.done && (_a = exp1_1.return)) _a.call(exp1_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return true;\n  };\n  var _cleanSubSup = function (options, low, up) {\n    var e_6, _a;\n    var remove = [];\n    try {\n      for (var _b = __values(options.getList('m' + low + up)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var children = mml.childNodes;\n        if (children[mml[low]] && children[mml[up]]) {\n          continue;\n        }\n        var parent_2 = mml.parent;\n        var newNode = children[mml[low]] ? options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) : options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]);\n        NodeUtil_js_1.default.copyAttributes(mml, newNode);\n        if (parent_2) {\n          parent_2.replaceChild(newNode, mml);\n        } else {\n          options.root = newNode;\n        }\n        remove.push(mml);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n  FilterUtil.cleanSubSup = function (arg) {\n    var options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n  var _moveLimits = function (options, underover, subsup) {\n    var e_7, _a;\n    var remove = [];\n    try {\n      for (var _b = __values(options.getList(underover)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        if (mml.attributes.get('displaystyle')) {\n          continue;\n        }\n        var base = mml.childNodes[mml.base];\n        var mo = base.coreMO();\n        if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n          var node = options.nodeFactory.create('node', subsup, mml.childNodes);\n          NodeUtil_js_1.default.copyAttributes(mml, node);\n          if (mml.parent) {\n            mml.parent.replaceChild(node, mml);\n          } else {\n            options.root = node;\n          }\n          remove.push(mml);\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n  FilterUtil.moveLimits = function (arg) {\n    var options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n  FilterUtil.setInherited = function (arg) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n})(FilterUtil || (FilterUtil = {}));\nexports.default = FilterUtil;","map":{"version":3,"names":["MmlNode_js_1","require","NodeUtil_js_1","__importDefault","FilterUtil","cleanStretchy","arg","options","data","_b","__values","getList","_c","next","done","mo","value","default","getProperty","symbol","getForm","setAttribute","parent_1","parent","getTexClass","texAtom","nodeFactory","create","replaceChild","inheritAttributesFrom","removeProperties","cleanAttributes","node","root","walkTree","mml","_d","attribs","attributes","keep","Set","get","split","getAllAttributes","getExplicitNames","key","has","getInherited","combineRelations","remove","_e","isType","TEXCLASS","REL","m2","children","childNodes","indexOf","variantForm","length","_compareExplicit","appendChildren","getChildren","_copyExplicit","_f","e_4","getPropertyNames","_g","name_1","setProperty","splice","push","getExplicit","setInherited","getForms","removeFromList","attrs","node1","node2","attr1","attr2","forEach","x","attr","set","filter","space","exp","exp1","exp2","exp1_1","exp1_1_1","name_2","_cleanSubSup","low","up","parent_2","newNode","base","copyAttributes","cleanSubSup","error","_moveLimits","underover","subsup","coreMO","moveLimits","setInheritedAttributes","math","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/FilterUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Utility functions for standard pre and post filters.\n *\n * @author sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {TEXCLASS, MMLNODE, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport NodeUtil from './NodeUtil.js';\nimport ParseOptions from './ParseOptions.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Attributes} from '../../core/MmlTree/Attributes.js';\n\n\nnamespace FilterUtil {\n\n  /**\n   * Visitor to set stretchy attributes to false on <mo> elements, if they are\n   * not used as delimiters. Also wraps non-stretchy infix delimiters into a\n   * TeXAtom.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanStretchy = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    for (let mo of options.getList('fixStretchy')) {\n      if (NodeUtil.getProperty(mo, 'fixStretchy')) {\n        let symbol = NodeUtil.getForm(mo);\n        if (symbol && symbol[3] && symbol[3]['stretchy']) {\n          NodeUtil.setAttribute(mo, 'stretchy', false);\n        }\n        const parent = mo.parent;\n        if (!NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {\n          const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n          parent.replaceChild(texAtom, mo);\n          texAtom.inheritAttributesFrom(mo);\n        }\n        NodeUtil.removeProperties(mo, 'fixStretchy');\n      }\n    }\n  };\n\n\n  /**\n   * Visitor that removes superfluous attributes from nodes. I.e., if a node has\n   * an attribute, which is also an inherited attribute it will be removed. This\n   * is necessary as attributes are set bottom up in the parser.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanAttributes = function(arg: {data: ParseOptions}) {\n    let node = arg.data.root as MmlNode;\n    node.walkTree((mml: MmlNode, _d: any) => {\n      let attribs = mml.attributes as any;\n      if (!attribs) {\n        return;\n      }\n      const keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));\n      delete (attribs.getAllAttributes())['mjx-keep-attrs'];\n      for (const key of attribs.getExplicitNames()) {\n        if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {\n          delete attribs.attributes[key];\n        }\n      }\n    }, {});\n  };\n\n\n  /**\n   * Combine adjacent <mo> elements that are relations (since MathML treats the\n   * spacing very differently)\n   * @param {ParseOptions} data The parse options.\n   */\n  export let combineRelations = function(arg: {data: ParseOptions}) {\n    const remove: MmlNode[] = [];\n    for (let mo of arg.data.getList('mo')) {\n      if (mo.getProperty('relationsCombined') || !mo.parent ||\n          (mo.parent && !NodeUtil.isType(mo.parent, 'mrow')) ||\n          NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {\n        // @test Prime, PrimeSup, Named Function\n        continue;\n      }\n      let mml = mo.parent;\n      let m2: MmlNode;\n      let children = mml.childNodes as MMLNODE[];\n      let next = children.indexOf(mo) + 1;\n      let variantForm = NodeUtil.getProperty(mo, 'variantForm');\n      while (next < children.length && (m2 = children[next]) &&\n             NodeUtil.isType(m2, 'mo') &&\n             NodeUtil.getTexClass(m2) === TEXCLASS.REL) {\n        if (variantForm === NodeUtil.getProperty(m2, 'variantForm') &&\n            _compareExplicit(mo, m2)) {\n          // @test Shift Left, Less Equal,\n          //       Multirel Font X, Multirel Mathvariant X\n          NodeUtil.appendChildren(mo, NodeUtil.getChildren(m2));\n          // This treatment means we might loose some inheritance structure, but\n          // no properties.\n          _copyExplicit(['stretchy', 'rspace'], mo, m2);\n          for (const name of m2.getPropertyNames()) {\n            mo.setProperty(name, m2.getProperty(name));\n          }\n          children.splice(next, 1);\n          remove.push(m2);\n          m2.parent = null;\n          m2.setProperty('relationsCombined', true);\n        } else {\n          // @test Preset Rspace Lspace\n          if (mo.attributes.getExplicit('rspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(mo, 'rspace', '0pt');\n          }\n          if (m2.attributes.getExplicit('lspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(m2, 'lspace', '0pt');\n          }\n          break;\n        }\n      }\n      mo.attributes.setInherited('form', (mo as MmlMo).getForms()[0]);\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n\n\n  /**\n   * Copies the specified explicit attributes from node2 to node1.\n   * @param {string[]} attrs List of explicit attribute names.\n   * @param {MmlNode} node1 The goal node.\n   * @param {MmlNode} node2 The source node.\n   */\n  let _copyExplicit = function(attrs: string[],\n                               node1: MmlNode, node2: MmlNode) {\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    attrs.forEach(x => {\n      let attr = attr2.getExplicit(x);\n      if (attr != null) {\n        // @test Infix Stretchy Right, Preset Lspace Rspace\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n\n  /**\n   * Compares the explicit attributes of two nodes. Returns true if they\n   * coincide, with the following exceptions:\n   *   - lspace attribute of node1 is ignored.\n   *   - rspace attribute of node2 is ignored.\n   *   - stretchy=false attributes are ignored.\n   * @param {MmlNode} node1 The first node.\n   * @param {MmlNode} node2 Its next sibling.\n   */\n  let _compareExplicit = function(node1: MmlNode, node2: MmlNode) {\n    let filter = (attr: Attributes, space: string): string[] => {\n      let exp = attr.getExplicitNames();\n      return exp.filter(x => {\n        return x !== space &&\n          (x !== 'stretchy' ||\n           attr.getExplicit('stretchy'));\n      });\n    };\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    let exp1 = filter(attr1, 'lspace');\n    let exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    for (let name of exp1) {\n      if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Cleans msubsup and munderover elements.\n   * @param {ParseOptions} options The parse options.\n   * @param {string} low String representing the lower part of the expression.\n   * @param {string} up String representing the upper part.\n   */\n  let _cleanSubSup = function(options: ParseOptions, low: string, up: string) {\n    const remove: MmlNode[] = [];\n    for (let mml of options.getList('m' + low + up) as any[]) {\n      const children = mml.childNodes;\n      if (children[mml[low]] && children[mml[up]]) {\n        continue;\n      }\n      const parent = mml.parent;\n      let newNode = (children[mml[low]] ?\n                 options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :\n                 options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));\n      NodeUtil.copyAttributes(mml, newNode);\n      if (parent) {\n        parent.replaceChild(newNode, mml);\n      } else {\n        options.root = newNode;\n      }\n      remove.push(mml);\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n\n\n  /**\n   * Visitor that rewrites incomplete msubsup/munderover elements in the given\n   * node into corresponding msub/sup/under/over nodes.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanSubSup = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n\n  /**\n   * Looks through the list of munderover elements for ones that have\n   * movablelimits and bases that are not mo's, and creates new msubsup\n   * elements to replace them if they aren't in displaystyle.\n   *\n   * @param {MmlNode} ath The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  let _moveLimits = function (options: ParseOptions, underover: string, subsup: string) {\n    const remove: MmlNode[] = [];\n    for (const mml of options.getList(underover)) {\n      if (mml.attributes.get('displaystyle')) {\n        continue;\n      }\n      const base = mml.childNodes[(mml as any).base] as MmlNode;\n      const mo = base.coreMO();\n      if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n        let node = options.nodeFactory.create('node', subsup, mml.childNodes);\n        NodeUtil.copyAttributes(mml, node);\n        if (mml.parent) {\n          mml.parent.replaceChild(node, mml);\n        } else {\n          options.root = node;\n        }\n        remove.push(mml);\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n\n  /**\n   * Visitor that rewrites in-line munderover elements with movablelimits but bases\n   * that are not mo's into explicit msubsup elements.\n   *\n   * @param {ParseOptions} data  The parse options to use\n   */\n  export let moveLimits = function (arg: {data: ParseOptions}) {\n    const options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n\n  /**\n   * Recursively sets the inherited attributes on the math tree.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let setInherited = function(arg: {math: any, data: ParseOptions}) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n\n}\n\n\nexport default FilterUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}