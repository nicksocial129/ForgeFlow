{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XMLNode = exports.TextNode = exports.AbstractMmlEmptyNode = exports.AbstractMmlBaseNode = exports.AbstractMmlLayoutNode = exports.AbstractMmlTokenNode = exports.AbstractMmlNode = exports.indentAttributes = exports.TEXCLASSNAMES = exports.TEXCLASS = void 0;\nvar Attributes_js_1 = require(\"./Attributes.js\");\nvar Node_js_1 = require(\"../Tree/Node.js\");\nexports.TEXCLASS = {\n  ORD: 0,\n  OP: 1,\n  BIN: 2,\n  REL: 3,\n  OPEN: 4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,\n  NONE: -1\n};\nexports.TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\nvar TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\nvar TEXSPACE = [[0, -1, 2, 3, 0, 0, 0, 1], [-1, -1, 0, 3, 0, 0, 0, 1], [2, 2, 0, 0, 2, 0, 0, 2], [3, 3, 0, 0, 3, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, -1, 2, 3, 0, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, -1, 2, 3, 1, 0, 1, 1]];\nexports.indentAttributes = ['indentalign', 'indentalignfirst', 'indentshift', 'indentshiftfirst'];\nvar AbstractMmlNode = function (_super) {\n  __extends(AbstractMmlNode, _super);\n  function AbstractMmlNode(factory, attributes, children) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (children === void 0) {\n      children = [];\n    }\n    var _this = _super.call(this, factory) || this;\n    _this.prevClass = null;\n    _this.prevLevel = null;\n    _this.texclass = null;\n    if (_this.arity < 0) {\n      _this.childNodes = [factory.create('inferredMrow')];\n      _this.childNodes[0].parent = _this;\n    }\n    _this.setChildren(children);\n    _this.attributes = new Attributes_js_1.Attributes(factory.getNodeClass(_this.kind).defaults, factory.getNodeClass('math').defaults);\n    _this.attributes.setList(attributes);\n    return _this;\n  }\n  AbstractMmlNode.prototype.copy = function (keepIds) {\n    var e_1, _a, e_2, _b;\n    if (keepIds === void 0) {\n      keepIds = false;\n    }\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n    if (this.attributes) {\n      var attributes = this.attributes.getAllAttributes();\n      try {\n        for (var _c = __values(Object.keys(attributes)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          if (name_1 !== 'id' || keepIds) {\n            node.attributes.set(name_1, attributes[name_1]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      var children = this.childNodes;\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes;\n      }\n      try {\n        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n          var child = children_1_1.value;\n          if (child) {\n            node.appendChild(child.copy());\n          } else {\n            node.childNodes.push(null);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    return node;\n  };\n  Object.defineProperty(AbstractMmlNode.prototype, \"texClass\", {\n    get: function () {\n      return this.texclass;\n    },\n    set: function (texClass) {\n      this.texclass = texClass;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"arity\", {\n    get: function () {\n      return Infinity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"Parent\", {\n    get: function () {\n      var parent = this.parent;\n      while (parent && parent.notParent) {\n        parent = parent.Parent;\n      }\n      return parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlNode.prototype.setChildren = function (children) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return _super.prototype.setChildren.call(this, children);\n  };\n  AbstractMmlNode.prototype.appendChild = function (child) {\n    var e_3, _a;\n    var _this = this;\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      if (this.arity === Infinity) {\n        child.childNodes.forEach(function (node) {\n          return _super.prototype.appendChild.call(_this, node);\n        });\n        return child;\n      }\n      var original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      try {\n        for (var _b = __values(original.getPropertyNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_2 = _c.value;\n          child.setProperty(name_2, original.getProperty(name_2));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n    return _super.prototype.appendChild.call(this, child);\n  };\n  AbstractMmlNode.prototype.replaceChild = function (newChild, oldChild) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return _super.prototype.replaceChild.call(this, newChild, oldChild);\n  };\n  AbstractMmlNode.prototype.core = function () {\n    return this;\n  };\n  AbstractMmlNode.prototype.coreMO = function () {\n    return this;\n  };\n  AbstractMmlNode.prototype.coreIndex = function () {\n    return 0;\n  };\n  AbstractMmlNode.prototype.childPosition = function () {\n    var e_4, _a;\n    var child = this;\n    var parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      var i = 0;\n      try {\n        for (var _b = __values(parent.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var node = _c.value;\n          if (node === child) {\n            return i;\n          }\n          i++;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n    return null;\n  };\n  AbstractMmlNode.prototype.setTeXclass = function (prev) {\n    this.getPrevClass(prev);\n    return this.texClass != null ? this : prev;\n  };\n  AbstractMmlNode.prototype.updateTeXclass = function (core) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  };\n  AbstractMmlNode.prototype.getPrevClass = function (prev) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel');\n    }\n  };\n  AbstractMmlNode.prototype.texSpacing = function () {\n    var prevClass = this.prevClass != null ? this.prevClass : exports.TEXCLASS.NONE;\n    var texClass = this.texClass || exports.TEXCLASS.ORD;\n    if (prevClass === exports.TEXCLASS.NONE || texClass === exports.TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === exports.TEXCLASS.VCENTER) {\n      prevClass = exports.TEXCLASS.ORD;\n    }\n    if (texClass === exports.TEXCLASS.VCENTER) {\n      texClass = exports.TEXCLASS.ORD;\n    }\n    var space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  };\n  AbstractMmlNode.prototype.hasSpacingAttributes = function () {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  };\n  AbstractMmlNode.prototype.setInheritedAttributes = function (attributes, display, level, prime) {\n    var e_5, _a;\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (display === void 0) {\n      display = false;\n    }\n    if (level === void 0) {\n      level = 0;\n    }\n    if (prime === void 0) {\n      prime = false;\n    }\n    var defaults = this.attributes.getAllDefaults();\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n          var _d = __read(attributes[key], 2),\n            node = _d[0],\n            value = _d[1];\n          var noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n          if (!noinherit[key]) {\n            this.attributes.setInherited(key, value);\n          }\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    var displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    var scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    var arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  };\n  AbstractMmlNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_6, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n  AbstractMmlNode.prototype.addInheritedAttributes = function (current, attributes) {\n    var e_7, _a;\n    var updated = __assign({}, current);\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_3 = _c.value;\n        if (name_3 !== 'displaystyle' && name_3 !== 'scriptlevel' && name_3 !== 'style') {\n          updated[name_3] = [this.kind, attributes[name_3]];\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n    return updated;\n  };\n  AbstractMmlNode.prototype.inheritAttributesFrom = function (node) {\n    var attributes = node.attributes;\n    var display = attributes.get('displaystyle');\n    var scriptlevel = attributes.get('scriptlevel');\n    var defaults = !attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    };\n    var prime = node.getProperty('texprimestyle') || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  };\n  AbstractMmlNode.prototype.verifyTree = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    var arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  };\n  AbstractMmlNode.prototype.verifyAttributes = function (options) {\n    var e_8, _a;\n    if (options['checkAttributes']) {\n      var attributes = this.attributes;\n      var bad = [];\n      try {\n        for (var _b = __values(attributes.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_4 = _c.value;\n          if (name_4.substr(0, 5) !== 'data-' && attributes.getDefault(name_4) === undefined && !name_4.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n            bad.push(name_4);\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  };\n  AbstractMmlNode.prototype.verifyChildren = function (options) {\n    var e_9, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.verifyTree(options);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n  AbstractMmlNode.prototype.mError = function (message, options, short) {\n    if (short === void 0) {\n      short = false;\n    }\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    var merror = this.factory.create('merror');\n    merror.attributes.set('data-mjx-message', message);\n    if (options['fullErrors'] || short) {\n      var mtext = this.factory.create('mtext');\n      var text = this.factory.create('text');\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  };\n  AbstractMmlNode.defaults = {\n    mathbackground: Attributes_js_1.INHERIT,\n    mathcolor: Attributes_js_1.INHERIT,\n    mathsize: Attributes_js_1.INHERIT,\n    dir: Attributes_js_1.INHERIT\n  };\n  AbstractMmlNode.noInherit = {\n    mstyle: {\n      mpadded: {\n        width: true,\n        height: true,\n        depth: true,\n        lspace: true,\n        voffset: true\n      },\n      mtable: {\n        width: true,\n        height: true,\n        depth: true,\n        align: true\n      }\n    },\n    maligngroup: {\n      mrow: {\n        groupalign: true\n      },\n      mtable: {\n        groupalign: true\n      }\n    }\n  };\n  AbstractMmlNode.alwaysInherit = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n  AbstractMmlNode.verifyDefaults = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n  return AbstractMmlNode;\n}(Node_js_1.AbstractNode);\nexports.AbstractMmlNode = AbstractMmlNode;\nvar AbstractMmlTokenNode = function (_super) {\n  __extends(AbstractMmlTokenNode, _super);\n  function AbstractMmlTokenNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlTokenNode.prototype, \"isToken\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlTokenNode.prototype.getText = function () {\n    var e_10, _a;\n    var text = '';\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof TextNode) {\n          text += child.getText();\n        }\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n    return text;\n  };\n  AbstractMmlTokenNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_11, _a;\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof AbstractMmlNode) {\n          child.setInheritedAttributes(attributes, display, level, prime);\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n  };\n  AbstractMmlTokenNode.prototype.walkTree = function (func, data) {\n    var e_12, _a;\n    func(this, data);\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child instanceof AbstractMmlNode) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n    return data;\n  };\n  AbstractMmlTokenNode.defaults = __assign(__assign({}, AbstractMmlNode.defaults), {\n    mathvariant: 'normal',\n    mathsize: Attributes_js_1.INHERIT\n  });\n  return AbstractMmlTokenNode;\n}(AbstractMmlNode);\nexports.AbstractMmlTokenNode = AbstractMmlTokenNode;\nvar AbstractMmlLayoutNode = function (_super) {\n  __extends(AbstractMmlLayoutNode, _super);\n  function AbstractMmlLayoutNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return this.childNodes[0].isSpacelike;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"arity\", {\n    get: function () {\n      return -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlLayoutNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n  AbstractMmlLayoutNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n  AbstractMmlLayoutNode.prototype.setTeXclass = function (prev) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  };\n  AbstractMmlLayoutNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlLayoutNode;\n}(AbstractMmlNode);\nexports.AbstractMmlLayoutNode = AbstractMmlLayoutNode;\nvar AbstractMmlBaseNode = function (_super) {\n  __extends(AbstractMmlBaseNode, _super);\n  function AbstractMmlBaseNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlBaseNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlBaseNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n  AbstractMmlBaseNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n  AbstractMmlBaseNode.prototype.setTeXclass = function (prev) {\n    var e_13, _a;\n    this.getPrevClass(prev);\n    this.texClass = exports.TEXCLASS.ORD;\n    var base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    try {\n      for (var _b = __values(this.childNodes.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        if (child) {\n          child.setTeXclass(null);\n        }\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n    return prev;\n  };\n  AbstractMmlBaseNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlBaseNode;\n}(AbstractMmlNode);\nexports.AbstractMmlBaseNode = AbstractMmlBaseNode;\nvar AbstractMmlEmptyNode = function (_super) {\n  __extends(AbstractMmlEmptyNode, _super);\n  function AbstractMmlEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"arity\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"Parent\", {\n    get: function () {\n      return this.parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"texClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevLevel\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlEmptyNode.prototype.hasSpacingAttributes = function () {\n    return false;\n  };\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"attributes\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractMmlEmptyNode.prototype.core = function () {\n    return this;\n  };\n  AbstractMmlEmptyNode.prototype.coreMO = function () {\n    return this;\n  };\n  AbstractMmlEmptyNode.prototype.coreIndex = function () {\n    return 0;\n  };\n  AbstractMmlEmptyNode.prototype.childPosition = function () {\n    return 0;\n  };\n  AbstractMmlEmptyNode.prototype.setTeXclass = function (prev) {\n    return prev;\n  };\n  AbstractMmlEmptyNode.prototype.texSpacing = function () {\n    return '';\n  };\n  AbstractMmlEmptyNode.prototype.setInheritedAttributes = function (_attributes, _display, _level, _prime) {};\n  AbstractMmlEmptyNode.prototype.inheritAttributesFrom = function (_node) {};\n  AbstractMmlEmptyNode.prototype.verifyTree = function (_options) {};\n  AbstractMmlEmptyNode.prototype.mError = function (_message, _options, _short) {\n    if (_short === void 0) {\n      _short = false;\n    }\n    return null;\n  };\n  return AbstractMmlEmptyNode;\n}(Node_js_1.AbstractEmptyNode);\nexports.AbstractMmlEmptyNode = AbstractMmlEmptyNode;\nvar TextNode = function (_super) {\n  __extends(TextNode, _super);\n  function TextNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.text = '';\n    return _this;\n  }\n  Object.defineProperty(TextNode.prototype, \"kind\", {\n    get: function () {\n      return 'text';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TextNode.prototype.getText = function () {\n    return this.text;\n  };\n  TextNode.prototype.setText = function (text) {\n    this.text = text;\n    return this;\n  };\n  TextNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setText(this.getText());\n  };\n  TextNode.prototype.toString = function () {\n    return this.text;\n  };\n  return TextNode;\n}(AbstractMmlEmptyNode);\nexports.TextNode = TextNode;\nvar XMLNode = function (_super) {\n  __extends(XMLNode, _super);\n  function XMLNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.xml = null;\n    _this.adaptor = null;\n    return _this;\n  }\n  Object.defineProperty(XMLNode.prototype, \"kind\", {\n    get: function () {\n      return 'XML';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  XMLNode.prototype.getXML = function () {\n    return this.xml;\n  };\n  XMLNode.prototype.setXML = function (xml, adaptor) {\n    if (adaptor === void 0) {\n      adaptor = null;\n    }\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  };\n  XMLNode.prototype.getSerializedXML = function () {\n    return this.adaptor.serializeXML(this.xml);\n  };\n  XMLNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setXML(this.adaptor.clone(this.xml));\n  };\n  XMLNode.prototype.toString = function () {\n    return 'XML data';\n  };\n  return XMLNode;\n}(AbstractMmlEmptyNode);\nexports.XMLNode = XMLNode;","map":{"version":3,"names":["Attributes_js_1","require","Node_js_1","exports","TEXCLASS","ORD","OP","BIN","REL","OPEN","CLOSE","PUNCT","INNER","VCENTER","NONE","TEXCLASSNAMES","TEXSPACELENGTH","TEXSPACE","indentAttributes","AbstractMmlNode","_super","__extends","factory","attributes","children","_this","call","prevClass","prevLevel","texclass","arity","childNodes","create","parent","setChildren","Attributes","getNodeClass","kind","defaults","setList","prototype","copy","keepIds","node","properties","__assign","getAllAttributes","_c","__values","Object","keys","_d","next","done","name_1","value","set","length","isInferred","children_1","children_1_1","child","appendChild","push","defineProperty","get","texClass","Infinity","notParent","Parent","forEach","original","_b","getPropertyNames","name_2","setProperty","getProperty","replaceChild","newChild","oldChild","core","coreMO","coreIndex","childPosition","i","setTeXclass","prev","getPrevClass","updateTeXclass","texSpacing","space","Math","abs","hasSpacingAttributes","isEmbellished","setInheritedAttributes","display","level","prime","getAllDefaults","key","hasOwnProperty","alwaysInherit","__read","noinherit","noInherit","setInherited","displaystyle","getExplicit","undefined","scriptlevel","slice","setChildInheritedAttributes","addInheritedAttributes","current","updated","name_3","inheritAttributesFrom","isSet","mathsize","verifyTree","options","verifyAttributes","mError","verifyChildren","bad","getExplicitNames","name_4","substr","getDefault","match","join","message","short","isKind","merror","mtext","text","setText","mathbackground","INHERIT","mathcolor","dir","mstyle","mpadded","width","height","depth","lspace","voffset","mtable","align","maligngroup","mrow","groupalign","scriptminsize","scriptsizemultiplier","verifyDefaults","checkArity","checkAttributes","fullErrors","fixMmultiscripts","fixMtables","AbstractNode","AbstractMmlTokenNode","getText","TextNode","walkTree","func","data","mathvariant","AbstractMmlLayoutNode","isSpacelike","AbstractMmlBaseNode","base","AbstractMmlEmptyNode","_attributes","_display","_level","_prime","_node","_options","_message","_short","AbstractEmptyNode","apply","arguments","toString","XMLNode","xml","adaptor","getXML","setXML","getSerializedXML","serializeXML","clone"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/core/MmlTree/MmlNode.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Interfaces and abstract classes for MmlNode objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Attributes, INHERIT} from './Attributes.js';\nimport {Property, PropertyList, Node, AbstractNode, AbstractEmptyNode, NodeClass} from '../Tree/Node.js';\nimport {MmlFactory} from './MmlFactory.js';\nimport {DOMAdaptor} from '../DOMAdaptor.js';\n\n/**\n *  Used in setInheritedAttributes() to pass originating node kind as well as property value\n */\nexport type AttributeList = {[attribute: string]: [string, Property]};\n\n/**\n *  These are the TeX classes for spacing computations\n */\nexport const TEXCLASS = {\n  ORD:   0,\n  OP:    1,\n  BIN:   2,\n  REL:   3,\n  OPEN:  4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,  // Used in TeXAtom, but not for spacing\n  NONE:   -1\n};\n\nexport const TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\n\n/**\n *  The spacing sizes used by the TeX spacing table below.\n */\nconst TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\n\n/**\n * See TeXBook Chapter 18 (p. 170)\n */\nconst TEXSPACE = [\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // ORD\n  [-1, -1,  0,  3,  0,  0,  0,  1], // OP\n  [ 2,  2,  0,  0,  2,  0,  0,  2], // BIN\n  [ 3,  3,  0,  0,  3,  0,  0,  3], // REL\n  [ 0,  0,  0,  0,  0,  0,  0,  0], // OPEN\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // CLOSE\n  [ 1,  1,  0,  1,  1,  1,  1,  1], // PUNCT\n  [ 1, -1,  2,  3,  1,  0,  1,  1]  // INNER\n];\n\n/**\n * Attributes used to determine indentation and shifting\n */\nexport const indentAttributes = [\n  'indentalign', 'indentalignfirst',\n  'indentshift', 'indentshiftfirst'\n];\n\n/**\n * The nodes that can be in the internal MathML tree\n */\nexport type MMLNODE = MmlNode | TextNode | XMLNode;\n\n/*****************************************************************/\n/**\n *  The MmlNode interface (extends Node interface)\n */\n\nexport interface MmlNode extends Node {\n\n  /**\n   * Test various properties of MathML nodes\n   */\n  readonly isToken: boolean;\n  readonly isEmbellished: boolean;\n  readonly isSpacelike: boolean;\n  readonly linebreakContainer: boolean;\n  readonly hasNewLine: boolean;\n\n  /**\n   *  The expected number of children (-1 means use inferred mrow)\n   */\n  readonly arity: number;\n  readonly isInferred: boolean;\n\n  /**\n   *  Get the parent node (skipping inferred mrows and\n   *    other nodes marked as notParent)\n   */\n  readonly Parent: MmlNode;\n  readonly notParent: boolean;\n\n  /**\n   * The actual parent in the tree\n   */\n  parent: MmlNode;\n\n  /**\n   *  values needed for TeX spacing computations\n   */\n  texClass: number;\n  prevClass: number;\n  prevLevel: number;\n\n  /**\n   *  The attributes (explicit and inherited) for this node\n   */\n  attributes: Attributes;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the child node that contains the\n   *                    core <mo> node.  For non-embellished nodes, the original node.\n   */\n  core(): MmlNode;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the core <mo> element (at whatever\n   *                    depth).  For non-embellished nodes, the original node itself.\n   */\n  coreMO(): MmlNode;\n\n  /**\n   * @return {number}   For embellished operators, the index of the child node containing\n   *                    the core <mo>.  For non-embellished nodes, 0.\n   */\n  coreIndex(): number;\n\n  /**\n   * @return {number}  The index of this node in its parent's childNodes array.\n   */\n  childPosition(): number;\n\n  /**\n   * @param {MmlNode} prev  The node that is before this one for TeX spacing purposes\n   *                        (not all nodes count in TeX measurements)\n   * @return {MmlNode}  The node that should be the previous node for the next one\n   *                    in the tree (usually, either the last child, or the node itself)\n   */\n  setTeXclass(prev: MmlNode): MmlNode;\n\n  /**\n   * @return {string}  The spacing to use before this element (one of TEXSPACELENGTH array above)\n   */\n  texSpacing(): string;\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form', 'lspace', or 'rspace' attribute\n   */\n  hasSpacingAttributes(): boolean;\n\n  /**\n   * Sets the nodes inherited attributes, and pushes them to the nodes children.\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  setInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean): void;\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  inheritAttributesFrom(node: MmlNode): void;\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   * @return {MmlNode}               The construted merror\n   */\n  mError(message: string, options: PropertyList, short?: boolean): MmlNode;\n\n  /**\n   * Check integrity of MathML structure\n   *\n   * @param {PropertyList} options  The options controlling the check\n   */\n  verifyTree(options?: PropertyList): void;\n}\n\n\n/*****************************************************************/\n/**\n *  The MmlNode class interface (extends the NodeClass)\n */\n\nexport interface MmlNodeClass extends NodeClass {\n\n  /**\n   *  The list of default attribute values for nodes of this class\n   */\n  defaults?: PropertyList;\n\n  /**\n   * An MmlNode takes a NodeFactory (so it can create additional nodes as needed), a list\n   *   of attributes, and an array of children and returns the desired MmlNode with\n   *   those attributes and children\n   *\n   * @constructor\n   * @param {MmlFactory} factory       The MathML node factory to use to create additional nodes\n   * @param {PropertyList} attributes  The list of initial attributes for the node\n   * @param {MmlNode[]} children       The initial child nodes (more can be added later)\n   */\n  new (factory: MmlFactory, attributes?: PropertyList, children?: MmlNode[]): MmlNode;\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode class (extends the AbstractNode class and implements\n *  the IMmlNode interface)\n */\n\nexport abstract class AbstractMmlNode extends AbstractNode implements MmlNode {\n\n  /**\n   * The properties common to all MathML nodes\n   */\n  public static defaults: PropertyList = {\n    mathbackground: INHERIT,\n    mathcolor: INHERIT,\n    mathsize: INHERIT,  // technically only for token elements, but <mstyle mathsize=\"...\"> should\n    //    scale all spaces, fractions, etc.\n    dir: INHERIT\n  };\n\n  /**\n   *  This lists properties that do NOT get inherited between specific kinds\n   *  of nodes.  The outer keys are the node kinds that are being inherited FROM,\n   *  while the second level of keys are the nodes that INHERIT the values.  Any\n   *  property appearing in the innermost list is NOT inherited by the pair.\n   *\n   *  For example, an mpadded element will not inherit a width attribute from an mstyle node.\n   */\n  public static noInherit: {[node1: string]: {[node2: string]: {[attribute: string]: boolean}}} = {\n    mstyle: {\n      mpadded: {width: true, height: true, depth: true, lspace: true, voffset: true},\n      mtable:  {width: true, height: true, depth: true, align: true}\n    },\n    maligngroup: {\n      mrow: {groupalign: true},\n      mtable: {groupalign: true}\n    }\n  };\n\n  /**\n   * This lists the attributes that should always be inherited,\n   *   even when there is no default value for the attribute.\n   */\n  public static alwaysInherit: {[name: string]: boolean} = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n\n  /**\n   * This is the list of options for the verifyTree() method\n   */\n  public static verifyDefaults: PropertyList = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n\n  /*\n   * These default to being unset (the node doesn't participate in spacing calculations).\n   * The correct values are produced when the setTeXclass() method is called on the tree.\n   */\n\n  /**\n   * The TeX class for the preceding node\n   */\n  public prevClass: number = null;\n\n  /**\n   * The scriptlevel of the preceding node\n   */\n  public prevLevel: number = null;\n\n  /**\n   * This node's attributes\n   */\n  public attributes: Attributes;\n\n  /**\n   *  Child nodes are MmlNodes (special case of Nodes).\n   */\n  public childNodes: MmlNode[];\n\n  /**\n   * The parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * The node factory is an MmlFactory\n   */\n  public readonly factory: MmlFactory;\n\n  /**\n   * The TeX class of this node (obtained via texClass below)\n   */\n  protected texclass: number = null;\n\n  /**\n   *  Create an MmlNode:\n   *    If the arity is -1, add the inferred row (created by the factory)\n   *    Add the children, if any\n   *    Create the Attribute object from the class defaults and the global defaults (the math node defaults)\n   *\n   *  @override\n   */\n  constructor(factory: MmlFactory, attributes: PropertyList = {}, children: MmlNode[] = []) {\n    super(factory);\n    if (this.arity < 0) {\n      this.childNodes = [factory.create('inferredMrow')];\n      this.childNodes[0].parent = this;\n    }\n    this.setChildren(children);\n    this.attributes = new Attributes(\n      factory.getNodeClass(this.kind).defaults,\n      factory.getNodeClass('math').defaults\n    );\n    this.attributes.setList(attributes);\n  }\n\n  /**\n   * @override\n   *\n   * @param {boolean} keepIds   True to copy id attributes, false to skip them.\n   *                              (May cause error in the future, since not part of the interface.)\n   * @return {AbstractMmlNode}  The copied node tree.\n   */\n  public copy(keepIds: boolean = false): AbstractMmlNode {\n    const node = this.factory.create(this.kind) as AbstractMmlNode;\n    node.properties = {...this.properties};\n    if (this.attributes) {\n      const attributes = this.attributes.getAllAttributes();\n      for (const name of Object.keys(attributes)) {\n        if (name !== 'id' || keepIds) {\n          node.attributes.set(name, attributes[name]);\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      let children = this.childNodes as MmlNode[];\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes as MmlNode[];\n      }\n      for (const child of children) {\n        if (child) {\n          node.appendChild(child.copy() as MmlNode);\n        } else {\n          node.childNodes.push(null);\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public get texClass(): number {\n    return this.texclass;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public set texClass(texClass: number) {\n    this.texclass = texClass;\n  }\n\n  /**\n   * @return {boolean}  true if this is a token node\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is an embellished operator\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a space-like node\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that supports linebreaks in its children\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this node contains a line break\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  The number of children allowed, or Infinity for any number,\n   *                   or -1 for when an inferred row is needed for the children.\n   *                   Special case is 1, meaning at least one (other numbers\n   *                   mean exactly that many).\n   */\n  public get arity(): number {\n    return Infinity;\n  }\n\n  /**\n   * @return {boolean}  true if this is an inferred mrow\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  The logical parent of this node (skipping over inferred rows\n   *                      some other node types)\n   */\n  public get Parent(): MmlNode {\n    let parent = this.parent;\n    while (parent && parent.notParent) {\n      parent = parent.Parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that doesn't count as a parent node in Parent()\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * If there is an inferred row, the the children of that instead\n   *\n   * @override\n   */\n  public setChildren(children: MmlNode[]) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return super.setChildren(children);\n  }\n  /**\n   * If there is an inferred row, append to that instead.\n   * If a child is inferred, append its children instead.\n   *\n   * @override\n   */\n  public appendChild(child: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      //\n      //  If we can have arbitrary children, remove the inferred mrow\n      //  (just add its children).\n      //\n      if (this.arity === Infinity) {\n        child.childNodes.forEach((node) => super.appendChild(node));\n        return child;\n      }\n      //\n      //  Otherwise, convert the inferred mrow to an explicit mrow\n      //\n      const original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      for (const name of original.getPropertyNames()) {\n        child.setProperty(name, original.getProperty(name));\n      }\n    }\n    return super.appendChild(child);\n  }\n  /**\n   * If there is an inferred row, remove the child from there\n   *\n   * @override\n   */\n  public replaceChild(newChild: MmlNode, oldChild: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return super.replaceChild(newChild, oldChild);\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    let child: MmlNode = this;\n    let parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      let i = 0;\n      for (const node of parent.childNodes) {\n        if (node === child) {\n          return i;\n        }\n        i++;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode): MmlNode {\n    this.getPrevClass(prev);\n    return (this.texClass != null ? this : prev);\n  }\n  /**\n   * For embellished operators, get the data from the core and clear the core\n   *\n   * @param {MmlNode} core  The core <mo> for this node\n   */\n  protected updateTeXclass(core: MmlNode) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  }\n  /**\n   * Get the previous element's texClass and scriptlevel\n   *\n   * @param {MmlNode} prev  The previous node to this one\n   */\n  protected getPrevClass(prev: MmlNode) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel') as number;\n    }\n  }\n\n  /**\n   * @return {string}  returns the spacing to use before this node\n   */\n  public texSpacing(): string {\n    let prevClass = (this.prevClass != null ? this.prevClass : TEXCLASS.NONE);\n    let texClass = this.texClass || TEXCLASS.ORD;\n    if (prevClass === TEXCLASS.NONE || texClass === TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === TEXCLASS.VCENTER) {\n      prevClass = TEXCLASS.ORD;\n    }\n    if (texClass === TEXCLASS.VCENTER) {\n      texClass = TEXCLASS.ORD;\n    }\n    let space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  }\n\n  /**\n   * Sets the inherited propertis for this node, and pushes inherited properties to the children\n   *\n   *   For each inheritable attribute:\n   *     If the node has a default for this attribute, try to inherit it\n   *       but check if the noInherit object prevents that.\n   *   If the node doesn't have an explicit displaystyle, inherit it\n   *   If the node doesn't have an explicit scriptstyle, inherit it\n   *   If the prime style is true, set it as a property (it is not a MathML attribute)\n   *   Check that the number of children is correct\n   *   Finally, push any inherited attributes to teh children.\n   *\n   * @override\n   */\n  public setInheritedAttributes(attributes: AttributeList = {},\n                                display: boolean = false, level: number = 0, prime: boolean = false) {\n    let defaults = this.attributes.getAllDefaults();\n    for (const key of Object.keys(attributes)) {\n      if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n        let [node, value] = attributes[key];\n        let noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n        if (!noinherit[key]) {\n          this.attributes.setInherited(key, value);\n        }\n      }\n    }\n    let displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    let scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    let arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && ((arity === 1 && this.childNodes.length === 0) ||\n                                             (arity !== 1 && this.childNodes.length !== arity))) {\n      //\n      //  Make sure there are the right number of child nodes\n      //  (trim them or add empty mrows)\n      //\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  }\n  /**\n   * Apply inherited attributes to all children\n   * (Some classes override this to handle changes in displaystyle and scriptlevel)\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      child.setInheritedAttributes(attributes, display, level, prime);\n    }\n  }\n  /**\n   * Used by subclasses to add their own attributes to the inherited list\n   * (e.g., mstyle uses this to augment the inherited attibutes)\n   *\n   * @param {AttributeList} current    The current list of inherited attributes\n   * @param {PropertyList} attributes  The new attributes to add into the list\n   */\n  protected addInheritedAttributes(current: AttributeList, attributes: PropertyList) {\n    let updated: AttributeList = {...current};\n    for (const name of Object.keys(attributes)) {\n      if (name !== 'displaystyle' && name !== 'scriptlevel' && name !== 'style') {\n        updated[name] = [this.kind, attributes[name]];\n      }\n    }\n    return updated;\n  }\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  public inheritAttributesFrom(node: MmlNode) {\n    const attributes = node.attributes;\n    const display = attributes.get('displaystyle') as boolean;\n    const scriptlevel = attributes.get('scriptlevel') as number;\n    const defaults: AttributeList = (!attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    });\n    const prime = node.getProperty('texprimestyle') as boolean || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  }\n\n  /**\n   * Verify the attributes, and that there are the right number of children.\n   * Then verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  public verifyTree(options: PropertyList = null) {\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    let arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity &&\n          ((arity === 1 && this.childNodes.length === 0) ||\n           (arity !== 1 && this.childNodes.length !== arity))) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  }\n\n  /**\n   * Verify that all the attributes are valid (i.e., have defaults)\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyAttributes(options: PropertyList) {\n    if (options['checkAttributes']) {\n      const attributes = this.attributes;\n      const bad = [];\n      for (const name of attributes.getExplicitNames()) {\n        if (name.substr(0, 5) !== 'data-' && attributes.getDefault(name) === undefined &&\n            !name.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n          // FIXME: provide a configurable checker for names that are OK\n          bad.push(name);\n        }\n        // FIXME: add ability to check attribute values?\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  }\n\n  /**\n   * Verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyChildren(options: PropertyList) {\n    for (const child of this.childNodes) {\n      child.verifyTree(options);\n    }\n  }\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   * @return {MmlNode}               The constructed merror\n   */\n  public mError(message: string, options: PropertyList, short: boolean = false): MmlNode {\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    let merror = this.factory.create('merror');\n    merror.attributes.set('data-mjx-message', message);\n    if (options['fullErrors'] || short) {\n      let mtext = this.factory.create('mtext');\n      let text = this.factory.create('text') as TextNode;\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Token node class (extends the AbstractMmlNode)\n */\n\nexport abstract class AbstractMmlTokenNode extends AbstractMmlNode {\n\n  /**\n   * Add the attributes common to all token nodes\n   */\n  public static defaults: PropertyList = {\n      ...AbstractMmlNode.defaults,\n    mathvariant: 'normal',\n    mathsize: INHERIT\n  };\n\n  /**\n   * @override\n   */\n  public get isToken() {\n    return true;\n  }\n\n  /**\n   * Get the text of the token node (skipping mglyphs, and combining\n   *   multiple text nodes)\n   */\n  public getText() {\n    let text = '';\n    for (const child of this.childNodes) {\n      if (child instanceof TextNode) {\n        text += child.getText();\n      }\n    }\n    return text;\n  }\n\n  /**\n   * Only inherit to child nodes that are AbstractMmlNodes (not TextNodes)\n   *\n   * @override\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    }\n  }\n\n  /**\n   * Only step into children that are AbstractMmlNodes (not TextNodes)\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Layout class (extends the AbstractMmlNode)\n *\n *  These have inferred mrows (so only one child) and can be\n *  spacelike or embellished based on their contents.\n */\n\nexport abstract class AbstractMmlLayoutNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isSpacelike() {\n    return this.childNodes[0].isSpacelike;\n  }\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public get arity() {\n    return -1;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode-with-base-node Class (extends the AbstractMmlNode)\n *\n *  These have a base element and other elemetns, (e.g., script elements for msubsup).\n *  They can be embellished (if their base is), and get their TeX classes\n *    from their base with their scripts being handled as separate math lists.\n */\n\nexport abstract class AbstractMmlBaseNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    this.getPrevClass(prev);\n    this.texClass = TEXCLASS.ORD;\n    let base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    for (const child of this.childNodes.slice(1)) {\n      if (child) {\n        child.setTeXclass(null);\n      }\n    }\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Empty Class (extends AbstractEmptyNode, implements MmlNode)\n *\n *  These have no children and no attributes (TextNode and XMLNode), so we\n *  override all the methods dealing with them, and with the data that usually\n *  goes with an MmlNode.\n */\n\nexport abstract class AbstractMmlEmptyNode extends AbstractEmptyNode implements MmlNode {\n\n  /**\n   *  Parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * @return {boolean}  Not a token element\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not embellished\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not space-like\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not a container of any kind\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Does not contain new lines\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  No children\n   */\n  public get arity(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  Is not an inferred row\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Is not a container element\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  Parent is the actual parent\n   */\n  public get Parent(): MmlNode {\n    return this.parent;\n  }\n\n  /**\n   * @return {number}  No TeX class\n   */\n  public get texClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevLevel(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return false;\n  }\n\n  /**\n   * return {Attributes}  No attributes, so don't store one\n   */\n  public get attributes(): Attributes {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    return prev;\n  }\n  /**\n   * @override\n   */\n  public texSpacing() {\n    return '';\n  }\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public setInheritedAttributes(_attributes: AttributeList, _display: boolean, _level: number, _prime: boolean) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public inheritAttributesFrom(_node: MmlNode) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @param {PropertyList} options  The options for the check\n   */\n  public verifyTree(_options: PropertyList) {}\n\n  /**\n   *  @override\n   */\n  public mError(_message: string, _options: PropertyList, _short: boolean = false) {\n    return null as MmlNode;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The TextNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class TextNode extends AbstractMmlEmptyNode {\n  /**\n   * The text for this node\n   */\n  protected text: string = '';\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'text';\n  }\n\n  /**\n   * @return {string}  Return the node's text\n   */\n  public getText(): string {\n    return this.text;\n  }\n\n  /**\n   * @param {string} text  The text to use for the node\n   * @return {TextNode}  The text node (for chaining of method calls)\n   */\n  public setText(text: string): TextNode {\n    this.text = text;\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public copy() {\n    return (this.factory.create(this.kind) as TextNode).setText(this.getText());\n  }\n\n  /**\n   * Just use the text\n   */\n  public toString() {\n    return this.text;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The XMLNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class XMLNode extends AbstractMmlEmptyNode {\n  /**\n   * The XML content for this node\n   */\n  protected xml: Object = null;\n\n  /**\n   * DOM adaptor for the content\n   */\n  protected adaptor: DOMAdaptor<any, any, any> = null;\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'XML';\n  }\n\n  /**\n   * @return {Object}  Return the node's XML content\n   */\n  public getXML(): Object {\n    return this.xml;\n  }\n\n  /**\n   * @param {object} xml  The XML content to be saved\n   * @param {DOMAdaptor} adaptor DOM adaptor for the content\n   * @return {XMLNode}  The XML node (for chaining of method calls)\n   */\n  public setXML(xml: Object, adaptor: DOMAdaptor<any, any, any> = null): XMLNode {\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  }\n\n  /**\n   * @return {string}  The serialized XML content\n   */\n  public getSerializedXML(): string {\n    return this.adaptor.serializeXML(this.xml);\n  }\n\n  /**\n   * @override\n   */\n  public copy(): XMLNode {\n    return (this.factory.create(this.kind) as XMLNode).setXML(this.adaptor.clone(this.xml));\n  }\n\n  /**\n   * Just indicate that this is XML data\n   */\n  public toString() {\n    return 'XML data';\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}