{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractDOMAdaptor = void 0;\nvar AbstractDOMAdaptor = function () {\n  function AbstractDOMAdaptor(document) {\n    if (document === void 0) {\n      document = null;\n    }\n    this.document = document;\n  }\n  AbstractDOMAdaptor.prototype.node = function (kind, def, children, ns) {\n    var e_1, _a;\n    if (def === void 0) {\n      def = {};\n    }\n    if (children === void 0) {\n      children = [];\n    }\n    var node = this.create(kind, ns);\n    this.setAttributes(node, def);\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        this.append(node, child);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return node;\n  };\n  AbstractDOMAdaptor.prototype.setAttributes = function (node, def) {\n    var e_2, _a, e_3, _b, e_4, _c;\n    if (def.style && typeof def.style !== 'string') {\n      try {\n        for (var _d = __values(Object.keys(def.style)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var key = _e.value;\n          this.setStyle(node, key.replace(/-([a-z])/g, function (_m, c) {\n            return c.toUpperCase();\n          }), def.style[key]);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    if (def.properties) {\n      try {\n        for (var _f = __values(Object.keys(def.properties)), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var key = _g.value;\n          node[key] = def.properties[key];\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n    try {\n      for (var _h = __values(Object.keys(def)), _j = _h.next(); !_j.done; _j = _h.next()) {\n        var key = _j.value;\n        if ((key !== 'style' || typeof def.style === 'string') && key !== 'properties') {\n          this.setAttribute(node, key, def[key]);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n  AbstractDOMAdaptor.prototype.replace = function (nnode, onode) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  };\n  AbstractDOMAdaptor.prototype.childNode = function (node, i) {\n    return this.childNodes(node)[i];\n  };\n  AbstractDOMAdaptor.prototype.allClasses = function (node) {\n    var classes = this.getAttribute(node, 'class');\n    return !classes ? [] : classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /);\n  };\n  return AbstractDOMAdaptor;\n}();\nexports.AbstractDOMAdaptor = AbstractDOMAdaptor;","map":{"version":3,"names":["AbstractDOMAdaptor","document","prototype","node","kind","def","children","ns","create","setAttributes","children_1","__values","children_1_1","next","done","child","value","append","style","_d","Object","keys","_e","key","setStyle","replace","_m","c","toUpperCase","properties","_f","_g","_h","_j","setAttribute","nnode","onode","insert","remove","childNode","i","childNodes","allClasses","classes","getAttribute","split","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/core/DOMAdaptor.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The DOMAdaptor interface and abstract class\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\n\n/**\n * The data for an attribute\n */\nexport type AttributeData = {\n  name: string,\n  value: string\n};\n\n/**\n * The data for an elements page-based bounding box\n */\nexport type PageBBox = {\n  left: number,\n  right: number,\n  top: number,\n  bottom: number\n};\n\n\n/*****************************************************************/\n/**\n *  The interface for the DOMAdaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface DOMAdaptor<N, T, D> {\n  /**\n   * Document in which the nodes are to be created\n   */\n  document: D;\n\n  /**\n   * @param {string} text    The serialized document to be parsed\n   * @param {string} format  The format (e.g., 'text/html' or 'text/xhtml')\n   * @return {D}             The parsed document\n   */\n  parse(text: string, format?: string): D;\n\n  /**\n   * @param {string} kind      The tag name of the HTML node to be created\n   * @param {OptionList} def   The properties to set for the created node\n   * @param {(N|T)[]} children The child nodes for the created HTML node\n   * @param {string} ns        The namespace in which to create the node\n   * @return {N}               The generated HTML tree\n   */\n  node(kind: string, def?: OptionList, children?: (N | T)[], ns?: string): N;\n\n  /**\n   * @param {string} text   The text from which to create an HTML text node\n   * @return {T}            The generated text node with the given text\n   */\n  text(text: string): T;\n\n  /**\n   * @param {D} doc   The document whose head is to be obtained\n   * @return {N}      The document.head element\n   */\n  head(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose body is to be obtained\n   * @return {N}      The document.body element\n   */\n  body(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose documentElement is to be obtained\n   * @return {N}      The documentElement\n   */\n  root(doc: D): N;\n\n  /**\n   * @param {D} doc     The document whose doctype is to be obtained\n   * @return {string}   The DOCTYPE comment\n   */\n  doctype(doc: D): string;\n\n  /**\n   * @param {N} node        The node to search for tags\n   * @param {string} name   The name of the tag to search for\n   * @param {string} ns     The namespace to search in (or null for no namespace)\n   * @return {N[]}          The list of tags found\n   */\n  tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * Get a list of containers (to be searched for math).  These can be\n   *  specified by CSS selector, or as actual DOM elements or arrays of such.\n   *\n   * @param {(string | N | N[])[]} nodes  The array of items to make into a container list\n   * @param {D} document                  The document in which to search\n   * @return {N[]}                        The array of containers to search\n   */\n  getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * Determine if a container node contains a given node somewhere in its DOM tree\n   *\n   * @param {N} container  The container to search\n   * @param {N|T} node     The node to look for\n   * @return {boolean}     True if the node is in the container's DOM tree\n   */\n  contains(container: N, node: N | T): boolean;\n\n  /**\n   * @param {N|T} node  The HTML node whose parent is to be obtained\n   * @return {N}        The parent node of the given one\n   */\n  parent(node: N | T): N;\n\n  /**\n   * @param {N} node     The HTML node to be appended to\n   * @param {N|T} child  The node or text to be appended\n   * @return {N|T}       The appended node\n   */\n  append(node: N, child: N | T): N | T;\n\n  /**\n   * @param {N|T} nchild  The node or text to be inserted\n   * @param {N|T} ochild  The node or text where the new child is to be added before it\n   */\n  insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @param {N|T} child  The node or text to be removed from its parent\n   * @return {N|T}       The removed node\n   */\n  remove(child: N | T): N | T;\n\n  /**\n   * @param {N|T} nnode  The node to replace with\n   * @param {N|T} onode  The child to be replaced\n   * @return {N|T}       The removed node\n   */\n  replace(nnode: N | T, onode: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node to be cloned\n   * @return {N}       The copied node\n   */\n  clone(node: N): N;\n\n  /**\n   * @param {T} node    The HTML text node to be split\n   * @param {number} n  The index of the character where the split will occur\n   */\n  split(node: T, n: number): T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node following the given one (or null)\n   */\n  next(node: N | T): N | T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node preceding the given one (or null)\n   */\n  previous(node: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N|T}     The first child of the given node (or null)\n   */\n  firstChild(node: N): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N}       The last child of the given node (or null)\n   */\n  lastChild(node: N): N | T;\n\n  /**\n   * @param {N} node    The HTML node whose children are to be obtained\n   * @return {(N|T)[]}  Array of children for the given node (not a live list)\n   */\n  childNodes(node: N): (N | T)[];\n\n  /**\n   * @param {N} node    The HTML node whose child is to be obtained\n   * @param {number} i  The index of the child to return\n   * @return {N|T}      The i-th child node of the given node (or null)\n   */\n  childNode(node: N, i: number): N | T;\n\n  /**\n   * @param {N | T} node   The HTML node whose tag or node name is to be obtained\n   * @return {string}      The tag or node name of the given node\n   */\n  kind(node: N | T): string;\n\n  /**\n   * @param {N|T} node  The HTML node whose value is to be obtained\n   * @return {string}   The value of the given node\n   */\n  value(node: N | T): string;\n\n  /**\n   * @param {N} node    The HTML node whose text content is to be obtained\n   * @return {string}   The text content of the given node\n   */\n  textContent(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose inner HTML string is to be obtained\n   * @return {string}  The serialized content of the node\n   */\n  innerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose outer HTML string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  outerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose serialized string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  serializeXML(node: N): string;\n\n  /**\n   * @param {N} node               The HTML node whose attribute is to be set\n   * @param {string|number} name   The name of the attribute to set\n   * @param {string} value         The new value of the attribute\n   * @param {string=} ns           The namespace to use for the attribute\n   */\n  setAttribute(node: N, name: string, value: string | number, ns?: string): void;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  setAttributes(node: N, def: OptionList): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be obtained\n   * @param {string} name   The name of the attribute to get\n   * @return {string}       The value of the given attribute of the given node\n   */\n  getAttribute(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be removed\n   * @param {string} name   The name of the attribute to remove\n   */\n  removeAttribute(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be tested\n   * @param {string} name   The name of the attribute to test\n   * @return {boolean}      True of the node has the given attribute defined\n   */\n  hasAttribute(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node           The HTML node whose attributes are to be returned\n   * @return {AttributeData[]} The list of attributes\n   */\n  allAttributes(node: N): AttributeData[];\n\n  /**\n   * @param {N} node        The HTML node whose class is to be augmented\n   * @param {string} name   The class to be added\n   */\n  addClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be changed\n   * @param {string} name   The class to be removed\n   */\n  removeClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be tested\n   * @param {string} name   The class to test\n   * @return {boolean}      True if the node has the given class\n   */\n  hasClass(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node        The HTML node whose class list is needed\n   * @return {string[]}     An array of the class names for this node\n   */\n  allClasses(node: N): string[];\n\n  /**\n   * @param {N} node        The HTML node whose style is to be changed\n   * @param {string} name   The style to be set\n   * @param {string} value  The new value of the style\n   */\n  setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose style is to be obtained\n   * @param {string} name   The style to be obtained\n   * @return {string}       The value of the style\n   */\n  getStyle(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose styles are to be returned\n   * @return {string}       The cssText for the styles\n   */\n  allStyles(node: N): string;\n\n  /**\n   * @param {N} node           The stylesheet node where the rule will be added\n   * @param {string[]} rules   The rule to add at the beginning of the stylesheet\n   */\n  insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @param {N} node        The HTML node whose font size is to be determined\n   * @return {number}       The font size (in pixels) of the node\n   */\n  fontSize(node: N): number;\n\n  /**\n   * @param {N} node        The HTML node whose font family is to be determined\n   * @return {string}       The font family\n   */\n  fontFamily(node: N): string;\n\n  /**\n   * @param {N} node            The HTML node whose dimensions are to be determined\n   * @param {number} em         The number of pixels in an em\n   * @param {boolean} local     True if local coordinates are to be used in SVG elements\n   * @return {[number, number]} The width and height (in ems) of the element\n   */\n  nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n\n  /**\n   * @param {N} node            The HTML node whose BBox is to be determined\n   * @return {PageBBox}         BBox as {left, right, top, bottom} position on the page (in pixels)\n   */\n  nodeBBox(node: N): PageBBox;\n}\n\n/*****************************************************************/\n/**\n *  Abstract DOMAdaptor class for creating HTML elements\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractDOMAdaptor<N, T, D> implements DOMAdaptor<N, T, D> {\n\n  /**\n   * The document in which the HTML nodes will be created\n   */\n  public document: D;\n\n  /**\n   * @param {D} document  The document in which the nodes will be created\n   * @constructor\n   */\n  constructor(document: D = null) {\n    this.document = document;\n  }\n\n  /**\n   * @override\n   */\n  public abstract parse(text: string, format?: string): D;\n\n  /**\n   * @override\n   */\n  public node(kind: string, def: OptionList = {}, children: (N | T)[] = [], ns?: string) {\n    const node = this.create(kind, ns);\n    this.setAttributes(node, def);\n    for (const child of children) {\n      this.append(node, child);\n    }\n    return node as N;\n  }\n\n  /**\n   * @param {string} kind  The type of the node to create\n   * @param {string} ns    The optional namespace in which to create the node\n   * @return {N}           The created node\n   */\n  protected abstract create(kind: string, ns?: string): N;\n\n  /**\n   * @override\n   */\n  public abstract text(text: string): T;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  public setAttributes(node: N, def: OptionList) {\n    if (def.style && typeof(def.style) !== 'string') {\n      for (let key of Object.keys(def.style)) {\n        this.setStyle(node, key.replace(/-([a-z])/g, (_m, c) => c.toUpperCase()), def.style[key]);\n      }\n    }\n    if (def.properties) {\n      for (let key of Object.keys(def.properties)) {\n        (node as OptionList)[key] = def.properties[key];\n      }\n    }\n    for (let key of Object.keys(def)) {\n      if ((key !== 'style' || typeof(def.style) === 'string') && key !== 'properties') {\n        this.setAttribute(node, key, def[key]);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public abstract head(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract body(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract root(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract doctype(doc: D): string;\n\n  /**\n   * @override\n   */\n  public abstract tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * @override\n   */\n  public abstract getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * @override\n   */\n  public abstract contains(container: N, node: N | T): boolean;\n\n  /**\n   * @override\n   */\n  public abstract parent(node: N | T): N;\n\n  /**\n   * @override\n   */\n  public abstract append(node: N, child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @override\n   */\n  public abstract remove(child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  }\n\n  /**\n   * @override\n   */\n  public abstract clone(node: N):  N;\n\n  /**\n   * @override\n   */\n  public abstract split(node: T, n: number): T;\n\n  /**\n   * @override\n   */\n  public abstract next(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract previous(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract firstChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract lastChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract childNodes(node: N): (N | T)[];\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return this.childNodes(node)[i];\n  }\n\n  /**\n   * @override\n   */\n  public abstract kind(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract value(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract textContent(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract innerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract outerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract serializeXML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract setAttribute(node: N, name: string, value: string, ns?: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getAttribute(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract removeAttribute(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasAttribute(node: N, name: string): boolean;\n\n\n  /**\n   * @override\n   */\n  public abstract allAttributes(node: N): AttributeData[];\n\n  /**\n   * @override\n   */\n  public abstract addClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract removeClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasClass(node: N, name: string): boolean;\n\n  /**\n   * @override\n   */\n  public allClasses(node: N) {\n    const classes = this.getAttribute(node, 'class');\n    return (!classes ? [] as string[] :\n            classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /));\n  }\n\n  /**\n   * @override\n   */\n  public abstract setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getStyle(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract allStyles(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @override\n   */\n  public abstract fontSize(node: N): number;\n\n  /**\n   * @override\n   */\n  public abstract fontFamily(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n  /**\n   * @override\n   */\n  public abstract nodeBBox(node: N): PageBBox;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}