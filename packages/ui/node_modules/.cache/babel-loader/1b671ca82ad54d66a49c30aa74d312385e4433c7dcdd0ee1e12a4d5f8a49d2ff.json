{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearDocument = exports.saveDocument = exports.makeBsprAttributes = exports.removeProperty = exports.getProperty = exports.setProperty = exports.balanceRules = void 0;\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar doc = null;\nvar item = null;\nvar getBBox = function (node) {\n  item.root = node;\n  var width = doc.outputJax.getBBox(item, doc).w;\n  return width;\n};\nvar getRule = function (node) {\n  var i = 0;\n  while (node && !NodeUtil_js_1.default.isType(node, 'mtable')) {\n    if (NodeUtil_js_1.default.isType(node, 'text')) {\n      return null;\n    }\n    if (NodeUtil_js_1.default.isType(node, 'mrow')) {\n      node = node.childNodes[0];\n      i = 0;\n      continue;\n    }\n    node = node.parent.childNodes[i];\n    i++;\n  }\n  return node;\n};\nvar getPremises = function (rule, direction) {\n  return rule.childNodes[direction === 'up' ? 1 : 0].childNodes[0].childNodes[0].childNodes[0].childNodes[0];\n};\nvar getPremise = function (premises, n) {\n  return premises.childNodes[n].childNodes[0].childNodes[0];\n};\nvar firstPremise = function (premises) {\n  return getPremise(premises, 0);\n};\nvar lastPremise = function (premises) {\n  return getPremise(premises, premises.childNodes.length - 1);\n};\nvar getConclusion = function (rule, direction) {\n  return rule.childNodes[direction === 'up' ? 0 : 1].childNodes[0].childNodes[0].childNodes[0];\n};\nvar getColumn = function (inf) {\n  while (inf && !NodeUtil_js_1.default.isType(inf, 'mtd')) {\n    inf = inf.parent;\n  }\n  return inf;\n};\nvar nextSibling = function (inf) {\n  return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) + 1];\n};\nvar previousSibling = function (inf) {\n  return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) - 1];\n};\nvar getParentInf = function (inf) {\n  while (inf && (0, exports.getProperty)(inf, 'inference') == null) {\n    inf = inf.parent;\n  }\n  return inf;\n};\nvar getSpaces = function (inf, rule, right) {\n  if (right === void 0) {\n    right = false;\n  }\n  var result = 0;\n  if (inf === rule) {\n    return result;\n  }\n  if (inf !== rule.parent) {\n    var children_1 = inf.childNodes;\n    var index_1 = right ? children_1.length - 1 : 0;\n    if (NodeUtil_js_1.default.isType(children_1[index_1], 'mspace')) {\n      result += getBBox(children_1[index_1]);\n    }\n    inf = rule.parent;\n  }\n  if (inf === rule) {\n    return result;\n  }\n  var children = inf.childNodes;\n  var index = right ? children.length - 1 : 0;\n  if (children[index] !== rule) {\n    result += getBBox(children[index]);\n  }\n  return result;\n};\nvar adjustValue = function (inf, right) {\n  if (right === void 0) {\n    right = false;\n  }\n  var rule = getRule(inf);\n  var conc = getConclusion(rule, (0, exports.getProperty)(rule, 'inferenceRule'));\n  var w = getSpaces(inf, rule, right);\n  var x = getBBox(rule);\n  var y = getBBox(conc);\n  return w + (x - y) / 2;\n};\nvar addSpace = function (config, inf, space, right) {\n  if (right === void 0) {\n    right = false;\n  }\n  if ((0, exports.getProperty)(inf, 'inferenceRule') || (0, exports.getProperty)(inf, 'labelledRule')) {\n    var mrow = config.nodeFactory.create('node', 'mrow');\n    inf.parent.replaceChild(mrow, inf);\n    mrow.setChildren([inf]);\n    moveProperties(inf, mrow);\n    inf = mrow;\n  }\n  var index = right ? inf.childNodes.length - 1 : 0;\n  var mspace = inf.childNodes[index];\n  if (NodeUtil_js_1.default.isType(mspace, 'mspace')) {\n    NodeUtil_js_1.default.setAttribute(mspace, 'width', ParseUtil_js_1.default.Em(ParseUtil_js_1.default.dimen2em(NodeUtil_js_1.default.getAttribute(mspace, 'width')) + space));\n    return;\n  }\n  mspace = config.nodeFactory.create('node', 'mspace', [], {\n    width: ParseUtil_js_1.default.Em(space)\n  });\n  if (right) {\n    inf.appendChild(mspace);\n    return;\n  }\n  mspace.parent = inf;\n  inf.childNodes.unshift(mspace);\n};\nvar moveProperties = function (src, dest) {\n  var props = ['inference', 'proof', 'maxAdjust', 'labelledRule'];\n  props.forEach(function (x) {\n    var value = (0, exports.getProperty)(src, x);\n    if (value != null) {\n      (0, exports.setProperty)(dest, x, value);\n      (0, exports.removeProperty)(src, x);\n    }\n  });\n};\nvar adjustSequents = function (config) {\n  var sequents = config.nodeLists['sequent'];\n  if (!sequents) {\n    return;\n  }\n  for (var i = sequents.length - 1, seq = void 0; seq = sequents[i]; i--) {\n    if ((0, exports.getProperty)(seq, 'sequentProcessed')) {\n      (0, exports.removeProperty)(seq, 'sequentProcessed');\n      continue;\n    }\n    var collect = [];\n    var inf = getParentInf(seq);\n    if ((0, exports.getProperty)(inf, 'inference') !== 1) {\n      continue;\n    }\n    collect.push(seq);\n    while ((0, exports.getProperty)(inf, 'inference') === 1) {\n      inf = getRule(inf);\n      var premise = firstPremise(getPremises(inf, (0, exports.getProperty)(inf, 'inferenceRule')));\n      var sequent = (0, exports.getProperty)(premise, 'inferenceRule') ? getConclusion(premise, (0, exports.getProperty)(premise, 'inferenceRule')) : premise;\n      if ((0, exports.getProperty)(sequent, 'sequent')) {\n        seq = sequent.childNodes[0];\n        collect.push(seq);\n        (0, exports.setProperty)(seq, 'sequentProcessed', true);\n      }\n      inf = premise;\n    }\n    adjustSequentPairwise(config, collect);\n  }\n};\nvar addSequentSpace = function (config, sequent, position, direction, width) {\n  var mspace = config.nodeFactory.create('node', 'mspace', [], {\n    width: ParseUtil_js_1.default.Em(width)\n  });\n  if (direction === 'left') {\n    var row = sequent.childNodes[position].childNodes[0];\n    mspace.parent = row;\n    row.childNodes.unshift(mspace);\n  } else {\n    sequent.childNodes[position].appendChild(mspace);\n  }\n  (0, exports.setProperty)(sequent.parent, 'sequentAdjust_' + direction, width);\n};\nvar adjustSequentPairwise = function (config, sequents) {\n  var top = sequents.pop();\n  while (sequents.length) {\n    var bottom = sequents.pop();\n    var _a = __read(compareSequents(top, bottom), 2),\n      left = _a[0],\n      right = _a[1];\n    if ((0, exports.getProperty)(top.parent, 'axiom')) {\n      addSequentSpace(config, left < 0 ? top : bottom, 0, 'left', Math.abs(left));\n      addSequentSpace(config, right < 0 ? top : bottom, 2, 'right', Math.abs(right));\n    }\n    top = bottom;\n  }\n};\nvar compareSequents = function (top, bottom) {\n  var tr = getBBox(top.childNodes[2]);\n  var br = getBBox(bottom.childNodes[2]);\n  var tl = getBBox(top.childNodes[0]);\n  var bl = getBBox(bottom.childNodes[0]);\n  var dl = tl - bl;\n  var dr = tr - br;\n  return [dl, dr];\n};\nvar balanceRules = function (arg) {\n  var e_1, _a;\n  item = new arg.document.options.MathItem('', null, arg.math.display);\n  var config = arg.data;\n  adjustSequents(config);\n  var inferences = config.nodeLists['inference'] || [];\n  try {\n    for (var inferences_1 = __values(inferences), inferences_1_1 = inferences_1.next(); !inferences_1_1.done; inferences_1_1 = inferences_1.next()) {\n      var inf = inferences_1_1.value;\n      var isProof = (0, exports.getProperty)(inf, 'proof');\n      var rule = getRule(inf);\n      var premises = getPremises(rule, (0, exports.getProperty)(rule, 'inferenceRule'));\n      var premiseF = firstPremise(premises);\n      if ((0, exports.getProperty)(premiseF, 'inference')) {\n        var adjust_1 = adjustValue(premiseF);\n        if (adjust_1) {\n          addSpace(config, premiseF, -adjust_1);\n          var w_1 = getSpaces(inf, rule, false);\n          addSpace(config, inf, adjust_1 - w_1);\n        }\n      }\n      var premiseL = lastPremise(premises);\n      if ((0, exports.getProperty)(premiseL, 'inference') == null) {\n        continue;\n      }\n      var adjust = adjustValue(premiseL, true);\n      addSpace(config, premiseL, -adjust, true);\n      var w = getSpaces(inf, rule, true);\n      var maxAdjust = (0, exports.getProperty)(inf, 'maxAdjust');\n      if (maxAdjust != null) {\n        adjust = Math.max(adjust, maxAdjust);\n      }\n      var column = void 0;\n      if (isProof || !(column = getColumn(inf))) {\n        addSpace(config, (0, exports.getProperty)(inf, 'proof') ? inf : inf.parent, adjust - w, true);\n        continue;\n      }\n      var sibling = nextSibling(column);\n      if (sibling) {\n        var pos = config.nodeFactory.create('node', 'mspace', [], {\n          width: adjust - w + 'em'\n        });\n        sibling.appendChild(pos);\n        inf.removeProperty('maxAdjust');\n        continue;\n      }\n      var parentRule = getParentInf(column);\n      if (!parentRule) {\n        continue;\n      }\n      adjust = (0, exports.getProperty)(parentRule, 'maxAdjust') ? Math.max((0, exports.getProperty)(parentRule, 'maxAdjust'), adjust) : adjust;\n      (0, exports.setProperty)(parentRule, 'maxAdjust', adjust);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (inferences_1_1 && !inferences_1_1.done && (_a = inferences_1.return)) _a.call(inferences_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n};\nexports.balanceRules = balanceRules;\nvar property_prefix = 'bspr_';\nvar blacklistedProperties = (_a = {}, _a[property_prefix + 'maxAdjust'] = true, _a);\nvar setProperty = function (node, property, value) {\n  NodeUtil_js_1.default.setProperty(node, property_prefix + property, value);\n};\nexports.setProperty = setProperty;\nvar getProperty = function (node, property) {\n  return NodeUtil_js_1.default.getProperty(node, property_prefix + property);\n};\nexports.getProperty = getProperty;\nvar removeProperty = function (node, property) {\n  node.removeProperty(property_prefix + property);\n};\nexports.removeProperty = removeProperty;\nvar makeBsprAttributes = function (arg) {\n  arg.data.root.walkTree(function (mml, _data) {\n    var attr = [];\n    mml.getPropertyNames().forEach(function (x) {\n      if (!blacklistedProperties[x] && x.match(RegExp('^' + property_prefix))) {\n        attr.push(x + ':' + mml.getProperty(x));\n      }\n    });\n    if (attr.length) {\n      NodeUtil_js_1.default.setAttribute(mml, 'semantics', attr.join(';'));\n    }\n  });\n};\nexports.makeBsprAttributes = makeBsprAttributes;\nvar saveDocument = function (arg) {\n  doc = arg.document;\n  if (!('getBBox' in doc.outputJax)) {\n    throw Error('The bussproofs extension requires an output jax with a getBBox() method');\n  }\n};\nexports.saveDocument = saveDocument;\nvar clearDocument = function (_arg) {\n  doc = null;\n};\nexports.clearDocument = clearDocument;","map":{"version":3,"names":["NodeUtil_js_1","__importDefault","require","ParseUtil_js_1","doc","item","getBBox","node","root","width","outputJax","w","getRule","i","default","isType","childNodes","parent","getPremises","rule","direction","getPremise","premises","n","firstPremise","lastPremise","length","getConclusion","getColumn","inf","nextSibling","indexOf","previousSibling","getParentInf","exports","getProperty","getSpaces","right","result","children_1","index_1","children","index","adjustValue","conc","x","y","addSpace","config","space","mrow","nodeFactory","create","replaceChild","setChildren","moveProperties","mspace","setAttribute","Em","dimen2em","getAttribute","appendChild","unshift","src","dest","props","forEach","value","setProperty","removeProperty","adjustSequents","sequents","nodeLists","seq","collect","push","premise","sequent","adjustSequentPairwise","addSequentSpace","position","row","top","pop","bottom","_a","__read","compareSequents","left","Math","abs","tr","br","tl","bl","dl","dr","balanceRules","arg","document","options","MathItem","math","display","data","inferences","inferences_1","__values","inferences_1_1","next","done","isProof","premiseF","adjust_1","w_1","premiseL","adjust","maxAdjust","max","column","sibling","pos","parentRule","property_prefix","blacklistedProperties","property","makeBsprAttributes","walkTree","mml","_data","attr","getPropertyNames","match","RegExp","join","saveDocument","Error","clearDocument","_arg"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/bussproofs/BussproofsUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Postfilter utility for the Bussproofs package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport ParseOptions from '../ParseOptions.js';\nimport NodeUtil from '../NodeUtil.js';\nimport ParseUtil from '../ParseUtil.js';\n\nimport {MmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {Property} from '../../../core/Tree/Node.js';\nimport {MathItem} from '../../../core/MathItem.js';\nimport {MathDocument} from '../../../core/MathDocument.js';\n\n\ntype MATHITEM = MathItem<any, any, any>;\ntype MATHDOCUMENT = MathDocument<any, any, any>;\n\ntype FilterData = {math: MATHITEM, document: MATHDOCUMENT, data: ParseOptions};\n\n/**\n *  Global constants local to the module. They instantiate an output jax for\n *  bounding box computation.\n */\nlet doc: MATHDOCUMENT = null;\nlet item: MATHITEM = null;\n\n\n/**\n * Get the bounding box of a node.\n * @param {MmlNode} node The target node.\n */\nlet getBBox = function(node: MmlNode) {\n  item.root = node;\n    let {w: width} = (doc.outputJax as any).getBBox(item, doc);\n  return width;\n};\n\n\n/**\n * Get the actual table that represents the inference rule, i.e., the rule\n * without the label. We ignore preceding elements or spaces.\n *\n * @param {MmlNode} node The out node representing the inference.\n * @return {MmlNode} The actual table representing the inference rule.\n */\nlet getRule = function(node: MmlNode): MmlNode {\n  let i = 0;\n  while (node && !NodeUtil.isType(node, 'mtable')) {\n    if (NodeUtil.isType(node, 'text')) {\n      return null;\n    }\n    if (NodeUtil.isType(node, 'mrow')) {\n      node = node.childNodes[0] as MmlNode;\n      i = 0;\n      continue;\n    }\n    node = node.parent.childNodes[i] as MmlNode;\n    i++;\n  }\n  return node;\n};\n\n\n/*******************************\n * Convenience methods for retrieving bits of the proof tree.\n */\n\n/**\n * Gets premises of an inference rule.\n * @param {MmlNode} rule The rule.\n * @param {string} direction Up or down.\n * @return {MmlNode} The premisses.\n */\nlet getPremises = function(rule: MmlNode, direction: string): MmlNode {\n  return rule.childNodes[direction === 'up' ? 1 : 0].childNodes[0].\n    childNodes[0].childNodes[0].childNodes[0] as MmlNode;\n};\n\n\n/**\n * Gets nth premise.\n * @param {MmlNode} premises The premises.\n * @param {number} n Number of premise to get.\n * @return {MmlNode} The nth premise.\n */\nlet getPremise = function(premises: MmlNode, n: number): MmlNode {\n  return premises.childNodes[n].childNodes[0].childNodes[0] as MmlNode;\n};\n\n\n/**\n * Gets first premise.\n * @param {MmlNode} premises The premises.\n * @return {MmlNode} The first premise.\n */\nlet firstPremise = function(premises: MmlNode): MmlNode {\n  return getPremise(premises, 0) as MmlNode;\n};\n\n\n/**\n * Gets last premise.\n * @param {MmlNode} premises The premises.\n * @return {MmlNode} The last premise.\n */\nlet lastPremise = function(premises: MmlNode): MmlNode {\n  return getPremise(premises, premises.childNodes.length - 1);\n};\n\n\n/**\n * Get conclusion in an inference rule.\n * @param {MmlNode} rule The rule.\n * @param {string} direction Up or down.\n * @return {MmlNode} The conclusion.\n */\nlet getConclusion = function(rule: MmlNode, direction: string): MmlNode {\n  return rule.childNodes[direction === 'up' ? 0 : 1].childNodes[0].childNodes[0].childNodes[0] as MmlNode;\n};\n\n\n/**\n * Gets the actual column element in an inference rule. I.e., digs down through\n * row, padding and space elements.\n * @param {MmlNode} inf The rule.\n * @return {MmlNode} The mtd element.\n */\nlet getColumn = function(inf: MmlNode): MmlNode {\n  while (inf && !NodeUtil.isType(inf, 'mtd')) {\n    inf = inf.parent as MmlNode;\n  }\n  return inf;\n};\n\n\n/**\n * Gets the next sibling of an inference rule.\n * @param {MmlNode} inf The inference rule.\n * @return {MmlNode} The next sibling.\n */\nlet nextSibling = function(inf: MmlNode): MmlNode {\n  return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) + 1] as MmlNode;\n};\n\n\n/**\n * Gets the previous sibling of an inference rule.\n * @param {MmlNode} inf The inference rule.\n * @return {MmlNode} The previous sibling.\n */\n// @ts-ignore\nlet previousSibling = function(inf: MmlNode): MmlNode {\n  return inf.parent.childNodes[inf.parent.childNodes.indexOf(inf) - 1] as MmlNode;\n};\n\n\n/**\n * Get the parent inference rule.\n * @param {MmlNode} inf The inference rule.\n * @return {MmlNode} Its parent.\n */\nlet getParentInf = function(inf: MmlNode): MmlNode {\n  while (inf && getProperty(inf, 'inference') == null) {\n    inf = inf.parent as MmlNode;\n  }\n  return inf;\n};\n\n\n// Computes bbox spaces\n//\n//\n\n/**\n * Computes spacing left or right of an inference rule. In the case of\n * right: right space + right label\n * left: left space + left label\n * @param {MmlNode} inf The overall proof tree.\n * @param {MmlNode} rule The particular inference rule.\n * @param {boolean = false} right True for right, o/w left.\n * @return {number} The spacing next to the rule.\n */\nlet getSpaces = function(inf: MmlNode, rule: MmlNode, right: boolean = false): number {\n  let result = 0;\n  if (inf === rule) {\n    return result;\n  }\n  if (inf !== rule.parent) {\n    let children = inf.childNodes as MmlNode[];\n    let index = right ? children.length - 1 : 0;\n    if (NodeUtil.isType(children[index], 'mspace')) {\n      result += getBBox(children[index]);\n    }\n    inf = rule.parent;\n  }\n  if (inf === rule) {\n    return result;\n  }\n  let children = inf.childNodes as MmlNode[];\n  let index = right ? children.length - 1 : 0;\n  if (children[index] !== rule) {\n    result += getBBox(children[index]);\n  }\n  return result;\n};\n\n\n// - Get rule T from Wrapper W.\n// - Get conclusion C in T.\n// - w: Preceding/following space/label.\n// - (x - y)/2: Distance from left boundary to middle of C.\n/**\n * Computes an space adjustment value to move the inference rule.\n * @param {MmlNode} inf The inference rule.\n * @param {boolean = false} right True if adjustments are on the right.\n * @return {number} The adjustment value.\n */\nlet adjustValue = function(inf: MmlNode, right: boolean = false): number {\n  let rule = getRule(inf);\n  let conc = getConclusion(rule, getProperty(rule, 'inferenceRule') as string);\n  // TODO:  Here we have to improve sequent adjustment!\n  let w = getSpaces(inf, rule, right);\n  let x = getBBox(rule);\n  let y = getBBox(conc);\n  return w + ((x - y) / 2);\n};\n\n\n/**\n * Adds (positive or negative) space in the column containing the inference rule.\n * @param {ParseOptions} config The parser configuration.\n * @param {MmlNode} inf The inference rule to place.\n * @param {number} space The space to be added.\n * @param {boolean = false} right True if adjustment is on the right.\n */\nlet addSpace = function(config: ParseOptions, inf: MmlNode,\n                        space: number, right: boolean = false) {\n  if (getProperty(inf, 'inferenceRule') ||\n      getProperty(inf, 'labelledRule')) {\n    const mrow = config.nodeFactory.create('node', 'mrow');\n    inf.parent.replaceChild(mrow, inf);\n    mrow.setChildren([inf]);\n    moveProperties(inf, mrow);\n    inf = mrow;\n  }\n  // TODO: Simplify below as we now have a definite mrow.\n  const index = right ? inf.childNodes.length - 1 : 0;\n  let mspace = inf.childNodes[index] as MmlNode;\n  if (NodeUtil.isType(mspace, 'mspace')) {\n    NodeUtil.setAttribute(\n      mspace, 'width',\n      ParseUtil.Em(ParseUtil.dimen2em(\n        NodeUtil.getAttribute(mspace, 'width') as string) + space));\n    return;\n  }\n  mspace = config.nodeFactory.create('node', 'mspace', [],\n                                     {width: ParseUtil.Em(space)});\n  if (right) {\n    inf.appendChild(mspace);\n    return;\n  }\n  mspace.parent = inf;\n  inf.childNodes.unshift(mspace);\n};\n\n\n/**\n * Propagates properties up the tree.\n * @param {MmlNode} src The source node.\n * @param {MmlNode} dest The destination node.\n */\nlet moveProperties = function(src: MmlNode, dest: MmlNode) {\n  let props = ['inference', 'proof', 'maxAdjust', 'labelledRule'];\n  props.forEach(x => {\n    let value = getProperty(src, x);\n    if (value != null) {\n      setProperty(dest, x, value);\n      removeProperty(src, x);\n    }\n  });\n};\n\n\n\n/********************************\n * The following methods deal with sequents. There are still issues with the\n * spatial layout, though.\n */\n// Sequents look like this: table row 3 cells\n// The table has the 'sequent' property.\n// The row is the node that is actually saved in the config object.\n/**\n * Method to adjust sequent positioning after the tree is computed.\n * @param {ParseOptions} config Parser configuration options.\n */\nlet adjustSequents = function(config: ParseOptions) {\n  let sequents = config.nodeLists['sequent'];\n  if (!sequents) {\n    return;\n  }\n  for (let i = sequents.length - 1, seq; seq = sequents[i]; i--) {\n    if (getProperty(seq, 'sequentProcessed')) {\n      removeProperty(seq, 'sequentProcessed');\n      continue;\n    }\n    let collect = [];\n    let inf = getParentInf(seq);\n    if (getProperty(inf, 'inference') !== 1) {\n      continue;\n    }\n    collect.push(seq);\n    while (getProperty(inf, 'inference') === 1) {\n      // In case we have a table with a label.\n      inf = getRule(inf);\n      let premise = firstPremise(getPremises(inf, getProperty(inf, 'inferenceRule') as string));\n      let sequent = (getProperty(premise, 'inferenceRule')) ?\n        // If the first premise is an inference rule, check the conclusions for a sequent.\n        getConclusion(premise, getProperty(premise, 'inferenceRule') as string) :\n        // Otherwise it is a hyp and we have to check the formula itself.\n        premise;\n      if (getProperty(sequent, 'sequent')) {\n        seq = sequent.childNodes[0] as MmlNode;\n        collect.push(seq);\n        setProperty(seq, 'sequentProcessed', true);\n      }\n      inf = premise;\n    }\n    adjustSequentPairwise(config, collect);\n  }\n};\n\n\n/**\n * Add spaces to the sequents where necessary.\n * @param {ParseOptions} config Parser configuration options.\n * @param {MmlNode} sequent The sequent inference rule.\n * @param {number} position Position of formula to adjust (0 or 2).\n * @param {string} direction Left or right of the turnstyle.\n * @param {number} width The space to add to the formulas.\n */\nconst addSequentSpace = function(config: ParseOptions, sequent: MmlNode,\n                                 position: number, direction: string, width: number) {\n  let mspace = config.nodeFactory.create('node', 'mspace', [],\n                                         {width: ParseUtil.Em(width)});\n  if (direction === 'left') {\n    let row = sequent.childNodes[position].childNodes[0] as MmlNode;\n    mspace.parent = row;\n    row.childNodes.unshift(mspace);\n  } else {\n    sequent.childNodes[position].appendChild(mspace);\n  }\n  setProperty(sequent.parent, 'sequentAdjust_' + direction, width);\n};\n\n\n/**\n * Adjusts the sequent positioning for a list of inference rules by pairwise\n * adjusting the width of formulas in sequents. I.e.,\n *    A,B |- C\n * ------------\n *    A |- B,C\n *\n * will be adjusted to\n *\n *    A, B |- C\n * ----------------\n *       A |- B,C\n *\n * @param {ParseOptions} config Parser configuration options.\n * @param {MmlNode[]} sequents The list of sequents.\n */\nconst adjustSequentPairwise = function(config: ParseOptions, sequents: MmlNode[]) {\n  let top = sequents.pop();\n  while (sequents.length) {\n    let bottom = sequents.pop();\n    let [left, right] = compareSequents(top, bottom);\n    if (getProperty(top.parent, 'axiom')) {\n      addSequentSpace(config, left < 0 ? top : bottom, 0, 'left', Math.abs(left));\n      addSequentSpace(config, right < 0 ? top : bottom, 2, 'right', Math.abs(right));\n    }\n    top = bottom;\n  }\n};\n\n\n/**\n * Compares the top and bottom sequent of a inference rule\n * Top:     A |- B\n *        ----------\n * Bottom:  C |- D\n *\n * @param {MmlNode} top Top sequent.\n * @param {MmlNode} bottom Bottom sequent.\n * @return {[number, number]} The delta for left and right side of the sequents.\n */\nconst compareSequents = function(top: MmlNode, bottom: MmlNode): [number, number] {\n  const tr = getBBox(top.childNodes[2] as MmlNode);\n  const br = getBBox(bottom.childNodes[2] as MmlNode);\n  const tl = getBBox(top.childNodes[0] as MmlNode);\n  const bl = getBBox(bottom.childNodes[0] as MmlNode);\n  // Deltas\n  const dl = tl - bl;\n  const dr = tr - br;\n  return [dl, dr];\n};\n\n// For every inference rule we adjust the width of ruler by subtracting and\n// adding suitable spaces around the rule. The algorithm in detail.\n//\n// Notions that we need:\n//\n//\n// * Inference: The inference consisting either of an inference rule or a\n//              structure containing the rule plus 0 - 2 labels and spacing\n//              elements.  s l{0,1} t r{0,1} s', m,n \\in IN_0\n//\n//              Technically this is realised as nested rows, if the spaces\n//              and/or labels exist:\n//              mr s mr l t r /mr s' /mr\n//\n// * InferenceRule: The rule without the labels and spacing.\n//\n// * Conclusion: The element forming the conclusion of the rule. In\n//               downwards inferences this is the final row of the table.\n//\n// * Premises: The premises of the rule. In downwards inferences this is the\n//             first row of the rule. Note that this is a rule itself,\n//             with one column for each premise and an empty column\n//             inbetween.\n//\n// * |x|: Width of bounding box of element x.\n//\n// Left adjustment:\n//\n// * For the given inference I:\n//    + compute rule R of I\n//    + compute premises P of I\n//    + compute premise P_f, P_l as first and last premise of I\n//\n// * If P_f is an inference rule:\n//    + compute adjust value a_f for wrapper W_f of P_f\n//    + add -a_f space to wrapper W_f\n//    + add  a_f space to wrapper W\n//\n// * If P_l is an inference rule:\n//   + compute adjust value a_l for wrapper W_l of P_l\n//   + if I has (right) label L: a_l = a_l + |L|\n//   + add -a_l space to P_l\n//   + a_l = max(a_l, A_I), where A_I is saved ajust value in the\n//     \"maxAdjust\" attribute of I.\n//\n//   + Case I is proof: Add a_l space to inf. (Correct after proof.)\n//   + Case I has sibling: Add a_l space to sibling.  (Correct after column.)\n//   + Otherwise: Propagate a_l by\n//                ++ find direct parent infererence rule I'\n//                ++ Set A_{I'} = a_l.\n//\n/**\n * Implements the above algorithm.\n * @param {FilterData} arg The parser configuration and mathitem to filter.\n */\nexport let balanceRules = function(arg: FilterData) {\n  item = new arg.document.options.MathItem('', null, arg.math.display);\n  let config = arg.data;\n  adjustSequents(config);\n  let inferences = config.nodeLists['inference'] || [];\n  for (let inf of inferences) {\n    let isProof = getProperty(inf, 'proof');\n    // This currently only works with downwards rules.\n    let rule = getRule(inf);\n    let premises = getPremises(rule, getProperty(rule, 'inferenceRule') as string);\n    let premiseF = firstPremise(premises);\n    if (getProperty(premiseF, 'inference')) {\n      let adjust = adjustValue(premiseF);\n      if (adjust) {\n        addSpace(config, premiseF, -adjust);\n        let w = getSpaces(inf, rule, false);\n        addSpace(config, inf, adjust - w);\n      }\n    }\n    // Right adjust:\n    let premiseL = lastPremise(premises);\n    if (getProperty(premiseL, 'inference') == null) {\n      continue;\n    }\n    let adjust = adjustValue(premiseL, true);\n    addSpace(config, premiseL, -adjust, true);\n    let w = getSpaces(inf, rule, true);\n    let maxAdjust = getProperty(inf, 'maxAdjust') as number;\n    if (maxAdjust != null) {\n      adjust = Math.max(adjust, maxAdjust);\n    }\n    let column: MmlNode;\n    if (isProof || !(column = getColumn(inf))) {\n      // After the tree we add a space with the accumulated max value.\n      // If the element is not in a column, we know we have some noise and the\n      // proof is an mrow around the final inference.\n      addSpace(config,\n               // in case the rule has been moved into an mrow in Left Adjust.\n               getProperty(inf, 'proof') ? inf : inf.parent, adjust - w, true);\n      continue;\n    }\n    let sibling = nextSibling(column);\n    if (sibling) {\n      // If there is a next column, it is the empty one and we make it wider by\n      // the accumulated max value.\n      const pos = config.nodeFactory.create('node', 'mspace', [],\n                                            {width: adjust - w + 'em'});\n      sibling.appendChild(pos);\n      inf.removeProperty('maxAdjust');\n      continue;\n    }\n    let parentRule = getParentInf(column);\n    if (!parentRule) {\n      continue;\n    }\n    // We are currently in rightmost inference, so we propagate the max\n    // correction value up in the tree.\n    adjust = getProperty(parentRule, 'maxAdjust') ?\n      Math.max(getProperty(parentRule, 'maxAdjust') as number, adjust) : adjust;\n    setProperty(parentRule, 'maxAdjust', adjust);\n  }\n};\n\n\n/**\n * Facilities for semantically relevant properties. These are used by SRE and\n * are always prefixed with bspr_.\n */\nlet property_prefix = 'bspr_';\nlet blacklistedProperties = {\n  [property_prefix + 'maxAdjust']: true\n};\n\n\n/**\n * Sets a bussproofs property used for postprocessing and to convey\n * semantics. Uses the bspr prefix.\n * @param {MmlNode} node The node.\n * @param {string} property The property to set.\n * @param {Property} value Its value.\n */\nexport let setProperty = function(node: MmlNode, property: string, value: Property) {\n  NodeUtil.setProperty(node, property_prefix + property, value);\n};\n\n\n/**\n * Gets a bussproofs property.\n * @param {MmlNode} node The node.\n * @param {string} property The property to retrieve.\n * @return {Property} The property object.\n */\nexport let getProperty = function(node: MmlNode, property: string): Property {\n  return NodeUtil.getProperty(node, property_prefix + property);\n};\n\n\n/**\n * Removes a bussproofs property.\n * @param {MmlNode} node\n * @param {string} property\n */\nexport let removeProperty = function(node: MmlNode, property: string) {\n  node.removeProperty(property_prefix + property);\n};\n\n\n/**\n * Postprocessor that adds properties as attributes to the nodes, unless they\n * are blacklisted.\n * @param {FilterData} arg The object to post-process.\n */\nexport let makeBsprAttributes = function(arg: FilterData) {\n  arg.data.root.walkTree((mml: MmlNode, _data?: any) => {\n    let attr: string[] = [];\n    mml.getPropertyNames().forEach(x => {\n      if (!blacklistedProperties[x] && x.match(RegExp('^' + property_prefix))) {\n        attr.push(x + ':' + mml.getProperty(x));\n      }\n    });\n    if (attr.length) {\n      NodeUtil.setAttribute(mml, 'semantics', attr.join(';'));\n    }\n  });\n};\n\n/**\n * Preprocessor that sets the document and jax for bounding box computations\n * @param {FilterData} arg The object to pre-process.\n */\nexport let saveDocument = function (arg: FilterData) {\n  doc = arg.document;\n  if (!('getBBox' in doc.outputJax)) {\n    throw Error('The bussproofs extension requires an output jax with a getBBox() method');\n  }\n};\n\n/**\n * Clear the document when we are done\n * @param {FilterData} arg The object to pre-process.\n */\nexport let clearDocument = function (_arg: FilterData) {\n  doc = null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}