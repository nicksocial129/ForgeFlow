{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar Symbol_js_1 = require(\"../Symbol.js\");\nvar NewcommandUtil;\n(function (NewcommandUtil) {\n  function disassembleSymbol(name, symbol) {\n    var newArgs = [name, symbol.char];\n    if (symbol.attributes) {\n      for (var key in symbol.attributes) {\n        newArgs.push(key);\n        newArgs.push(symbol.attributes[key]);\n      }\n    }\n    return newArgs;\n  }\n  NewcommandUtil.disassembleSymbol = disassembleSymbol;\n  function assembleSymbol(args) {\n    var name = args[0];\n    var char = args[1];\n    var attrs = {};\n    for (var i = 2; i < args.length; i = i + 2) {\n      attrs[args[i]] = args[i + 1];\n    }\n    return new Symbol_js_1.Symbol(name, char, attrs);\n  }\n  NewcommandUtil.assembleSymbol = assembleSymbol;\n  function GetCSname(parser, cmd) {\n    var c = parser.GetNext();\n    if (c !== '\\\\') {\n      throw new TexError_js_1.default('MissingCS', '%1 must be followed by a control sequence', cmd);\n    }\n    var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(cmd));\n    return cs.substr(1);\n  }\n  NewcommandUtil.GetCSname = GetCSname;\n  function GetCsNameArgument(parser, name) {\n    var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n    if (cs.charAt(0) === '\\\\') {\n      cs = cs.substr(1);\n    }\n    if (!cs.match(/^(.|[a-z]+)$/i)) {\n      throw new TexError_js_1.default('IllegalControlSequenceName', 'Illegal control sequence name for %1', name);\n    }\n    return cs;\n  }\n  NewcommandUtil.GetCsNameArgument = GetCsNameArgument;\n  function GetArgCount(parser, name) {\n    var n = parser.GetBrackets(name);\n    if (n) {\n      n = ParseUtil_js_1.default.trimSpaces(n);\n      if (!n.match(/^[0-9]+$/)) {\n        throw new TexError_js_1.default('IllegalParamNumber', 'Illegal number of parameters specified in %1', name);\n      }\n    }\n    return n;\n  }\n  NewcommandUtil.GetArgCount = GetArgCount;\n  function GetTemplate(parser, cmd, cs) {\n    var c = parser.GetNext();\n    var params = [];\n    var n = 0;\n    var i = parser.i;\n    while (parser.i < parser.string.length) {\n      c = parser.GetNext();\n      if (c === '#') {\n        if (i !== parser.i) {\n          params[n] = parser.string.substr(i, parser.i - i);\n        }\n        c = parser.string.charAt(++parser.i);\n        if (!c.match(/^[1-9]$/)) {\n          throw new TexError_js_1.default('CantUseHash2', 'Illegal use of # in template for %1', cs);\n        }\n        if (parseInt(c) !== ++n) {\n          throw new TexError_js_1.default('SequentialParam', 'Parameters for %1 must be numbered sequentially', cs);\n        }\n        i = parser.i + 1;\n      } else if (c === '{') {\n        if (i !== parser.i) {\n          params[n] = parser.string.substr(i, parser.i - i);\n        }\n        if (params.length > 0) {\n          return [n.toString()].concat(params);\n        } else {\n          return n;\n        }\n      }\n      parser.i++;\n    }\n    throw new TexError_js_1.default('MissingReplacementString', 'Missing replacement string for definition of %1', cmd);\n  }\n  NewcommandUtil.GetTemplate = GetTemplate;\n  function GetParameter(parser, name, param) {\n    if (param == null) {\n      return parser.GetArgument(name);\n    }\n    var i = parser.i;\n    var j = 0;\n    var hasBraces = 0;\n    while (parser.i < parser.string.length) {\n      var c = parser.string.charAt(parser.i);\n      if (c === '{') {\n        if (parser.i === i) {\n          hasBraces = 1;\n        }\n        parser.GetArgument(name);\n        j = parser.i - i;\n      } else if (MatchParam(parser, param)) {\n        if (hasBraces) {\n          i++;\n          j -= 2;\n        }\n        return parser.string.substr(i, j);\n      } else if (c === '\\\\') {\n        parser.i++;\n        j++;\n        hasBraces = 0;\n        var match = parser.string.substr(parser.i).match(/[a-z]+|./i);\n        if (match) {\n          parser.i += match[0].length;\n          j = parser.i - i;\n        }\n      } else {\n        parser.i++;\n        j++;\n        hasBraces = 0;\n      }\n    }\n    throw new TexError_js_1.default('RunawayArgument', 'Runaway argument for %1?', name);\n  }\n  NewcommandUtil.GetParameter = GetParameter;\n  function MatchParam(parser, param) {\n    if (parser.string.substr(parser.i, param.length) !== param) {\n      return 0;\n    }\n    if (param.match(/\\\\[a-z]+$/i) && parser.string.charAt(parser.i + param.length).match(/[a-z]/i)) {\n      return 0;\n    }\n    parser.i += param.length;\n    return 1;\n  }\n  NewcommandUtil.MatchParam = MatchParam;\n  function addDelimiter(parser, cs, char, attr) {\n    var handlers = parser.configuration.handlers;\n    var handler = handlers.retrieve(NewcommandUtil.NEW_DELIMITER);\n    handler.add(cs, new Symbol_js_1.Symbol(cs, char, attr));\n  }\n  NewcommandUtil.addDelimiter = addDelimiter;\n  function addMacro(parser, cs, func, attr, symbol) {\n    if (symbol === void 0) {\n      symbol = '';\n    }\n    var handlers = parser.configuration.handlers;\n    var handler = handlers.retrieve(NewcommandUtil.NEW_COMMAND);\n    handler.add(cs, new Symbol_js_1.Macro(symbol ? symbol : cs, func, attr));\n  }\n  NewcommandUtil.addMacro = addMacro;\n  function addEnvironment(parser, env, func, attr) {\n    var handlers = parser.configuration.handlers;\n    var handler = handlers.retrieve(NewcommandUtil.NEW_ENVIRONMENT);\n    handler.add(env, new Symbol_js_1.Macro(env, func, attr));\n  }\n  NewcommandUtil.addEnvironment = addEnvironment;\n  NewcommandUtil.NEW_DELIMITER = 'new-Delimiter';\n  NewcommandUtil.NEW_COMMAND = 'new-Command';\n  NewcommandUtil.NEW_ENVIRONMENT = 'new-Environment';\n})(NewcommandUtil || (NewcommandUtil = {}));\nexports.default = NewcommandUtil;","map":{"version":3,"names":["ParseUtil_js_1","__importDefault","require","TexError_js_1","Symbol_js_1","NewcommandUtil","disassembleSymbol","name","symbol","newArgs","char","attributes","key","push","assembleSymbol","args","attrs","i","length","Symbol","GetCSname","parser","cmd","c","GetNext","default","cs","trimSpaces","GetArgument","substr","GetCsNameArgument","charAt","match","GetArgCount","n","GetBrackets","GetTemplate","params","string","parseInt","toString","concat","GetParameter","param","j","hasBraces","MatchParam","addDelimiter","attr","handlers","configuration","handler","retrieve","NEW_DELIMITER","add","addMacro","func","NEW_COMMAND","Macro","addEnvironment","env","NEW_ENVIRONMENT","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/newcommand/NewcommandUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Utility functions for the newcommand package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport ParseUtil from '../ParseUtil.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport {Macro, Symbol} from '../Symbol.js';\nimport {Args, Attributes, ParseMethod} from '../Types.js';\nimport * as sm from '../SymbolMap.js';\n\n\nnamespace NewcommandUtil {\n\n  /**\n   * Transforms the attributes of a symbol into the arguments of a macro. E.g.,\n   * Symbol('ell', 'l', {mathvariant: \"italic\"}) is turned into Macro arguments:\n   * ['ell', 'l', 'mathvariant', 'italic'].\n   *\n   * @param {string} name The command name for the symbol.\n   * @param {Symbol} symbol The symbol associated with name.\n   * @return {Args[]} Arguments for a macro.\n   */\n  export function disassembleSymbol(name: string, symbol: Symbol): Args[] {\n    let newArgs = [name, symbol.char] as Args[];\n    // @test Let Relet, Let Let, Let Circular Macro\n    if (symbol.attributes) {\n      // @test Let Relet\n      for (let key in symbol.attributes) {\n        newArgs.push(key);\n        newArgs.push(symbol.attributes[key] as Args);\n      }\n    }\n    return newArgs;\n  }\n\n\n  /**\n   * Assembles a symbol from a list of macro arguments. This is the inverse\n   * method of the one above.\n   *\n   * @param {Args[]} args The arguments of the macro.\n   * @return {Symbol} The Symbol generated from the arguments..\n   */\n  export function assembleSymbol(args: Args[]): Symbol {\n    // @test Let Relet, Let Let, Let Circular Macro\n    let name = args[0] as string;\n    let char = args[1] as string;\n    let attrs: Attributes = {};\n    for (let i = 2; i < args.length; i = i + 2) {\n      // @test Let Relet\n      attrs[args[i] as string] = args[i + 1];\n    }\n    return new Symbol(name, char, attrs);\n  }\n\n  /**\n   * Get the next CS name or give an error.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} cmd The string starting with a control sequence.\n   * @return {string} The control sequence.\n   */\n  export function GetCSname(parser: TexParser, cmd: string): string {\n    // @test Def ReDef, Let Bar, Let Brace Equal\n    let c = parser.GetNext();\n    if (c !== '\\\\') {\n      // @test No CS\n      throw new TexError('MissingCS',\n                          '%1 must be followed by a control sequence', cmd);\n    }\n    let cs = ParseUtil.trimSpaces(parser.GetArgument(cmd));\n    return cs.substr(1);\n  }\n\n  /**\n   * Get a control sequence name as an argument (doesn't require the backslash)\n   * @param {TexParser} parser The calling parser.\n   * @param {string} name The macro that is getting the name.\n   * @return {string} The control sequence.\n   */\n  export function GetCsNameArgument(parser: TexParser, name: string): string {\n    let cs = ParseUtil.trimSpaces(parser.GetArgument(name));\n    if (cs.charAt(0) === '\\\\') {\n      // @test Newcommand Simple\n      cs = cs.substr(1);\n    }\n    if (!cs.match(/^(.|[a-z]+)$/i)) {\n      // @test Illegal CS\n      throw new TexError('IllegalControlSequenceName',\n                         'Illegal control sequence name for %1', name);\n    }\n    return cs;\n  }\n\n  /**\n   * Get the number of arguments for a macro definition\n   * @param {TexParser} parser The calling parser.\n   * @param {string} name The macro that is getting the argument count.\n   * @return {string} The number of arguments (or blank).\n   */\n  export function GetArgCount(parser: TexParser, name: string): string {\n    let n = parser.GetBrackets(name);\n    if (n) {\n      // @test Newcommand Optional, Newcommand Arg, Newcommand Arg Optional\n      // @test Newenvironment Optional, Newenvironment Arg Optional\n      n = ParseUtil.trimSpaces(n);\n      if (!n.match(/^[0-9]+$/)) {\n        // @test Illegal Argument Number\n        throw new TexError('IllegalParamNumber',\n                           'Illegal number of parameters specified in %1', name);\n      }\n    }\n    return n;\n  }\n\n  /**\n   * Get a \\def parameter template.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} cmd The string starting with the template.\n   * @param {string} cs The control sequence of the \\def.\n   * @return {number | string[]} The number of parameters or a string array if\n   *     there is an optional argument.\n   */\n  export function GetTemplate(parser: TexParser, cmd: string, cs: string): number | string[] {\n    // @test Def Double Let, Def ReDef, Def Let\n    let c = parser.GetNext();\n    let params: string[] = [];\n    let n = 0;\n    let i = parser.i;\n    while (parser.i < parser.string.length) {\n      c = parser.GetNext();\n      if (c === '#') {\n        // @test Def ReDef, Def Let, Def Optional Brace\n        if (i !== parser.i) {\n          // @test Def Let, Def Optional Brace\n          params[n] = parser.string.substr(i, parser.i - i);\n        }\n        c = parser.string.charAt(++parser.i);\n        if (!c.match(/^[1-9]$/)) {\n          // @test Illegal Hash\n          throw new TexError('CantUseHash2',\n                              'Illegal use of # in template for %1', cs);\n        }\n        if (parseInt(c) !== ++n) {\n          // @test No Sequence\n          throw new TexError('SequentialParam',\n                              'Parameters for %1 must be numbered sequentially', cs);\n        }\n        i = parser.i + 1;\n      } else if (c === '{') {\n        // @test Def Double Let, Def ReDef, Def Let\n        if (i !== parser.i) {\n          // @test Optional Brace Error\n          params[n] = parser.string.substr(i, parser.i - i);\n        }\n        if (params.length > 0) {\n          // @test Def Let, Def Optional Brace\n          return [n.toString()].concat(params);\n        } else {\n          // @test Def Double Let, Def ReDef\n          return n;\n        }\n      }\n      parser.i++;\n    }\n    // @test No Replacement\n    throw new TexError('MissingReplacementString',\n                        'Missing replacement string for definition of %1', cmd);\n  }\n\n\n  /**\n   * Find a single parameter delimited by a trailing template.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} name The name of the calling command.\n   * @param {string} param The parameter for the macro.\n   */\n  export function GetParameter(parser: TexParser, name: string, param: string) {\n    if (param == null) {\n      // @test Def Let, Def Optional Brace, Def Options CS\n      return parser.GetArgument(name);\n    }\n    let i = parser.i;\n    let j = 0;\n    let hasBraces = 0;\n    while (parser.i < parser.string.length) {\n      let c = parser.string.charAt(parser.i);\n      // @test Def Let, Def Optional Brace, Def Options CS\n      if (c === '{') {\n        // @test Def Optional Brace, Def Options CS\n        if (parser.i === i) {\n          // @test Def Optional Brace\n          hasBraces = 1;\n        }\n        parser.GetArgument(name);\n        j = parser.i - i;\n      } else if (MatchParam(parser, param)) {\n        // @test Def Let, Def Optional Brace, Def Options CS\n        if (hasBraces) {\n          // @test Def Optional Brace\n          i++;\n          j -= 2;\n        }\n        return parser.string.substr(i, j);\n      } else if (c === '\\\\') {\n        // @test Def Options CS\n        parser.i++;\n        j++;\n        hasBraces = 0;\n        let match = parser.string.substr(parser.i).match(/[a-z]+|./i);\n        if (match) {\n          // @test Def Options CS\n          parser.i += match[0].length;\n          j = parser.i - i;\n        }\n      } else {\n        // @test Def Let\n        parser.i++;\n        j++;\n        hasBraces = 0;\n      }\n    }\n    // @test Runaway Argument\n    throw new TexError('RunawayArgument', 'Runaway argument for %1?', name);\n  }\n\n\n  /**\n   * Check if a template is at the current location.\n   * (The match must be exact, with no spacing differences. TeX is\n   *  a little more forgiving than this about spaces after macro names)\n   * @param {TexParser} parser The calling parser.\n   * @param {string} param Tries to match an optional parameter.\n   * @return {number} The number of optional parameters, either 0 or 1.\n   */\n  export function MatchParam(parser: TexParser, param: string): number {\n    // @test Def Let, Def Optional Brace, Def Options CS\n    if (parser.string.substr(parser.i, param.length) !== param) {\n      // @test Def Let, Def Options CS\n      return 0;\n    }\n    if (param.match(/\\\\[a-z]+$/i) &&\n        parser.string.charAt(parser.i + param.length).match(/[a-z]/i)) {\n      // @test (missing)\n      return 0;\n    }\n    // @test Def Let, Def Optional Brace, Def Options CS\n    parser.i += param.length;\n    return 1;\n  }\n\n\n  /**\n   * Adds a new delimiter as extension to the parser.\n   * @param {TexParser} parser The current parser.\n   * @param {string} cs The control sequence of the delimiter.\n   * @param {string} char The corresponding character.\n   * @param {Attributes} attr The attributes needed for parsing.\n   */\n  export function addDelimiter(parser: TexParser, cs: string, char: string, attr: Attributes) {\n    const handlers = parser.configuration.handlers;\n    const handler = handlers.retrieve(NEW_DELIMITER) as sm.DelimiterMap;\n    handler.add(cs, new Symbol(cs, char, attr));\n  }\n\n  /**\n   * Adds a new macro as extension to the parser.\n   * @param {TexParser} parser The current parser.\n   * @param {string} cs The control sequence of the delimiter.\n   * @param {ParseMethod} func The parse method for this macro.\n   * @param {Args[]} attr The attributes needed for parsing.\n   * @param {string=} symbol Optionally original symbol for macro, in case it is\n   *     different from the control sequence.\n   */\n  export function addMacro(parser: TexParser, cs: string, func: ParseMethod, attr: Args[],\n                           symbol: string = '') {\n    const handlers = parser.configuration.handlers;\n    const handler = handlers.retrieve(NEW_COMMAND) as sm.CommandMap;\n    handler.add(cs, new Macro(symbol ? symbol : cs, func, attr));\n  }\n\n\n  /**\n   * Adds a new environment as extension to the parser.\n   * @param {TexParser} parser The current parser.\n   * @param {string} env The environment name.\n   * @param {ParseMethod} func The parse method for this macro.\n   * @param {Args[]} attr The attributes needed for parsing.\n   */\n  export function addEnvironment(parser: TexParser, env: string, func: ParseMethod, attr: Args[]) {\n    const handlers = parser.configuration.handlers;\n    const handler = handlers.retrieve(NEW_ENVIRONMENT) as sm.EnvironmentMap;\n    handler.add(env, new Macro(env, func, attr));\n  }\n\n  /**\n   * Naming constants for the extension mappings.\n   */\n  export const NEW_DELIMITER = 'new-Delimiter';\n  export const NEW_COMMAND = 'new-Command';\n  export const NEW_ENVIRONMENT = 'new-Environment';\n\n}\n\nexport default NewcommandUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}