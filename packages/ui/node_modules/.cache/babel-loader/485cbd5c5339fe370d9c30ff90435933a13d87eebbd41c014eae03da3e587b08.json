{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindTeX = void 0;\nvar FindMath_js_1 = require(\"../../core/FindMath.js\");\nvar string_js_1 = require(\"../../util/string.js\");\nvar MathItem_js_1 = require(\"../../core/MathItem.js\");\nvar FindTeX = function (_super) {\n  __extends(FindTeX, _super);\n  function FindTeX(options) {\n    var _this = _super.call(this, options) || this;\n    _this.getPatterns();\n    return _this;\n  }\n  FindTeX.prototype.getPatterns = function () {\n    var _this = this;\n    var options = this.options;\n    var starts = [],\n      parts = [],\n      subparts = [];\n    this.end = {};\n    this.env = this.sub = 0;\n    var i = 1;\n    options['inlineMath'].forEach(function (delims) {\n      return _this.addPattern(starts, delims, false);\n    });\n    options['displayMath'].forEach(function (delims) {\n      return _this.addPattern(starts, delims, true);\n    });\n    if (starts.length) {\n      parts.push(starts.sort(string_js_1.sortLength).join('|'));\n    }\n    if (options['processEnvironments']) {\n      parts.push('\\\\\\\\begin\\\\s*\\\\{([^}]*)\\\\}');\n      this.env = i;\n      i++;\n    }\n    if (options['processEscapes']) {\n      subparts.push('\\\\\\\\([\\\\\\\\$])');\n    }\n    if (options['processRefs']) {\n      subparts.push('(\\\\\\\\(?:eq)?ref\\\\s*\\\\{[^}]*\\\\})');\n    }\n    if (subparts.length) {\n      parts.push('(' + subparts.join('|') + ')');\n      this.sub = i;\n    }\n    this.start = new RegExp(parts.join('|'), 'g');\n    this.hasPatterns = parts.length > 0;\n  };\n  FindTeX.prototype.addPattern = function (starts, delims, display) {\n    var _a = __read(delims, 2),\n      open = _a[0],\n      close = _a[1];\n    starts.push((0, string_js_1.quotePattern)(open));\n    this.end[open] = [close, display, this.endPattern(close)];\n  };\n  FindTeX.prototype.endPattern = function (end, endp) {\n    return new RegExp((endp || (0, string_js_1.quotePattern)(end)) + '|\\\\\\\\(?:[a-zA-Z]|.)|[{}]', 'g');\n  };\n  FindTeX.prototype.findEnd = function (text, n, start, end) {\n    var _a = __read(end, 3),\n      close = _a[0],\n      display = _a[1],\n      pattern = _a[2];\n    var i = pattern.lastIndex = start.index + start[0].length;\n    var match,\n      braces = 0;\n    while (match = pattern.exec(text)) {\n      if ((match[1] || match[0]) === close && braces === 0) {\n        return (0, MathItem_js_1.protoItem)(start[0], text.substr(i, match.index - i), match[0], n, start.index, match.index + match[0].length, display);\n      } else if (match[0] === '{') {\n        braces++;\n      } else if (match[0] === '}' && braces) {\n        braces--;\n      }\n    }\n    return null;\n  };\n  FindTeX.prototype.findMathInString = function (math, n, text) {\n    var start, match;\n    this.start.lastIndex = 0;\n    while (start = this.start.exec(text)) {\n      if (start[this.env] !== undefined && this.env) {\n        var end = '\\\\\\\\end\\\\s*(\\\\{' + (0, string_js_1.quotePattern)(start[this.env]) + '\\\\})';\n        match = this.findEnd(text, n, start, ['{' + start[this.env] + '}', true, this.endPattern(null, end)]);\n        if (match) {\n          match.math = match.open + match.math + match.close;\n          match.open = match.close = '';\n        }\n      } else if (start[this.sub] !== undefined && this.sub) {\n        var math_1 = start[this.sub];\n        var end = start.index + start[this.sub].length;\n        if (math_1.length === 2) {\n          match = (0, MathItem_js_1.protoItem)('', math_1.substr(1), '', n, start.index, end);\n        } else {\n          match = (0, MathItem_js_1.protoItem)('', math_1, '', n, start.index, end, false);\n        }\n      } else {\n        match = this.findEnd(text, n, start, this.end[start[0]]);\n      }\n      if (match) {\n        math.push(match);\n        this.start.lastIndex = match.end.n;\n      }\n    }\n  };\n  FindTeX.prototype.findMath = function (strings) {\n    var math = [];\n    if (this.hasPatterns) {\n      for (var i = 0, m = strings.length; i < m; i++) {\n        this.findMathInString(math, i, strings[i]);\n      }\n    }\n    return math;\n  };\n  FindTeX.OPTIONS = {\n    inlineMath: [['\\\\(', '\\\\)']],\n    displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']],\n    processEscapes: true,\n    processEnvironments: true,\n    processRefs: true\n  };\n  return FindTeX;\n}(FindMath_js_1.AbstractFindMath);\nexports.FindTeX = FindTeX;","map":{"version":3,"names":["FindMath_js_1","require","string_js_1","MathItem_js_1","FindTeX","_super","__extends","options","_this","call","getPatterns","prototype","starts","parts","subparts","end","env","sub","i","forEach","delims","addPattern","length","push","sort","sortLength","join","start","RegExp","hasPatterns","display","_a","__read","open","close","quotePattern","endPattern","endp","findEnd","text","n","pattern","lastIndex","index","match","braces","exec","protoItem","substr","findMathInString","math","undefined","math_1","findMath","strings","m","OPTIONS","inlineMath","displayMath","processEscapes","processEnvironments","processRefs","AbstractFindMath","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/FindTeX.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the TeX version of the FindMath object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AbstractFindMath} from '../../core/FindMath.js';\nimport {OptionList} from '../../util/Options.js';\nimport {sortLength, quotePattern} from '../../util/string.js';\nimport {ProtoItem, protoItem} from '../../core/MathItem.js';\n\n/**\n * Shorthand types for data about end delimiters and delimiter pairs\n */\nexport type EndItem = [string, boolean, RegExp];\nexport type Delims = [string, string];\n\n/*****************************************************************/\n/*\n *  Implements the FindTeX class (extends AbstractFindMath)\n *\n *  Locates TeX expressions within strings\n */\n\n/*\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class FindTeX<N, T, D> extends AbstractFindMath<N, T, D> {\n\n  /**\n   * @type {OptionList}\n   */\n  public static OPTIONS: OptionList = {\n    inlineMath: [              // The start/end delimiter pairs for in-line math\n      //  ['$', '$'],              //  (comment out any you don't want, or add your own, but\n      ['\\\\(', '\\\\)']           //  be sure that you don't have an extra comma at the end)\n    ],\n\n    displayMath: [             // The start/end delimiter pairs for display math\n      ['$$', '$$'],            //  (comment out any you don't want, or add your own, but\n      ['\\\\[', '\\\\]']           //  be sure that you don't have an extra comma at the end)\n    ],\n\n    processEscapes: true,      // set to true to allow \\$ to produce a dollar without\n    //   starting in-line math mode\n    processEnvironments: true, // set to true to process \\begin{xxx}...\\end{xxx} outside\n    //   of math mode, false to prevent that\n    processRefs: true,         // set to true to process \\ref{...} outside of math mode\n  };\n\n  /**\n   * The regular expression for any starting delimiter\n   */\n  protected start: RegExp;\n\n  /**\n   * The end-delimiter data keyed to the opening delimiter string\n   */\n  protected end: {[name: string]: EndItem};\n\n  /**\n   * False if the configuration has no delimiters (so search can be skipped), true otherwise\n   */\n  protected hasPatterns: boolean;\n\n  /**\n   * The index of the \\begin...\\end pattern in the regex match array\n   */\n  protected env: number;\n\n  /**\n   * The index of the \\ref and escaped character patters in the regex match array\n   */\n  protected sub: number;\n\n  /**\n   * @override\n   */\n  constructor(options: OptionList) {\n    super(options);\n    this.getPatterns();\n  }\n\n  /**\n   * Create the patterns needed for searching the strings for TeX\n   *   based on the configuration options\n   */\n  protected getPatterns() {\n    let options = this.options;\n    let starts: string[] = [], parts: string[] = [], subparts: string[] = [];\n    this.end = {};\n    this.env = this.sub = 0;\n    let i = 1;\n    options['inlineMath'].forEach((delims: Delims) => this.addPattern(starts, delims, false));\n    options['displayMath'].forEach((delims: Delims) => this.addPattern(starts, delims, true));\n    if (starts.length) {\n      parts.push(starts.sort(sortLength).join('|'));\n    }\n    if (options['processEnvironments']) {\n      parts.push('\\\\\\\\begin\\\\s*\\\\{([^}]*)\\\\}');\n      this.env = i;\n      i++;\n    }\n    if (options['processEscapes']) {\n      subparts.push('\\\\\\\\([\\\\\\\\$])');\n    }\n    if (options['processRefs']) {\n      subparts.push('(\\\\\\\\(?:eq)?ref\\\\s*\\\\{[^}]*\\\\})');\n    }\n    if (subparts.length) {\n      parts.push('(' + subparts.join('|') + ')');\n      this.sub = i;\n    }\n    this.start = new RegExp(parts.join('|'), 'g');\n    this.hasPatterns = (parts.length > 0);\n  }\n\n  /**\n   * Add the needed patterns for a pair of delimiters\n   *\n   * @param {string[]} starts  Array of starting delimiter strings\n   * @param {Delims} delims    Array of delimiter strings, as [start, end]\n   * @param {boolean} display  True if the delimiters are for display mode\n   */\n  protected addPattern(starts: string[], delims: Delims, display: boolean) {\n    let [open, close] = delims;\n    starts.push(quotePattern(open));\n    this.end[open] = [close, display, this.endPattern(close)];\n  }\n\n  /**\n   * Create the pattern for a close delimiter\n   *\n   * @param {string} end   The end delimiter text\n   * @param {string} endp  The end delimiter pattern (overrides the literal end pattern)\n   * @return {RegExp}      The regular expression for the end delimiter\n   */\n  protected endPattern(end: string, endp?: string): RegExp {\n    return new RegExp((endp || quotePattern(end)) + '|\\\\\\\\(?:[a-zA-Z]|.)|[{}]', 'g');\n  }\n\n  /**\n   * Search for the end delimiter given the start delimiter,\n   *   skipping braced groups, and control sequences that aren't\n   *   the close delimiter.\n   *\n   * @param {string} text            The string being searched for the end delimiter\n   * @param {number} n               The index of the string being searched\n   * @param {RegExpExecArray} start  The result array from the start-delimiter search\n   * @param {EndItem} end            The end-delimiter data corresponding to the start delimiter\n   * @return {ProtoItem<N,T>}        The proto math item for the math, if found\n   */\n  protected findEnd(text: string, n: number, start: RegExpExecArray, end: EndItem): ProtoItem<N, T> {\n    let [close, display, pattern] = end;\n    let i = pattern.lastIndex = start.index + start[0].length;\n    let match: RegExpExecArray, braces: number = 0;\n    while ((match = pattern.exec(text))) {\n      if ((match[1] || match[0]) === close && braces === 0) {\n        return protoItem<N, T>(start[0], text.substr(i, match.index - i), match[0],\n                               n, start.index, match.index + match[0].length, display);\n      } else if (match[0] === '{') {\n        braces++;\n      } else if (match[0] === '}' && braces) {\n        braces--;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Search a string for math delimited by one of the delimiter pairs,\n   *   or by \\begin{env}...\\end{env}, or \\eqref{...}, \\ref{...}, \\\\, or \\$.\n   *\n   * @param {ProtoItem[]} math  The array of proto math items located so far\n   * @param {number} n          The index of the string being searched\n   * @param {string} text       The string being searched\n   */\n  protected findMathInString(math: ProtoItem<N, T>[], n: number, text: string) {\n    let start, match;\n    this.start.lastIndex = 0;\n    while ((start = this.start.exec(text))) {\n      if (start[this.env] !== undefined && this.env) {\n        let end = '\\\\\\\\end\\\\s*(\\\\{' + quotePattern(start[this.env]) + '\\\\})';\n        match = this.findEnd(text, n, start, ['{' + start[this.env] + '}', true, this.endPattern(null, end)]);\n        if (match) {\n          match.math = match.open + match.math + match.close;\n          match.open = match.close = '';\n        }\n      } else if (start[this.sub] !== undefined && this.sub) {\n        let math = start[this.sub];\n        let end = start.index + start[this.sub].length;\n        if (math.length === 2) {\n          match = protoItem<N, T>('', math.substr(1), '', n, start.index, end);\n        } else {\n          match = protoItem<N, T>('', math, '', n, start.index, end, false);\n        }\n      } else {\n        match = this.findEnd(text, n, start, this.end[start[0]]);\n      }\n      if (match) {\n        math.push(match);\n        this.start.lastIndex = match.end.n;\n      }\n    }\n  }\n\n  /**\n   * Search for math in an array of strings and return an array of matches.\n   *\n   * @override\n   */\n  public findMath(strings: string[]) {\n    let math: ProtoItem<N, T>[] = [];\n    if (this.hasPatterns) {\n      for (let i = 0, m = strings.length; i < m; i++) {\n        this.findMathInString(math, i, strings[i]);\n      }\n    }\n    return math;\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}