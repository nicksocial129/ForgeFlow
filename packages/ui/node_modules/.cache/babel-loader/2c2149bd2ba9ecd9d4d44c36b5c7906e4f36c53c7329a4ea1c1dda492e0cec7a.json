{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\nimport { convert } from 'unist-util-is';\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n\n * @param parent\n *   Parent node.\n * @param index\n *   Child of `parent` or it’s index.\n * @param test\n *   `unist-util-is`-compatible test.\n * @returns\n *   Child of `parent` or `null`.\n */\nexport const findAfter =\n/**\n * @type {(\n *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &\n *  ((node: Parent, index: Node | number, test?: Test) => Node | null)\n * )}\n */\n\n/**\n * @param {Parent} parent\n * @param {Node | number} index\n * @param {Test} [test]\n * @returns {Node | null}\n */\nfunction (parent, index, test) {\n  const is = convert(test);\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node');\n  }\n  if (typeof index === 'number') {\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\n      throw new Error('Expected positive finite number as index');\n    }\n  } else {\n    index = parent.children.indexOf(index);\n    if (index < 0) {\n      throw new Error('Expected child node or index');\n    }\n  }\n  while (++index < parent.children.length) {\n    if (is(parent.children[index], index, parent)) {\n      return parent.children[index];\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["convert","findAfter","parent","index","test","is","type","children","Error","Number","POSITIVE_INFINITY","indexOf","length"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/unist-util-find-after/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n\n * @param parent\n *   Parent node.\n * @param index\n *   Child of `parent` or it’s index.\n * @param test\n *   `unist-util-is`-compatible test.\n * @returns\n *   Child of `parent` or `null`.\n */\nexport const findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &\n   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent\n     * @param {Node | number} index\n     * @param {Test} [test]\n     * @returns {Node | null}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,OAAO,QAAO,eAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS;AACpB;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACI,SAAAA,CAAUC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAE;EAC7B,MAAMC,EAAE,GAAGL,OAAO,CAACI,IAAI,CAAC;EAExB,IAAI,CAACF,MAAM,IAAI,CAACA,MAAM,CAACI,IAAI,IAAI,CAACJ,MAAM,CAACK,QAAQ,EAAE;IAC/C,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;EACzC;EAEA,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,KAAKM,MAAM,CAACC,iBAAiB,EAAE;MACnD,MAAM,IAAIF,KAAK,CAAC,0CAA0C,CAAC;IAC7D;EACF,CAAC,MAAM;IACLL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACI,OAAO,CAACR,KAAK,CAAC;IAEtC,IAAIA,KAAK,GAAG,CAAC,EAAE;MACb,MAAM,IAAIK,KAAK,CAAC,8BAA8B,CAAC;IACjD;EACF;EAEA,OAAO,EAAEL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACK,MAAM,EAAE;IACvC,IAAIP,EAAE,CAACH,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC,EAAEA,KAAK,EAAED,MAAM,CAAC,EAAE;MAC7C,OAAOA,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC;IAC/B;EACF;EAEA,OAAO,IAAI;AACb,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}