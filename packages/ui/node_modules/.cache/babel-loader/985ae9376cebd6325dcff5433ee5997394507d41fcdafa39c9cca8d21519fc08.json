{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MmlMo = void 0;\nvar MmlNode_js_1 = require(\"../MmlNode.js\");\nvar OperatorDictionary_js_1 = require(\"../OperatorDictionary.js\");\nvar string_js_1 = require(\"../../../util/string.js\");\nvar MmlMo = function (_super) {\n  __extends(MmlMo, _super);\n  function MmlMo() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._texClass = null;\n    _this.lspace = 5 / 18;\n    _this.rspace = 5 / 18;\n    return _this;\n  }\n  Object.defineProperty(MmlMo.prototype, \"texClass\", {\n    get: function () {\n      if (this._texClass === null) {\n        var mo = this.getText();\n        var _a = __read(this.handleExplicitForm(this.getForms()), 3),\n          form1 = _a[0],\n          form2 = _a[1],\n          form3 = _a[2];\n        var OPTABLE_1 = this.constructor.OPTABLE;\n        var def = OPTABLE_1[form1][mo] || OPTABLE_1[form2][mo] || OPTABLE_1[form3][mo];\n        return def ? def[2] : MmlNode_js_1.TEXCLASS.REL;\n      }\n      return this._texClass;\n    },\n    set: function (value) {\n      this._texClass = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MmlMo.prototype, \"kind\", {\n    get: function () {\n      return 'mo';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MmlMo.prototype, \"isEmbellished\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MmlMo.prototype, \"hasNewLine\", {\n    get: function () {\n      return this.attributes.get('linebreak') === 'newline';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MmlMo.prototype.coreParent = function () {\n    var embellished = this;\n    var parent = this;\n    var math = this.factory.getNodeClass('math');\n    while (parent && parent.isEmbellished && parent.coreMO() === this && !(parent instanceof math)) {\n      embellished = parent;\n      parent = parent.parent;\n    }\n    return embellished;\n  };\n  MmlMo.prototype.coreText = function (parent) {\n    if (!parent) {\n      return '';\n    }\n    if (parent.isEmbellished) {\n      return parent.coreMO().getText();\n    }\n    while (((parent.isKind('mrow') || parent.isKind('TeXAtom') && parent.texClass !== MmlNode_js_1.TEXCLASS.VCENTER || parent.isKind('mstyle') || parent.isKind('mphantom')) && parent.childNodes.length === 1 || parent.isKind('munderover')) && parent.childNodes[0]) {\n      parent = parent.childNodes[0];\n    }\n    return parent.isToken ? parent.getText() : '';\n  };\n  MmlMo.prototype.hasSpacingAttributes = function () {\n    return this.attributes.isSet('lspace') || this.attributes.isSet('rspace');\n  };\n  Object.defineProperty(MmlMo.prototype, \"isAccent\", {\n    get: function () {\n      var accent = false;\n      var node = this.coreParent().parent;\n      if (node) {\n        var key = node.isKind('mover') ? node.childNodes[node.over].coreMO() ? 'accent' : '' : node.isKind('munder') ? node.childNodes[node.under].coreMO() ? 'accentunder' : '' : node.isKind('munderover') ? this === node.childNodes[node.over].coreMO() ? 'accent' : this === node.childNodes[node.under].coreMO() ? 'accentunder' : '' : '';\n        if (key) {\n          var value = node.attributes.getExplicit(key);\n          accent = value !== undefined ? accent : this.attributes.get('accent');\n        }\n      }\n      return accent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MmlMo.prototype.setTeXclass = function (prev) {\n    var _a = this.attributes.getList('form', 'fence'),\n      form = _a.form,\n      fence = _a.fence;\n    if (this.getProperty('texClass') === undefined && (this.attributes.isSet('lspace') || this.attributes.isSet('rspace'))) {\n      return null;\n    }\n    if (fence && this.texClass === MmlNode_js_1.TEXCLASS.REL) {\n      if (form === 'prefix') {\n        this.texClass = MmlNode_js_1.TEXCLASS.OPEN;\n      }\n      if (form === 'postfix') {\n        this.texClass = MmlNode_js_1.TEXCLASS.CLOSE;\n      }\n    }\n    return this.adjustTeXclass(prev);\n  };\n  MmlMo.prototype.adjustTeXclass = function (prev) {\n    var texClass = this.texClass;\n    var prevClass = this.prevClass;\n    if (texClass === MmlNode_js_1.TEXCLASS.NONE) {\n      return prev;\n    }\n    if (prev) {\n      if (prev.getProperty('autoOP') && (texClass === MmlNode_js_1.TEXCLASS.BIN || texClass === MmlNode_js_1.TEXCLASS.REL)) {\n        prevClass = prev.texClass = MmlNode_js_1.TEXCLASS.ORD;\n      }\n      prevClass = this.prevClass = prev.texClass || MmlNode_js_1.TEXCLASS.ORD;\n      this.prevLevel = this.attributes.getInherited('scriptlevel');\n    } else {\n      prevClass = this.prevClass = MmlNode_js_1.TEXCLASS.NONE;\n    }\n    if (texClass === MmlNode_js_1.TEXCLASS.BIN && (prevClass === MmlNode_js_1.TEXCLASS.NONE || prevClass === MmlNode_js_1.TEXCLASS.BIN || prevClass === MmlNode_js_1.TEXCLASS.OP || prevClass === MmlNode_js_1.TEXCLASS.REL || prevClass === MmlNode_js_1.TEXCLASS.OPEN || prevClass === MmlNode_js_1.TEXCLASS.PUNCT)) {\n      this.texClass = MmlNode_js_1.TEXCLASS.ORD;\n    } else if (prevClass === MmlNode_js_1.TEXCLASS.BIN && (texClass === MmlNode_js_1.TEXCLASS.REL || texClass === MmlNode_js_1.TEXCLASS.CLOSE || texClass === MmlNode_js_1.TEXCLASS.PUNCT)) {\n      prev.texClass = this.prevClass = MmlNode_js_1.TEXCLASS.ORD;\n    } else if (texClass === MmlNode_js_1.TEXCLASS.BIN) {\n      var child = this;\n      var parent_1 = this.parent;\n      while (parent_1 && parent_1.parent && parent_1.isEmbellished && (parent_1.childNodes.length === 1 || !parent_1.isKind('mrow') && parent_1.core() === child)) {\n        child = parent_1;\n        parent_1 = parent_1.parent;\n      }\n      if (parent_1.childNodes[parent_1.childNodes.length - 1] === child) {\n        this.texClass = MmlNode_js_1.TEXCLASS.ORD;\n      }\n    }\n    return this;\n  };\n  MmlMo.prototype.setInheritedAttributes = function (attributes, display, level, prime) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (display === void 0) {\n      display = false;\n    }\n    if (level === void 0) {\n      level = 0;\n    }\n    if (prime === void 0) {\n      prime = false;\n    }\n    _super.prototype.setInheritedAttributes.call(this, attributes, display, level, prime);\n    var mo = this.getText();\n    this.checkOperatorTable(mo);\n    this.checkPseudoScripts(mo);\n    this.checkPrimes(mo);\n    this.checkMathAccent(mo);\n  };\n  MmlMo.prototype.checkOperatorTable = function (mo) {\n    var e_1, _a;\n    var _b = __read(this.handleExplicitForm(this.getForms()), 3),\n      form1 = _b[0],\n      form2 = _b[1],\n      form3 = _b[2];\n    this.attributes.setInherited('form', form1);\n    var OPTABLE = this.constructor.OPTABLE;\n    var def = OPTABLE[form1][mo] || OPTABLE[form2][mo] || OPTABLE[form3][mo];\n    if (def) {\n      if (this.getProperty('texClass') === undefined) {\n        this.texClass = def[2];\n      }\n      try {\n        for (var _c = __values(Object.keys(def[3] || {})), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          this.attributes.setInherited(name_1, def[3][name_1]);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      this.lspace = (def[0] + 1) / 18;\n      this.rspace = (def[1] + 1) / 18;\n    } else {\n      var range = (0, OperatorDictionary_js_1.getRange)(mo);\n      if (range) {\n        if (this.getProperty('texClass') === undefined) {\n          this.texClass = range[2];\n        }\n        var spacing = this.constructor.MMLSPACING[range[2]];\n        this.lspace = (spacing[0] + 1) / 18;\n        this.rspace = (spacing[1] + 1) / 18;\n      }\n    }\n  };\n  MmlMo.prototype.getForms = function () {\n    var core = this;\n    var parent = this.parent;\n    var Parent = this.Parent;\n    while (Parent && Parent.isEmbellished) {\n      core = parent;\n      parent = Parent.parent;\n      Parent = Parent.Parent;\n    }\n    if (parent && parent.isKind('mrow') && parent.nonSpaceLength() !== 1) {\n      if (parent.firstNonSpace() === core) {\n        return ['prefix', 'infix', 'postfix'];\n      }\n      if (parent.lastNonSpace() === core) {\n        return ['postfix', 'infix', 'prefix'];\n      }\n    }\n    return ['infix', 'prefix', 'postfix'];\n  };\n  MmlMo.prototype.handleExplicitForm = function (forms) {\n    if (this.attributes.isSet('form')) {\n      var form_1 = this.attributes.get('form');\n      forms = [form_1].concat(forms.filter(function (name) {\n        return name !== form_1;\n      }));\n    }\n    return forms;\n  };\n  MmlMo.prototype.checkPseudoScripts = function (mo) {\n    var PSEUDOSCRIPTS = this.constructor.pseudoScripts;\n    if (!mo.match(PSEUDOSCRIPTS)) return;\n    var parent = this.coreParent().Parent;\n    var isPseudo = !parent || !(parent.isKind('msubsup') && !parent.isKind('msub'));\n    this.setProperty('pseudoscript', isPseudo);\n    if (isPseudo) {\n      this.attributes.setInherited('lspace', 0);\n      this.attributes.setInherited('rspace', 0);\n    }\n  };\n  MmlMo.prototype.checkPrimes = function (mo) {\n    var PRIMES = this.constructor.primes;\n    if (!mo.match(PRIMES)) return;\n    var REMAP = this.constructor.remapPrimes;\n    var primes = (0, string_js_1.unicodeString)((0, string_js_1.unicodeChars)(mo).map(function (c) {\n      return REMAP[c];\n    }));\n    this.setProperty('primes', primes);\n  };\n  MmlMo.prototype.checkMathAccent = function (mo) {\n    var parent = this.Parent;\n    if (this.getProperty('mathaccent') !== undefined || !parent || !parent.isKind('munderover')) return;\n    var base = parent.childNodes[0];\n    if (base.isEmbellished && base.coreMO() === this) return;\n    var MATHACCENT = this.constructor.mathaccents;\n    if (mo.match(MATHACCENT)) {\n      this.setProperty('mathaccent', true);\n    }\n  };\n  MmlMo.defaults = __assign(__assign({}, MmlNode_js_1.AbstractMmlTokenNode.defaults), {\n    form: 'infix',\n    fence: false,\n    separator: false,\n    lspace: 'thickmathspace',\n    rspace: 'thickmathspace',\n    stretchy: false,\n    symmetric: false,\n    maxsize: 'infinity',\n    minsize: '0em',\n    largeop: false,\n    movablelimits: false,\n    accent: false,\n    linebreak: 'auto',\n    lineleading: '1ex',\n    linebreakstyle: 'before',\n    indentalign: 'auto',\n    indentshift: '0',\n    indenttarget: '',\n    indentalignfirst: 'indentalign',\n    indentshiftfirst: 'indentshift',\n    indentalignlast: 'indentalign',\n    indentshiftlast: 'indentshift'\n  });\n  MmlMo.MMLSPACING = OperatorDictionary_js_1.MMLSPACING;\n  MmlMo.OPTABLE = OperatorDictionary_js_1.OPTABLE;\n  MmlMo.pseudoScripts = new RegExp(['^[\"\\'*`', '\\u00AA', '\\u00B0', '\\u00B2-\\u00B4', '\\u00B9', '\\u00BA', '\\u2018-\\u201F', '\\u2032-\\u2037\\u2057', '\\u2070\\u2071', '\\u2074-\\u207F', '\\u2080-\\u208E', ']+$'].join(''));\n  MmlMo.primes = new RegExp(['^[\"\\'`', '\\u2018-\\u201F', ']+$'].join(''));\n  MmlMo.remapPrimes = {\n    0x0022: 0x2033,\n    0x0027: 0x2032,\n    0x0060: 0x2035,\n    0x2018: 0x2035,\n    0x2019: 0x2032,\n    0x201A: 0x2032,\n    0x201B: 0x2035,\n    0x201C: 0x2036,\n    0x201D: 0x2033,\n    0x201E: 0x2033,\n    0x201F: 0x2036\n  };\n  MmlMo.mathaccents = new RegExp(['^[', '\\u00B4\\u0301\\u02CA', '\\u0060\\u0300\\u02CB', '\\u00A8\\u0308', '\\u007E\\u0303\\u02DC', '\\u00AF\\u0304\\u02C9', '\\u02D8\\u0306', '\\u02C7\\u030C', '\\u005E\\u0302\\u02C6', '\\u2192\\u20D7', '\\u02D9\\u0307', '\\u02DA\\u030A', '\\u20DB', '\\u20DC', ']$'].join(''));\n  return MmlMo;\n}(MmlNode_js_1.AbstractMmlTokenNode);\nexports.MmlMo = MmlMo;","map":{"version":3,"names":["MmlNode_js_1","require","OperatorDictionary_js_1","string_js_1","MmlMo","_super","__extends","_this","apply","arguments","_texClass","lspace","rspace","Object","defineProperty","prototype","get","mo","getText","_a","__read","handleExplicitForm","getForms","form1","form2","form3","OPTABLE_1","constructor","OPTABLE","def","TEXCLASS","REL","set","value","attributes","coreParent","embellished","parent","math","factory","getNodeClass","isEmbellished","coreMO","coreText","isKind","texClass","VCENTER","childNodes","length","isToken","hasSpacingAttributes","isSet","accent","node","key","over","under","getExplicit","undefined","setTeXclass","prev","getList","form","fence","getProperty","OPEN","CLOSE","adjustTeXclass","prevClass","NONE","BIN","ORD","prevLevel","getInherited","OP","PUNCT","child","parent_1","core","setInheritedAttributes","display","level","prime","call","checkOperatorTable","checkPseudoScripts","checkPrimes","checkMathAccent","_b","setInherited","_c","__values","keys","_d","next","done","name_1","range","getRange","spacing","MMLSPACING","Parent","nonSpaceLength","firstNonSpace","lastNonSpace","forms","form_1","concat","filter","name","PSEUDOSCRIPTS","pseudoScripts","match","isPseudo","setProperty","PRIMES","primes","REMAP","remapPrimes","unicodeString","unicodeChars","map","c","base","MATHACCENT","mathaccents","defaults","__assign","AbstractMmlTokenNode","separator","stretchy","symmetric","maxsize","minsize","largeop","movablelimits","linebreak","lineleading","linebreakstyle","indentalign","indentshift","indenttarget","indentalignfirst","indentshiftfirst","indentalignlast","indentshiftlast","RegExp","join","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/core/MmlTree/MmlNodes/mo.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the MmlMo node\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {PropertyList} from '../../Tree/Node.js';\nimport {AbstractMmlTokenNode, MmlNode, AttributeList, TEXCLASS} from '../MmlNode.js';\nimport {MmlMrow} from './mrow.js';\nimport {MmlMover, MmlMunder, MmlMunderover} from './munderover.js';\nimport {OperatorList, OPTABLE, getRange, MMLSPACING} from '../OperatorDictionary.js';\nimport {unicodeChars, unicodeString} from '../../../util/string.js';\n\n/*****************************************************************/\n/**\n *  Implements the MmlMo node class (subclass of AbstractMmlTokenNode)\n */\n\nexport class MmlMo extends AbstractMmlTokenNode {\n\n  /**\n   * @override\n   */\n  public static defaults: PropertyList = {\n    ...AbstractMmlTokenNode.defaults,\n    form: 'infix',\n    fence: false,\n    separator: false,\n    lspace: 'thickmathspace',\n    rspace: 'thickmathspace',\n    stretchy: false,\n    symmetric: false,\n    maxsize: 'infinity',\n    minsize: '0em', // MathML says '1em', but that is larger than some natural sizes\n    largeop: false,\n    movablelimits: false,\n    accent: false,\n    linebreak: 'auto',\n    lineleading: '1ex',\n    linebreakstyle: 'before',\n    indentalign: 'auto',\n    indentshift: '0',\n    indenttarget: '',\n    indentalignfirst: 'indentalign',\n    indentshiftfirst: 'indentshift',\n    indentalignlast: 'indentalign',\n    indentshiftlast: 'indentshift'\n  };\n\n  /**\n   * The MathML spacing values for the TeX classes\n   */\n  public static MMLSPACING = MMLSPACING;\n\n  /**\n   * The Operator Dictionary\n   */\n  public static OPTABLE: {[form: string]: OperatorList} = OPTABLE;\n\n  /**\n   * Pattern for matching when the contents is one ore more pseudoscripts\n   */\n  public static pseudoScripts = new RegExp([\n    '^[\"\\'*`',\n    '\\u00AA',               // FEMININE ORDINAL INDICATOR\n    '\\u00B0',               // DEGREE SIGN\n    '\\u00B2-\\u00B4',        // SUPERSCRIPT 2 and 3, ACUTE ACCENT\n    '\\u00B9',               // SUPERSCRIPT ONE\n    '\\u00BA',               // MASCULINE ORDINAL INDICATOR\n    '\\u2018-\\u201F',        // Various double and single quotation marks (up and down)\n    '\\u2032-\\u2037\\u2057',  // Primes and reversed primes (forward and reversed)\n    '\\u2070\\u2071',         // SUPERSCRIPT 0 and i\n    '\\u2074-\\u207F',        // SUPERCRIPT 4 through 9, -, =, (, ), and n\n    '\\u2080-\\u208E',        // SUBSCRIPT 0 through 9, -, =, (, ).\n    ']+$'\n  ].join(''));\n\n  /**\n   * Pattern for when contents is a collection of primes\n   */\n   protected static primes = new RegExp([\n     '^[\"\\'`',\n     '\\u2018-\\u201F',        // Various double and single quotation marks (up and down)\n     ']+$'\n   ].join(''));\n\n   /**\n    * Default map for remapping prime characters\n    */\n  protected static remapPrimes: {[n: number]: number} = {\n     0x0022: 0x2033,   // double quotes\n     0x0027: 0x2032,   // single quote\n     0x0060: 0x2035,   // back quote\n     0x2018: 0x2035,   // open single quote\n     0x2019: 0x2032,   // close single quote\n     0x201A: 0x2032,   // low open single quote\n     0x201B: 0x2035,   // reversed open single quote\n     0x201C: 0x2036,   // open double quote\n     0x201D: 0x2033,   // close double quote\n     0x201E: 0x2033,   // low open double quote\n     0x201F: 0x2036,   // reversed open double quote\n  };\n\n  /**\n   * Regular expression matching characters that are marked as math accents\n   */\n  protected static mathaccents = new RegExp([\n    '^[',\n    '\\u00B4\\u0301\\u02CA',  // acute\n    '\\u0060\\u0300\\u02CB',  // grave\n    '\\u00A8\\u0308',        // ddot\n    '\\u007E\\u0303\\u02DC',  // tilde\n    '\\u00AF\\u0304\\u02C9',  // bar\n    '\\u02D8\\u0306',        // breve\n    '\\u02C7\\u030C',        // check\n    '\\u005E\\u0302\\u02C6',  // hat\n    '\\u2192\\u20D7',        // vec\n    '\\u02D9\\u0307',        // dot\n    '\\u02DA\\u030A',        // mathring\n    '\\u20DB',              // dddot\n    '\\u20DC',              // ddddot\n    ']$'\n  ].join(''));\n\n  /**\n   * The internal TeX class of the node (for use with getter/setter below)\n   */\n  public _texClass: number = null;\n\n  /**\n   * Use a getter to look up the TeX class from the operator table if it hasn't\n   * been set yet (but don't save it in case the form changes when it is in its\n   * location).\n   */\n  public get texClass() {\n    if (this._texClass === null) {\n      let mo = this.getText();\n      let [form1, form2, form3] = this.handleExplicitForm(this.getForms());\n      let OPTABLE = (this.constructor as typeof MmlMo).OPTABLE;\n      let def = OPTABLE[form1][mo] || OPTABLE[form2][mo] || OPTABLE[form3][mo];\n      return def ? def[2] : TEXCLASS.REL;\n    }\n    return this._texClass;\n  }\n\n  /**\n   * Use a setter to store the actual value in _texClass;\n   */\n  public set texClass(value: number) {\n    this._texClass = value;\n  }\n\n  /**\n   * The default MathML spacing on the left\n   */\n  /* tslint:disable-next-line:whitespace */\n  public lspace = 5/18;\n\n  /**\n   * The default MathML spacing on the right\n   */\n  /* tslint:disable-next-line:whitespace */\n  public rspace = 5/18;\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'mo';\n  }\n\n  /**\n   * All <mo> are considered embellished\n   * @override\n   */\n  public get isEmbellished() {\n    return true;\n  }\n\n  /**\n   * @return {boolean}  Is <mo> marked as an explicit linebreak?\n   */\n  public get hasNewLine(): boolean {\n    return this.attributes.get('linebreak') === 'newline';\n  }\n\n  /**\n   * @return {MmlNode}  The node that is the outermost embellished operator\n   *                    with this node as its core\n   */\n  public coreParent(): MmlNode {\n    let embellished = this as MmlNode;\n    let parent = this as MmlNode;\n    let math = this.factory.getNodeClass('math');\n    while (parent && parent.isEmbellished && parent.coreMO() === this && !(parent instanceof math)) {\n      embellished = parent;\n      parent = (parent as MmlNode).parent;\n    }\n    return embellished;\n  }\n\n  /**\n   * @param {MmlNode} parent  The node whose core text is to be obtained\n   * @return {string}         The text of the core MO of the given parent element\n   */\n  public coreText(parent: MmlNode): string {\n    if (!parent) {\n      return '';\n    }\n    if (parent.isEmbellished) {\n      return (parent.coreMO() as MmlMo).getText();\n    }\n    while ((((parent.isKind('mrow') ||\n              (parent.isKind('TeXAtom') && parent.texClass !== TEXCLASS.VCENTER) ||\n              parent.isKind('mstyle') ||\n              parent.isKind('mphantom')) && parent.childNodes.length === 1) ||\n            parent.isKind('munderover')) && parent.childNodes[0]) {\n      parent = parent.childNodes[0] as MmlNode;\n    }\n    return (parent.isToken ? (parent as AbstractMmlTokenNode).getText() : '');\n  }\n\n  /**\n   * @override\n   */\n  public hasSpacingAttributes() {\n    return this.attributes.isSet('lspace') ||\n      this.attributes.isSet('rspace');\n  }\n\n  /**\n   * @return {boolean}  True is this mo is an accent in an munderover construction\n   */\n  get isAccent(): boolean {\n    let accent = false;\n    const node = this.coreParent().parent;\n    if (node) {\n      const key = (node.isKind('mover') ?\n                   ((node.childNodes[(node as MmlMover).over] as MmlNode).coreMO() ?\n                    'accent' : '') :\n                   node.isKind('munder') ?\n                   ((node.childNodes[(node as MmlMunder).under] as MmlNode).coreMO() ?\n                    'accentunder' : '') :\n                   node.isKind('munderover') ?\n                   (this === (node.childNodes[(node as MmlMunderover).over] as MmlNode).coreMO() ?\n                    'accent' :\n                    this === (node.childNodes[(node as MmlMunderover).under] as MmlNode).coreMO() ?\n                    'accentunder' : '') :\n                   '');\n      if (key) {\n        const value = node.attributes.getExplicit(key);\n        accent = (value !== undefined ? accent : this.attributes.get('accent')) as boolean;\n      }\n    }\n    return accent;\n  }\n\n  /**\n   * Produce the texClass based on the operator dictionary values\n   *\n   * @override\n   */\n  public setTeXclass(prev: MmlNode): MmlNode {\n    let {form, fence} = this.attributes.getList('form', 'fence') as {form: string, fence: string};\n    if (this.getProperty('texClass') === undefined &&\n        (this.attributes.isSet('lspace') || this.attributes.isSet('rspace'))) {\n      return null;\n    }\n    if (fence && this.texClass === TEXCLASS.REL) {\n      if (form === 'prefix') {\n        this.texClass = TEXCLASS.OPEN;\n      }\n      if (form === 'postfix') {\n        this.texClass = TEXCLASS.CLOSE;\n      }\n    }\n    return this.adjustTeXclass(prev);\n  }\n  /**\n   * Follow the TeXBook rules for adjusting the TeX class once its neighbors are known\n   *\n   * @param {MmlNode} prev  The node appearing before this one in the output\n   * @return {MmlNode}      The last node displayed (this node)\n   */\n  public adjustTeXclass(prev: MmlNode): MmlNode {\n    let texClass = this.texClass;\n    let prevClass = this.prevClass;\n    if (texClass === TEXCLASS.NONE) {\n      return prev;\n    }\n    if (prev) {\n      if (prev.getProperty('autoOP') && (texClass === TEXCLASS.BIN || texClass === TEXCLASS.REL)) {\n        prevClass = prev.texClass = TEXCLASS.ORD;\n      }\n      prevClass = this.prevClass = (prev.texClass || TEXCLASS.ORD);\n      this.prevLevel = this.attributes.getInherited('scriptlevel') as number;\n    } else {\n      prevClass = this.prevClass = TEXCLASS.NONE;\n    }\n    if (texClass === TEXCLASS.BIN &&\n        (prevClass === TEXCLASS.NONE || prevClass === TEXCLASS.BIN || prevClass === TEXCLASS.OP ||\n         prevClass === TEXCLASS.REL || prevClass === TEXCLASS.OPEN || prevClass === TEXCLASS.PUNCT)) {\n      this.texClass = TEXCLASS.ORD;\n    } else if (prevClass === TEXCLASS.BIN &&\n               (texClass === TEXCLASS.REL || texClass === TEXCLASS.CLOSE || texClass === TEXCLASS.PUNCT)) {\n      prev.texClass = this.prevClass = TEXCLASS.ORD;\n    } else if (texClass === TEXCLASS.BIN) {\n      //\n      // Check if node is the last one in its container since the rule\n      // above only takes effect if there is a node that follows.\n      //\n      let child: MmlNode = this;\n      let parent = this.parent;\n      while (parent && parent.parent && parent.isEmbellished &&\n             (parent.childNodes.length === 1 ||\n              (!parent.isKind('mrow') && parent.core() === child))) {\n        child = parent;\n        parent = parent.parent;\n      }\n      if (parent.childNodes[parent.childNodes.length - 1] === child) {\n        this.texClass = TEXCLASS.ORD;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Do the normal inheritance, then look up the attributes from the operator dictionary.\n   * If there is no dictionary entry, get the TeX class from the Unicode range list.\n   *\n   * @override\n   */\n  public setInheritedAttributes(attributes: AttributeList = {},\n                                display: boolean = false, level: number = 0, prime: boolean = false) {\n    super.setInheritedAttributes(attributes, display, level, prime);\n    let mo = this.getText();\n    this.checkOperatorTable(mo);\n    this.checkPseudoScripts(mo);\n    this.checkPrimes(mo);\n    this.checkMathAccent(mo);\n  }\n\n  /**\n   * Set the attributes from the operator table\n   *\n   * @param {string} mo   The test of the mo element\n   */\n  protected checkOperatorTable(mo: string) {\n    let [form1, form2, form3] = this.handleExplicitForm(this.getForms());\n    this.attributes.setInherited('form', form1);\n    let OPTABLE = (this.constructor as typeof MmlMo).OPTABLE;\n    let def = OPTABLE[form1][mo] || OPTABLE[form2][mo] || OPTABLE[form3][mo];\n    if (def) {\n      if (this.getProperty('texClass') === undefined) {\n        this.texClass = def[2];\n      }\n      for (const name of Object.keys(def[3] || {})) {\n        this.attributes.setInherited(name, def[3][name]);\n      }\n      this.lspace = (def[0] + 1) / 18;\n      this.rspace = (def[1] + 1) / 18;\n    } else {\n      let range = getRange(mo);\n      if (range) {\n        if (this.getProperty('texClass') === undefined) {\n          this.texClass = range[2];\n        }\n        const spacing = (this.constructor as typeof MmlMo).MMLSPACING[range[2]];\n        this.lspace = (spacing[0] + 1) / 18;\n        this.rspace = (spacing[1] + 1) / 18;\n      }\n    }\n  }\n\n  /**\n   * @return {[string, string, string]}  The list of form attribute values in the\n   *                                     order they should be tested, based on the\n   *                                     position of the element in its parent.\n   */\n  public getForms(): [string, string, string] {\n    let core: MmlNode = this;\n    let parent = this.parent;\n    let Parent = this.Parent;\n    while (Parent && Parent.isEmbellished) {\n      core = parent;\n      parent = Parent.parent;\n      Parent = Parent.Parent;\n    }\n    if (parent && parent.isKind('mrow') && (parent as MmlMrow).nonSpaceLength() !== 1) {\n      if ((parent as MmlMrow).firstNonSpace() === core) {\n        return ['prefix', 'infix', 'postfix'];\n      }\n      if ((parent as MmlMrow).lastNonSpace() === core) {\n        return ['postfix', 'infix', 'prefix'];\n      }\n    }\n    return ['infix', 'prefix', 'postfix'];\n  }\n\n  /**\n   * @param {string[]} forms     The three forms in the default order they are to be tested\n   * @return {string[]}          The forms in the new order, if there is an explicit form attribute\n   */\n  protected handleExplicitForm(forms: string[]): string[] {\n    if (this.attributes.isSet('form')) {\n      const form = this.attributes.get('form') as string;\n      forms = [form].concat(forms.filter(name => (name !== form)));\n    }\n    return forms;\n  }\n\n  /**\n   * Mark the mo as a pseudoscript if it is one.  True means it is,\n   *   false means it is a pseudo-script character, but in an msup (so needs a variant form)\n   *\n   * @param {string} mo   The test of the mo element\n   */\n  protected checkPseudoScripts(mo: string) {\n    const PSEUDOSCRIPTS = (this.constructor as typeof MmlMo).pseudoScripts;\n    if (!mo.match(PSEUDOSCRIPTS)) return;\n    const parent = this.coreParent().Parent;\n    const isPseudo = !parent || !(parent.isKind('msubsup') && !parent.isKind('msub'));\n    this.setProperty('pseudoscript', isPseudo);\n    if (isPseudo) {\n      this.attributes.setInherited('lspace', 0);\n      this.attributes.setInherited('rspace', 0);\n    }\n  }\n\n  /**\n   * Determine whether the mo consists of primes, and remap them if so.\n   *\n   * @param {string} mo   The test of the mo element\n   */\n  protected checkPrimes(mo: string) {\n    const PRIMES = (this.constructor as typeof MmlMo).primes;\n    if (!mo.match(PRIMES)) return;\n    const REMAP = (this.constructor as typeof MmlMo).remapPrimes;\n    const primes = unicodeString(unicodeChars(mo).map(c => REMAP[c]));\n    this.setProperty('primes', primes);\n  }\n\n  /**\n   * Determine whether the mo is a mathaccent character\n   *\n   * @param {string} mo   The test of the mo element\n   */\n  protected checkMathAccent(mo: string) {\n    const parent = this.Parent;\n    if (this.getProperty('mathaccent') !== undefined || !parent || !parent.isKind('munderover')) return;\n    const base = parent.childNodes[0] as MmlNode;\n    if (base.isEmbellished && base.coreMO() === this) return;\n    const MATHACCENT = (this.constructor as typeof MmlMo).mathaccents;\n    if (mo.match(MATHACCENT)) {\n      this.setProperty('mathaccent', true);\n    }\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}