{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar sitem = __importStar(require(\"./BaseItems.js\"));\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar TexConstants_js_1 = require(\"../TexConstants.js\");\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nvar Tags_js_1 = require(\"../Tags.js\");\nvar lengths_js_1 = require(\"../../../util/lengths.js\");\nvar Entities_js_1 = require(\"../../../util/Entities.js\");\nvar Options_js_1 = require(\"../../../util/Options.js\");\nvar BaseMethods = {};\nvar P_HEIGHT = 1.2 / .85;\nvar MmlTokenAllow = {\n  fontfamily: 1,\n  fontsize: 1,\n  fontweight: 1,\n  fontstyle: 1,\n  color: 1,\n  background: 1,\n  id: 1,\n  'class': 1,\n  href: 1,\n  style: 1\n};\nBaseMethods.Open = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('open'));\n};\nBaseMethods.Close = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('close'));\n};\nBaseMethods.Tilde = function (parser, _c) {\n  parser.Push(parser.create('token', 'mtext', {}, Entities_js_1.entities.nbsp));\n};\nBaseMethods.Space = function (_parser, _c) {};\nBaseMethods.Superscript = function (parser, _c) {\n  var _a;\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n  var primes;\n  var base;\n  var top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sup : base.over;\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.over) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.over)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n      position = base.over;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sup;\n    }\n  }\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\nBaseMethods.Subscript = function (parser, _c) {\n  var _a;\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n  var primes, base;\n  var top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sub : base.under;\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sub) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.under) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.under)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n      position = base.under;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sub;\n    }\n  }\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\nBaseMethods.Prime = function (parser, c) {\n  var base = parser.stack.Prev();\n  if (!base) {\n    base = parser.create('node', 'mi');\n  }\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup)) {\n    throw new TexError_js_1.default('DoubleExponentPrime', 'Prime causes double exponent: use braces to clarify');\n  }\n  var sup = '';\n  parser.i--;\n  do {\n    sup += Entities_js_1.entities.prime;\n    parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === Entities_js_1.entities.rsquo);\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  var node = parser.create('token', 'mo', {\n    variantForm: true\n  }, sup);\n  parser.Push(parser.itemFactory.create('prime', base, node));\n};\nBaseMethods.Comment = function (parser, _c) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\nBaseMethods.Hash = function (_parser, _c) {\n  throw new TexError_js_1.default('CantUseHash1', 'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\nBaseMethods.MathFont = function (parser, name, variant) {\n  var text = parser.GetArgument(name);\n  var mml = new TexParser_js_1.default(text, __assign(__assign({}, parser.stack.env), {\n    font: variant,\n    multiLetterIdentifiers: /^[a-zA-Z]+/,\n    noAutoOP: true\n  }), parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\nBaseMethods.SetFont = function (parser, _name, font) {\n  parser.stack.env['font'] = font;\n};\nBaseMethods.SetStyle = function (parser, _name, texStyle, style, level) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    displaystyle: style,\n    scriptlevel: level\n  }));\n};\nBaseMethods.SetSize = function (parser, _name, size) {\n  parser.stack.env['size'] = size;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    mathsize: (0, lengths_js_1.em)(size)\n  }));\n};\nBaseMethods.Spacer = function (parser, _name, space) {\n  var node = parser.create('node', 'mspace', [], {\n    width: (0, lengths_js_1.em)(space)\n  });\n  var style = parser.create('node', 'mstyle', [node], {\n    scriptlevel: 0\n  });\n  parser.Push(style);\n};\nBaseMethods.LeftRight = function (parser, name) {\n  var first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\nBaseMethods.NamedFn = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n  var mml = parser.create('token', 'mi', {\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\nBaseMethods.NamedOp = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n  id = id.replace(/&thinsp;/, '\\u2006');\n  var mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstants_js_1.TexConstant.Form.PREFIX,\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\nBaseMethods.Limits = function (parser, _name, limits) {\n  var op = parser.stack.Prev(true);\n  if (!op || NodeUtil_js_1.default.getTexClass(NodeUtil_js_1.default.getCoreMO(op)) !== MmlNode_js_1.TEXCLASS.OP && NodeUtil_js_1.default.getProperty(op, 'movesupsub') == null) {\n    throw new TexError_js_1.default('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n  var top = parser.stack.Top();\n  var node;\n  if (NodeUtil_js_1.default.isType(op, 'munderover') && !limits) {\n    node = parser.create('node', 'msubsup');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil_js_1.default.isType(op, 'msubsup') && limits) {\n    node = parser.create('node', 'munderover');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  }\n  NodeUtil_js_1.default.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(op), {\n    'movablelimits': false\n  });\n  if (NodeUtil_js_1.default.getAttribute(op, 'movablelimits') || NodeUtil_js_1.default.getProperty(op, 'movablelimits')) {\n    NodeUtil_js_1.default.setProperties(op, {\n      'movablelimits': false\n    });\n  }\n};\nBaseMethods.Over = function (parser, name, open, close) {\n  var mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS);\n  if (open || close) {\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n  if (name.match(/^\\\\above/)) {\n    mml.setProperty('thickness', parser.GetDimen(name));\n  } else if (name.match(/^\\\\atop/) || open || close) {\n    mml.setProperty('thickness', 0);\n  }\n  parser.Push(mml);\n};\nBaseMethods.Frac = function (parser, name) {\n  var num = parser.ParseArg(name);\n  var den = parser.ParseArg(name);\n  var node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\nBaseMethods.Sqrt = function (parser, name) {\n  var n = parser.GetBrackets(name);\n  var arg = parser.GetArgument(name);\n  if (arg === '\\\\frac') {\n    arg += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n  var mml = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n  if (!n) {\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n  parser.Push(mml);\n};\nfunction parseRoot(parser, n) {\n  var env = parser.stack.env;\n  var inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  var newParser = new TexParser_js_1.default(n, env, parser.configuration);\n  var node = newParser.mml();\n  var global = newParser.stack.global;\n  if (global['leftRoot'] || global['upRoot']) {\n    var def = {};\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n  env['inRoot'] = inRoot;\n  return node;\n}\nBaseMethods.Root = function (parser, name) {\n  var n = parser.GetUpTo(name, '\\\\of');\n  var arg = parser.ParseArg(name);\n  var node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\nBaseMethods.MoveRoot = function (parser, name, id) {\n  if (!parser.stack.env['inRoot']) {\n    throw new TexError_js_1.default('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n  if (parser.stack.global[id]) {\n    throw new TexError_js_1.default('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n  var n = parser.GetArgument(name);\n  if (!n.match(/-?[0-9]+/)) {\n    throw new TexError_js_1.default('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n  n = parseInt(n, 10) / 15 + 'em';\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n  parser.stack.global[id] = n;\n};\nBaseMethods.Accent = function (parser, name, accent, stretchy) {\n  var c = parser.ParseArg(name);\n  var def = __assign(__assign({}, ParseUtil_js_1.default.getFontDef(parser)), {\n    accent: true,\n    mathaccent: true\n  });\n  var entity = NodeUtil_js_1.default.createEntity(accent);\n  var moNode = parser.create('token', 'mo', def, entity);\n  var mml = moNode;\n  NodeUtil_js_1.default.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  var mo = NodeUtil_js_1.default.isEmbellished(c) ? NodeUtil_js_1.default.getCoreMO(c) : c;\n  if (NodeUtil_js_1.default.isType(mo, 'mo') || NodeUtil_js_1.default.getProperty(mo, 'movablelimits')) {\n    NodeUtil_js_1.default.setProperties(mo, {\n      'movablelimits': false\n    });\n  }\n  var muoNode = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(muoNode, 0, c);\n  NodeUtil_js_1.default.setChild(muoNode, 1, null);\n  NodeUtil_js_1.default.setChild(muoNode, 2, mml);\n  var texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\nBaseMethods.UnderOver = function (parser, name, c, stack) {\n  var entity = NodeUtil_js_1.default.createEntity(c);\n  var mo = parser.create('token', 'mo', {\n    stretchy: true,\n    accent: true\n  }, entity);\n  var pos = name.charAt(1) === 'o' ? 'over' : 'under';\n  var base = parser.ParseArg(name);\n  parser.Push(ParseUtil_js_1.default.underOver(parser, base, mo, pos, stack));\n};\nBaseMethods.Overset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  if (top.isKind('mo')) {\n    NodeUtil_js_1.default.setAttribute(top, 'accent', false);\n  }\n  var node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\nBaseMethods.Underset = function (parser, name) {\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  if (bot.isKind('mo')) {\n    NodeUtil_js_1.default.setAttribute(bot, 'accent', false);\n  }\n  var node = parser.create('node', 'munder', [base, bot], {\n    accentunder: false\n  });\n  parser.Push(node);\n};\nBaseMethods.Overunderset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  if (top.isKind('mo')) {\n    NodeUtil_js_1.default.setAttribute(top, 'accent', false);\n  }\n  if (bot.isKind('mo')) {\n    NodeUtil_js_1.default.setAttribute(bot, 'accent', false);\n  }\n  var node = parser.create('node', 'munderover', [base, bot, top], {\n    accent: false,\n    accentunder: false\n  });\n  parser.Push(node);\n};\nBaseMethods.TeXAtom = function (parser, name, mclass) {\n  var def = {\n    texClass: mclass\n  };\n  var mml;\n  var node;\n  var parsed;\n  if (mclass === MmlNode_js_1.TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    var arg = parser.GetArgument(name);\n    var match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n    if (match) {\n      def['mathvariant'] = TexConstants_js_1.TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      parsed = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n  parser.Push(mml);\n};\nBaseMethods.MmlToken = function (parser, name) {\n  var kind = parser.GetArgument(name);\n  var attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  var text = parser.GetArgument(name);\n  var def = {};\n  var keep = [];\n  var node;\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n  if (!node || !node.isToken) {\n    throw new TexError_js_1.default('NotMathMLToken', '%1 is not a token element', kind);\n  }\n  while (attr !== '') {\n    var match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n    if (!match) {\n      throw new TexError_js_1.default('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      throw new TexError_js_1.default('UnknownAttrForElement', '%1 is not a recognized attribute for %2', match[1], kind);\n    }\n    var value = ParseUtil_js_1.default.MmlFilterAttribute(parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      } else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n      def[match[1]] = value;\n      keep.push(match[1]);\n    }\n    attr = attr.substr(match[0].length);\n  }\n  if (keep.length) {\n    def['mjx-keep-attrs'] = keep.join(' ');\n  }\n  var textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil_js_1.default.setProperties(node, def);\n  parser.Push(node);\n};\nBaseMethods.Strut = function (parser, _name) {\n  var row = parser.create('node', 'mrow');\n  var padded = parser.create('node', 'mpadded', [row], {\n    height: '8.6pt',\n    depth: '3pt',\n    width: 0\n  });\n  parser.Push(padded);\n};\nBaseMethods.Phantom = function (parser, name, v, h) {\n  var box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n  if (v || h) {\n    box = parser.create('node', 'mpadded', [box]);\n    if (h) {\n      NodeUtil_js_1.default.setAttribute(box, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(box, 'depth', 0);\n    }\n    if (v) {\n      NodeUtil_js_1.default.setAttribute(box, 'width', 0);\n    }\n  }\n  var atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\nBaseMethods.Smash = function (parser, name) {\n  var bt = ParseUtil_js_1.default.trimSpaces(parser.GetBrackets(name, ''));\n  var smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n  switch (bt) {\n    case 'b':\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n      break;\n    case 't':\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      break;\n    default:\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n  }\n  var atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\nBaseMethods.Lap = function (parser, name) {\n  var mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {\n    width: 0\n  });\n  if (name === '\\\\llap') {\n    NodeUtil_js_1.default.setAttribute(mml, 'lspace', '-1width');\n  }\n  var atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\nBaseMethods.RaiseLower = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var item = parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'vertical'\n  });\n  if (h.charAt(0) === '-') {\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n  if (name === '\\\\lower') {\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n  parser.Push(item);\n};\nBaseMethods.MoveLeftRight = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var nh = h.charAt(0) === '-' ? h.slice(1) : '-' + h;\n  if (name === '\\\\moveleft') {\n    var tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n  parser.Push(parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'horizontal',\n    left: parser.create('node', 'mspace', [], {\n      width: h\n    }),\n    right: parser.create('node', 'mspace', [], {\n      width: nh\n    })\n  }));\n};\nBaseMethods.Hskip = function (parser, name) {\n  var node = parser.create('node', 'mspace', [], {\n    width: parser.GetDimen(name)\n  });\n  parser.Push(node);\n};\nBaseMethods.Nonscript = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\nBaseMethods.Rule = function (parser, name, style) {\n  var w = parser.GetDimen(name),\n    h = parser.GetDimen(name),\n    d = parser.GetDimen(name);\n  var def = {\n    width: w,\n    height: h,\n    depth: d\n  };\n  if (style !== 'blank') {\n    def['mathbackground'] = parser.stack.env['color'] || 'black';\n  }\n  var node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\nBaseMethods.rule = function (parser, name) {\n  var v = parser.GetBrackets(name),\n    w = parser.GetDimen(name),\n    h = parser.GetDimen(name);\n  var mml = parser.create('node', 'mspace', [], {\n    width: w,\n    height: h,\n    mathbackground: parser.stack.env['color'] || 'black'\n  });\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {\n      voffset: v\n    });\n    if (v.match(/^\\-/)) {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', v);\n      NodeUtil_js_1.default.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n  parser.Push(mml);\n};\nBaseMethods.MakeBig = function (parser, name, mclass, size) {\n  size *= P_HEIGHT;\n  var sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  var delim = parser.GetDelimiter(name, true);\n  var mo = parser.create('token', 'mo', {\n    minsize: sizeStr,\n    maxsize: sizeStr,\n    fence: true,\n    stretchy: true,\n    symmetric: true\n  }, delim);\n  var node = parser.create('node', 'TeXAtom', [mo], {\n    texClass: mclass\n  });\n  parser.Push(node);\n};\nBaseMethods.BuildRel = function (parser, name) {\n  var top = parser.ParseUpTo(name, '\\\\over');\n  var bot = parser.ParseArg(name);\n  var node = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(node, 0, bot);\n  NodeUtil_js_1.default.setChild(node, 1, null);\n  NodeUtil_js_1.default.setChild(node, 2, top);\n  var atom = parser.create('node', 'TeXAtom', [node], {\n    texClass: MmlNode_js_1.TEXCLASS.REL\n  });\n  parser.Push(atom);\n};\nBaseMethods.HBox = function (parser, name, style, font) {\n  parser.PushAll(ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), style, font));\n};\nBaseMethods.FBox = function (parser, name) {\n  var internal = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n  var node = parser.create('node', 'menclose', internal, {\n    notation: 'box'\n  });\n  parser.Push(node);\n};\nBaseMethods.FrameBox = function (parser, name) {\n  var width = parser.GetBrackets(name);\n  var pos = parser.GetBrackets(name) || 'c';\n  var mml = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width: width,\n      'data-align': (0, Options_js_1.lookup)(pos, {\n        l: 'left',\n        r: 'right'\n      }, 'center')\n    })];\n  }\n  var node = parser.create('node', 'TeXAtom', [parser.create('node', 'menclose', mml, {\n    notation: 'box'\n  })], {\n    texClass: MmlNode_js_1.TEXCLASS.ORD\n  });\n  parser.Push(node);\n};\nBaseMethods.Not = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('not'));\n};\nBaseMethods.Dots = function (parser, _name) {\n  var ldotsEntity = NodeUtil_js_1.default.createEntity('2026');\n  var cdotsEntity = NodeUtil_js_1.default.createEntity('22EF');\n  var ldots = parser.create('token', 'mo', {\n    stretchy: false\n  }, ldotsEntity);\n  var cdots = parser.create('token', 'mo', {\n    stretchy: false\n  }, cdotsEntity);\n  parser.Push(parser.itemFactory.create('dots').setProperties({\n    ldots: ldots,\n    cdots: cdots\n  }));\n};\nBaseMethods.Matrix = function (parser, _name, open, close, align, spacing, vspacing, style, cases, numbered) {\n  var c = parser.GetNext();\n  if (c === '') {\n    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (c === '{') {\n    parser.i++;\n  } else {\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n  var array = parser.itemFactory.create('array').setProperty('requireClose', true);\n  array.arraydef = {\n    rowspacing: vspacing || '4pt',\n    columnspacing: spacing || '1em'\n  };\n  if (cases) {\n    array.setProperty('isCases', true);\n  }\n  if (numbered) {\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n  if (open || close) {\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n  if (style === 'D') {\n    array.arraydef.displaystyle = true;\n  }\n  if (align != null) {\n    array.arraydef.columnalign = align;\n  }\n  parser.Push(array);\n};\nBaseMethods.Entry = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isEntry: true,\n    name: name\n  }));\n  var top = parser.stack.Top();\n  var env = top.getProperty('casesEnv');\n  var cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  var str = parser.string;\n  var braces = 0,\n    close = -1,\n    i = parser.i,\n    m = str.length;\n  var end = env ? new RegExp(\"^\\\\\\\\end\\\\s*\\\\{\".concat(env.replace(/\\*/, '\\\\*'), \"\\\\}\")) : null;\n  while (i < m) {\n    var c = str.charAt(i);\n    if (c === '{') {\n      braces++;\n      i++;\n    } else if (c === '}') {\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      throw new TexError_js_1.default('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      var rest = str.substr(i);\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || end && rest.match(end)) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      i++;\n    }\n  }\n  var text = str.substr(parser.i, i - parser.i);\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    var internal = ParseUtil_js_1.default.internalMath(parser, ParseUtil_js_1.default.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\nBaseMethods.Cr = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name\n  }));\n};\nBaseMethods.CrLaTeX = function (parser, name, nobrackets) {\n  if (nobrackets === void 0) {\n    nobrackets = false;\n  }\n  var n;\n  if (!nobrackets) {\n    if (parser.string.charAt(parser.i) === '*') {\n      parser.i++;\n    }\n    if (parser.string.charAt(parser.i) === '[') {\n      var dim = parser.GetBrackets(name, '');\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dim), 2),\n        value = _a[0],\n        unit = _a[1];\n      if (dim && !value) {\n        throw new TexError_js_1.default('BracketMustBeDimension', 'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n      n = value + unit;\n    }\n  }\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name,\n    linebreak: true\n  }));\n  var top = parser.stack.Top();\n  var node;\n  if (top instanceof sitem.ArrayItem) {\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      node = parser.create('node', 'mspace', [], {\n        depth: n\n      });\n      parser.Push(node);\n    }\n    node = parser.create('node', 'mspace', [], {\n      linebreak: TexConstants_js_1.TexConstant.LineBreak.NEWLINE\n    });\n    parser.Push(node);\n  }\n};\nBaseMethods.HLine = function (parser, _name, style) {\n  if (style == null) {\n    style = 'solid';\n  }\n  var top = parser.stack.Top();\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    throw new TexError_js_1.default('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n  if (!top.table.length) {\n    top.frame.push('top');\n  } else {\n    var lines = top.arraydef['rowlines'] ? top.arraydef['rowlines'].split(/ /) : [];\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\nBaseMethods.HFill = function (parser, _name) {\n  var top = parser.stack.Top();\n  if (top instanceof sitem.ArrayItem) {\n    top.hfill.push(top.Size());\n  } else {\n    throw new TexError_js_1.default('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\nBaseMethods.BeginEnd = function (parser, name) {\n  var env = parser.GetArgument(name);\n  if (env.match(/\\\\/i)) {\n    throw new TexError_js_1.default('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n  var macro = parser.configuration.handlers.get('environment').lookup(env);\n  if (macro && name === '\\\\end') {\n    if (!macro.args[0]) {\n      var mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n    parser.stack.env['closing'] = env;\n  }\n  ParseUtil_js_1.default.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\nBaseMethods.Array = function (parser, begin, open, close, align, spacing, vspacing, style, raggedHeight) {\n  if (!align) {\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n  var lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var array = parser.itemFactory.create('array');\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: vspacing || '4pt'\n  };\n  if (lines.match(/[|:]/)) {\n    if (lines.charAt(0).match(/[|:]/)) {\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      array.frame.push('right');\n    }\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines = lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n  if (open) {\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n  if (close) {\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n  if (style === 'D') {\n    array.arraydef['displaystyle'] = true;\n  } else if (style) {\n    array.arraydef['displaystyle'] = false;\n  }\n  if (style === 'S') {\n    array.arraydef['scriptlevel'] = 1;\n  }\n  if (raggedHeight) {\n    array.arraydef['useHeight'] = false;\n  }\n  parser.Push(begin);\n  return array;\n};\nBaseMethods.AlignedArray = function (parser, begin) {\n  var align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  var item = BaseMethods.Array(parser, begin);\n  return ParseUtil_js_1.default.setArrayAlign(item, align);\n};\nBaseMethods.Equation = function (parser, begin, numbered) {\n  parser.Push(begin);\n  ParseUtil_js_1.default.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).setProperty('name', begin.getName());\n};\nBaseMethods.EqnArray = function (parser, begin, numbered, taggable, align, spacing) {\n  parser.Push(begin);\n  if (taggable) {\n    ParseUtil_js_1.default.checkEqnEnv(parser);\n  }\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var newItem = parser.itemFactory.create('eqnarray', begin.getName(), numbered, taggable, parser.stack.global);\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\nBaseMethods.HandleNoTag = function (parser, _name) {\n  parser.tags.notag();\n};\nBaseMethods.HandleLabel = function (parser, name) {\n  var label = parser.GetArgument(name);\n  if (label === '') {\n    return;\n  }\n  if (!parser.tags.refUpdate) {\n    if (parser.tags.label) {\n      throw new TexError_js_1.default('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n    parser.tags.label = label;\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      throw new TexError_js_1.default('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n    parser.tags.labels[label] = new Tags_js_1.Label();\n  }\n};\nBaseMethods.HandleRef = function (parser, name, eqref) {\n  var label = parser.GetArgument(name);\n  var ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n  if (!ref) {\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n    ref = new Tags_js_1.Label();\n  }\n  var tag = ref.tag;\n  if (eqref) {\n    tag = parser.tags.formatTag(tag);\n  }\n  var node = parser.create('node', 'mrow', ParseUtil_js_1.default.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL),\n    'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\nBaseMethods.Macro = function (parser, name, macro, argcount, def) {\n  if (argcount) {\n    var args = [];\n    if (def != null) {\n      var optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n    for (var i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n    macro = ParseUtil_js_1.default.substituteArgs(parser, args, macro);\n  }\n  parser.string = ParseUtil_js_1.default.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil_js_1.default.checkMaxMacros(parser);\n};\nBaseMethods.MathChoice = function (parser, name) {\n  var D = parser.ParseArg(name);\n  var T = parser.ParseArg(name);\n  var S = parser.ParseArg(name);\n  var SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\nexports.default = BaseMethods;","map":{"version":3,"names":["sitem","__importStar","require","NodeUtil_js_1","__importDefault","TexError_js_1","TexParser_js_1","TexConstants_js_1","ParseUtil_js_1","MmlNode_js_1","Tags_js_1","lengths_js_1","Entities_js_1","Options_js_1","BaseMethods","P_HEIGHT","MmlTokenAllow","fontfamily","fontsize","fontweight","fontstyle","color","background","id","href","style","Open","parser","_c","Push","itemFactory","create","Close","Tilde","entities","nbsp","Space","_parser","Superscript","GetNext","match","string","substr","i","primes","base","top","stack","Top","isKind","_a","__read","Peek","Pop","Prev","movesupsub","default","getProperty","position","isType","sup","over","getChildAt","setProperties","Subscript","sub","under","Prime","c","prime","rsquo","length","node","variantForm","Comment","charAt","Hash","MathFont","name","variant","text","GetArgument","mml","__assign","env","font","multiLetterIdentifiers","noAutoOP","configuration","SetFont","_name","SetStyle","texStyle","level","setProperty","displaystyle","scriptlevel","SetSize","size","mathsize","em","Spacer","space","width","LeftRight","first","GetDelimiter","NamedFn","texClass","TEXCLASS","OP","NamedOp","replace","movablelimits","form","TexConstant","Form","PREFIX","Limits","limits","op","getTexClass","getCoreMO","currentCS","copyChildren","Last","getAttribute","Over","open","close","GetDimen","Frac","num","ParseArg","den","Sqrt","n","GetBrackets","arg","parseRoot","inRoot","newParser","global","def","Root","GetUpTo","MoveRoot","parseInt","Accent","accent","stretchy","getFontDef","mathaccent","entity","createEntity","moNode","setAttribute","mo","isEmbellished","muoNode","setChild","texAtom","UnderOver","pos","underOver","Overset","checkMovableLimits","Underset","bot","accentunder","Overunderset","TeXAtom","mclass","parsed","Variant","NORMAL","MmlToken","kind","attr","keep","e","isToken","attributes","hasDefault","value","MmlFilterAttribute","toLowerCase","push","join","textNode","appendChild","Strut","row","padded","height","depth","Phantom","v","h","box","atom","Smash","bt","trimSpaces","smash","Lap","RaiseLower","item","move","slice","MoveLeftRight","nh","tmp","left","right","Hskip","Nonscript","Rule","w","d","rule","mathbackground","voffset","MakeBig","sizeStr","String","delim","minsize","maxsize","fence","symmetric","BuildRel","ParseUpTo","REL","HBox","PushAll","internalMath","FBox","internal","notation","FrameBox","lookup","l","r","ORD","Not","Dots","ldotsEntity","cdotsEntity","ldots","cdots","Matrix","align","spacing","vspacing","cases","numbered","array","arraydef","rowspacing","columnspacing","side","columnalign","Entry","isEntry","str","braces","m","end","RegExp","concat","rest","Cr","isCR","CrLaTeX","nobrackets","dim","matchDimen","unit","linebreak","ArrayItem","addRowSpacing","LineBreak","NEWLINE","HLine","Size","table","frame","lines","split","HFill","hfill","BeginEnd","macro","handlers","get","args","checkMaxMacros","parse","Array","begin","raggedHeight","getName","dashed","columnlines","convertDelimiter","AlignedArray","setArrayAlign","Equation","checkEqnEnv","EqnArray","taggable","newItem","options","minlabelspacing","HandleNoTag","tags","notag","HandleLabel","label","refUpdate","allLabels","labels","Label","HandleRef","eqref","ref","redo","tag","formatTag","formatUrl","baseURL","Macro","argcount","optional","substituteArgs","addArgs","MathChoice","D","T","S","SS","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/base/BaseMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The Basic Parse methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport * as sitem from './BaseItems.js';\nimport {StackItem, EnvList} from '../StackItem.js';\nimport {Macro} from '../Symbol.js';\nimport {ParseMethod} from '../Types.js';\nimport NodeUtil from '../NodeUtil.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport {TexConstant} from '../TexConstants.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {MmlNode, TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMunderover} from '../../../core/MmlTree/MmlNodes/munderover.js';\nimport {Label} from '../Tags.js';\nimport {em} from '../../../util/lengths.js';\nimport {entities} from '../../../util/Entities.js';\nimport {lookup} from '../../../util/Options.js';\n\n\n// Namespace\nlet BaseMethods: Record<string, ParseMethod> = {};\n\nconst P_HEIGHT = 1.2 / .85;   // cmex10 height plus depth over .85\nconst MmlTokenAllow: {[key: string]: number} = {\n  fontfamily: 1, fontsize: 1, fontweight: 1, fontstyle: 1,\n  color: 1, background: 1,\n  id: 1, 'class': 1, href: 1, style: 1\n};\n\n\n\n/**\n * Handle LaTeX tokens.\n */\n\n/**\n * Handle {\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Open = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('open'));\n};\n\n/**\n * Handle }\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Close = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('close'));\n};\n\n\n/**\n * Handle tilde and spaces.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Tilde = function(parser: TexParser, _c: string) {\n  // @test Tilde, Tilde2\n  parser.Push(parser.create('token', 'mtext', {}, entities.nbsp));\n};\n\n/**\n * Handling space, by doing nothing.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Space = function(_parser: TexParser, _c: string) {};\n\n/**\n * Handle ^\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Superscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string = parser.string.substr(0, parser.i + 1) +\n      ' ' + parser.string.substr(parser.i + 1);\n  }\n  let primes: MmlNode;\n  let base: MmlNode | void;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Prime\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    // @test Empty base2, Square, Cube\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty base\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ? (base as MmlMsubsup).sup :\n    (base as MmlMunderover).over;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).over) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-super-error, Double-over-error\n    throw new TexError('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Move Superscript, Large Operator\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).over)) {\n        // @test Large Operator\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).over;\n    } else {\n      // @test Empty base, Empty base2, Square, Cube\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sup;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle _\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Subscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string =\n      parser.string.substr(0, parser.i + 1) + ' ' +\n      parser.string.substr(parser.i + 1);\n  }\n  let primes, base;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Sub\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty Base Index\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ?\n    (base as MmlMsubsup).sub : (base as MmlMunderover).under;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sub)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).under) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-sub-error, Double-under-error\n    throw new TexError('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Large Operator, Move Superscript\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).under)) {\n        // @test Move Superscript\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).under;\n    } else {\n      // @test Empty Base Index, Empty Base Index2, Index\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sub;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle '\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Prime = function(parser: TexParser, c: string) {\n  // @test Prime\n  let base = parser.stack.Prev();\n  if (!base) {\n    // @test PrimeSup, PrePrime, Prime on Sup\n    base = parser.create('node', 'mi');\n  }\n  if (NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n      NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) {\n    // @test Double Prime Error\n    throw new TexError('DoubleExponentPrime',\n                        'Prime causes double exponent: use braces to clarify');\n  }\n  let sup = '';\n  parser.i--;\n  do {\n    // @test Prime, PrimeSup, Double Prime, PrePrime\n    sup += entities.prime; parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === entities.rsquo);\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  const node = parser.create('token', 'mo', {variantForm: true}, sup);\n  parser.Push(\n    parser.itemFactory.create('prime', base, node) );\n};\n\n\n/**\n * Handle comments\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Comment = function(parser: TexParser, _c: string) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\n\n\n/**\n * Handle hash marks outside of definitions\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Hash = function(_parser: TexParser, _c: string) {\n  // @test Hash Error\n  throw new TexError('CantUseHash1',\n                      'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\n\n\n\n/**\n *\n * Handle LaTeX Macros\n *\n */\n\n\n/**\n * Handle \\mathrm, \\mathbf, etc, allowing for multi-letter runs to be one <mi>.\n */\nBaseMethods.MathFont = function(parser: TexParser, name: string, variant: string) {\n  const text = parser.GetArgument(name);\n  let mml = new TexParser(text, {\n    ...parser.stack.env,\n    font: variant,\n    multiLetterIdentifiers: /^[a-zA-Z]+/ as any,\n    noAutoOP: true\n  }, parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\n\n/**\n * Setting font, e.g., via \\\\rm, \\\\bf etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} font The font name.\n */\nBaseMethods.SetFont = function(parser: TexParser, _name: string, font: string) {\n  parser.stack.env['font'] = font;\n};\n\n/**\n * Setting style, e.g., via \\\\displaystyle, \\\\textstyle, etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} texStyle The tex style name: D, T, S, SS\n * @param {boolean} style True if we are in displaystyle.\n * @param {string} level The nesting level for scripts.\n */\nBaseMethods.SetStyle = function(parser: TexParser, _name: string,\n                                texStyle: string, style: boolean,\n                                level: string) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty(\n      'styles', {displaystyle: style, scriptlevel: level}));\n};\n\n\n/**\n * Setting size of an expression, e.g., \\\\small, \\\\huge.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} size The size value.\n */\nBaseMethods.SetSize = function(parser: TexParser, _name: string, size: number) {\n  parser.stack.env['size'] = size;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty('styles', {mathsize: em(size)}));\n};\n\n/**\n * Setting explicit spaces, e.g., via commata or colons.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} space The space value.\n */\nBaseMethods.Spacer = function(parser: TexParser, _name: string, space: number) {\n  // @test Positive Spacing, Negative Spacing\n  const node = parser.create('node', 'mspace', [], {width: em(space)});\n  const style = parser.create('node', 'mstyle', [node], {scriptlevel: 0});\n  parser.Push(style);\n};\n\n\n/**\n * Parses left/right fenced expressions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.LeftRight = function(parser: TexParser, name: string) {\n  // @test Fenced, Fenced3\n  const first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\n\n/**\n * Handle a named math function, e.g., \\\\sin, \\\\cos\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the function.\n */\nBaseMethods.NamedFn = function(parser: TexParser, name: string, id: string) {\n  // @test Named Function\n  if (!id) {\n    id = name.substr(1);\n  }\n  const mml = parser.create('token', 'mi', {texClass: TEXCLASS.OP}, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\n\n\n/**\n * Handle a named math operator, e.g., \\\\min, \\\\lim\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the operator.\n */\nBaseMethods.NamedOp = function(parser: TexParser, name: string, id: string) {\n  // @test Limit\n  if (!id) {\n    id = name.substr(1);\n  }\n  id = id.replace(/&thinsp;/, '\\u2006');\n  const mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstant.Form.PREFIX,\n    texClass: TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\n\n/**\n * Handle a limits command for math operators.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} limits The limits arguments.\n */\nBaseMethods.Limits = function(parser: TexParser, _name: string, limits: string) {\n  // @test Limits\n  let op = parser.stack.Prev(true);\n  // Get the texclass for the core operator.\n  if (!op || (NodeUtil.getTexClass(NodeUtil.getCoreMO(op)) !== TEXCLASS.OP &&\n              NodeUtil.getProperty(op, 'movesupsub') == null)) {\n    // @test Limits Error\n    throw new TexError('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n  const top = parser.stack.Top();\n  let node;\n  if (NodeUtil.isType(op, 'munderover') && !limits) {\n    // @test Limits UnderOver\n    node = parser.create('node', 'msubsup');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil.isType(op, 'msubsup') && limits) {\n    // @test Limits SubSup\n    // node = parser.create('node', 'munderover', NodeUtil.getChildren(op), {});\n    // Needs to be copied, otherwise we get an error in MmlNode.appendChild!\n    node = parser.create('node', 'munderover');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  }\n  NodeUtil.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil.setProperties(NodeUtil.getCoreMO(op), {'movablelimits': false});\n  if (NodeUtil.getAttribute(op, 'movablelimits') ||\n      NodeUtil.getProperty(op, 'movablelimits')) {\n    NodeUtil.setProperties(op, {'movablelimits': false});\n  }\n};\n\n\n/**\n * Handle over commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open The open delimiter in case of a \"withdelim\" version.\n * @param {string} close The close delimiter.\n */\nBaseMethods.Over = function(parser: TexParser, name: string, open: string, close: string) {\n  // @test Over\n  const mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS) ;\n  if (open || close) {\n    // @test Choose\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    // @test Over With Delims, Above With Delims\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n  if (name.match(/^\\\\above/)) {\n    // @test Above, Above With Delims\n    mml.setProperty('thickness', parser.GetDimen(name));\n  }\n  else if (name.match(/^\\\\atop/) || open || close) {\n    // @test Choose\n    mml.setProperty('thickness', 0);\n  }\n  parser.Push(mml);\n};\n\n/**\n * Parses a fraction.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Frac = function(parser: TexParser, name: string) {\n  // @test Frac\n  const num = parser.ParseArg(name);\n  const den = parser.ParseArg(name);\n  const node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\n\n/**\n * Parses a square root element.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Sqrt = function(parser: TexParser, name: string) {\n  const n = parser.GetBrackets(name);\n  let arg = parser.GetArgument(name);\n  if (arg === '\\\\frac') {\n    arg  += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n  let mml = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n  if (!n) {\n    // @test Square Root\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    // @test General Root\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n  parser.Push(mml);\n};\n\n\n// Utility\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} n The index of the root.\n */\nfunction parseRoot(parser: TexParser, n: string) {\n  // @test General Root, Explicit Root\n  const env = parser.stack.env;\n  const inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  const newParser = new TexParser(n, env, parser.configuration);\n  let node = newParser.mml();\n  const global = newParser.stack.global;\n  if (global['leftRoot'] || global['upRoot']) {\n    // @test Tweaked Root\n    const def: EnvList = {};\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n  env['inRoot'] = inRoot;\n  return node;\n}\n\n\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Root = function(parser: TexParser, name: string) {\n  const n = parser.GetUpTo(name, '\\\\of');\n  const arg = parser.ParseArg(name);\n  const node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\n\n\n/**\n * Parses a movable index element in a root, e.g. \\\\uproot, \\\\leftroot\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Argument which should be a string representation of an integer.\n */\nBaseMethods.MoveRoot = function(parser: TexParser, name: string, id: string) {\n  // @test Tweaked Root\n  if (!parser.stack.env['inRoot']) {\n    // @test Misplaced Move Root\n    throw new TexError('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n  if (parser.stack.global[id]) {\n    // @test Multiple Move Root\n    throw new TexError('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n  let n = parser.GetArgument(name);\n  if (!n.match(/-?[0-9]+/)) {\n    // @test Incorrect Move Root\n    throw new TexError('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n  n = (parseInt(n, 10) / 15) + 'em';\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n  parser.stack.global[id] = n;\n};\n\n\n/**\n * Handle accents.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} accent The accent.\n * @param {boolean} stretchy True if accent is stretchy.\n */\nBaseMethods.Accent = function(parser: TexParser, name: string, accent: string, stretchy: boolean) {\n  // @test Vector\n  const c = parser.ParseArg(name);\n  // @test Vector Font\n  const def = {...ParseUtil.getFontDef(parser), accent: true, mathaccent: true};\n  const entity = NodeUtil.createEntity(accent);\n  const moNode = parser.create('token', 'mo', def, entity);\n  const mml = moNode;\n  NodeUtil.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  // @test Vector Op, Vector\n  const mo = (NodeUtil.isEmbellished(c) ? NodeUtil.getCoreMO(c) : c);\n  if (NodeUtil.isType(mo, 'mo') || NodeUtil.getProperty(mo, 'movablelimits')) {\n    // @test Vector Op\n    NodeUtil.setProperties(mo, {'movablelimits': false});\n  }\n  const muoNode = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(muoNode, 0, c);\n  NodeUtil.setChild(muoNode, 1, null);\n  NodeUtil.setChild(muoNode, 2, mml);\n  let texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\n\n\n/**\n * Handles stacked elements.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} c Character to stack.\n * @param {boolean} stack True if stacked operator.\n */\nBaseMethods.UnderOver = function(parser: TexParser, name: string, c: string, stack: boolean) {\n  const entity = NodeUtil.createEntity(c);\n  const mo = parser.create('token', 'mo', {stretchy: true, accent: true}, entity);\n  const pos = (name.charAt(1) === 'o' ? 'over' : 'under');\n  const base = parser.ParseArg(name);\n  parser.Push(ParseUtil.underOver(parser, base, mo, pos, stack));\n};\n\n\n/**\n * Handles overset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overset = function(parser: TexParser, name: string) {\n  // @test Overset\n  const top = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  if (top.isKind('mo')) {\n    NodeUtil.setAttribute(top, 'accent', false);\n  }\n  const node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\n\n\n/**\n * Handles underset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Underset = function(parser: TexParser, name: string) {\n  // @test Underset\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  if (bot.isKind('mo')) {\n    NodeUtil.setAttribute(bot, 'accent', false);\n  }\n  const node = parser.create('node', 'munder', [base, bot], {accentunder: false});\n  parser.Push(node);\n};\n\n\n/**\n * Handles overunderset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overunderset = function(parser: TexParser, name: string) {\n  const top = parser.ParseArg(name);\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  if (top.isKind('mo')) {\n    NodeUtil.setAttribute(top, 'accent', false);\n  }\n  if (bot.isKind('mo')) {\n    NodeUtil.setAttribute(bot, 'accent', false);\n  }\n  const node = parser.create('node', 'munderover', [base, bot, top], {accent: false, accentunder: false});\n  parser.Push(node);\n};\n\n\n/**\n * Creates TeXAtom, when class of element is changed explicitly.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The new TeX class.\n */\nBaseMethods.TeXAtom = function(parser: TexParser, name: string, mclass: number) {\n  let def: EnvList = {texClass: mclass};\n  let mml: StackItem | MmlNode;\n  let node: MmlNode;\n  let parsed: MmlNode;\n  if (mclass === TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    const arg = parser.GetArgument(name);\n    const match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n    if (match) {\n      // @test Mathop\n      def['mathvariant'] = TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      // @test Mathop Cal\n      parsed = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    // @test Mathrel\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n  parser.Push(mml);\n};\n\n\n/**\n * Creates mmltoken elements. Used in Macro substitutions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MmlToken = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const kind = parser.GetArgument(name);\n  let attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  const text = parser.GetArgument(name);\n  const def: EnvList = {};\n  const keep: string[] = [];\n  let node: MmlNode;\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n  if (!node || !node.isToken) {\n    // @test Token Illegal Type, Token Wrong Type\n    throw new TexError('NotMathMLToken', '%1 is not a token element', kind);\n  }\n  while (attr !== '') {\n    const match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n    if (!match) {\n      // @test Token Invalid Attribute\n      throw new TexError('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      // @test Token Unknown Attribute, Token Wrong Attribute\n      throw new TexError('UnknownAttrForElement',\n                          '%1 is not a recognized attribute for %2',\n                          match[1], kind);\n    }\n    let value: string | boolean = ParseUtil.MmlFilterAttribute(\n      parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      }\n      else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n      def[match[1]] = value;\n      keep.push(match[1]);\n    }\n    attr = attr.substr(match[0].length);\n  }\n  if (keep.length) {\n    def['mjx-keep-attrs'] = keep.join(' ');\n  }\n  const textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil.setProperties(node, def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle strut.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Strut = function(parser: TexParser, _name: string) {\n  // @test Strut\n  const row = parser.create('node', 'mrow');\n  const padded = parser.create('node', 'mpadded', [row],\n                                                         {height: '8.6pt', depth: '3pt', width: 0});\n  parser.Push(padded);\n};\n\n/**\n * Handle phantom commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} v Vertical size.\n * @param {string} h Horizontal size.\n */\nBaseMethods.Phantom = function(parser: TexParser, name: string, v: string, h: string) {\n  // @test Phantom\n  let box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n  if (v || h) {\n    // TEMP: Changes here\n    box = parser.create('node', 'mpadded', [box]);\n    if (h) {\n      // @test Horizontal Phantom\n      NodeUtil.setAttribute(box, 'height', 0);\n      NodeUtil.setAttribute(box, 'depth', 0);\n    }\n    if (v) {\n      // @test Vertical Phantom\n      NodeUtil.setAttribute(box, 'width', 0);\n    }\n  }\n  const atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\n\n/**\n * Handle smash.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Smash = function(parser: TexParser, name: string) {\n  // @test Smash, Smash Top, Smash Bottom\n  const bt = ParseUtil.trimSpaces(parser.GetBrackets(name, ''));\n  const smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n  // TEMP: Changes here:\n  switch (bt) {\n  case 'b': NodeUtil.setAttribute(smash, 'depth', 0); break;\n  case 't': NodeUtil.setAttribute(smash, 'height', 0); break;\n  default:\n    NodeUtil.setAttribute(smash, 'height', 0);\n    NodeUtil.setAttribute(smash, 'depth', 0);\n  }\n  const atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\n\n/**\n * Handle rlap and llap commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Lap = function(parser: TexParser, name: string) {\n  // @test Llap, Rlap\n  const mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {width: 0});\n  if (name === '\\\\llap') {\n    // @test Llap\n    NodeUtil.setAttribute(mml, 'lspace', '-1width');\n  }\n  const atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\n\n/**\n * Handle raise and lower commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.RaiseLower = function(parser: TexParser, name: string) {\n  // @test Raise, Lower, Raise Negative, Lower Negative\n  let h = parser.GetDimen(name);\n  let item =\n    parser.itemFactory.create('position').setProperties({name: parser.currentCS, move: 'vertical'}) ;\n  // TEMP: Changes here:\n  if (h.charAt(0) === '-') {\n    // @test Raise Negative, Lower Negative\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n  if (name === '\\\\lower') {\n    // @test Raise, Raise Negative\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    // @test Lower, Lower Negative\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n  parser.Push(item);\n};\n\n\n/**\n * Handle moveleft, moveright commands\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MoveLeftRight = function(parser: TexParser, name: string) {\n  // @test Move Left, Move Right, Move Left Negative, Move Right Negative\n  let h = parser.GetDimen(name);\n  let nh = (h.charAt(0) === '-' ? h.slice(1) : '-' + h);\n  if (name === '\\\\moveleft') {\n    let tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n  parser.Push(\n    parser.itemFactory.create('position').setProperties({\n      name: parser.currentCS, move: 'horizontal',\n      left:  parser.create('node', 'mspace', [], {width: h}),\n      right: parser.create('node', 'mspace', [], {width: nh})}) );\n};\n\n\n/**\n * Handle horizontal spacing commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Hskip = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const node = parser.create('node', 'mspace', [],\n                             {width: parser.GetDimen(name)});\n  parser.Push(node);\n};\n\n\n/**\n * Handle removal of spaces in script modes\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Nonscript = function(parser: TexParser, _name: string) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\n\n\n/**\n * Handle Rule and Space command\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style The style of the rule spacer.\n */\nBaseMethods.Rule = function(parser: TexParser, name: string, style: string) {\n  // @test Rule 3D, Space 3D\n  const w = parser.GetDimen(name),\n  h = parser.GetDimen(name),\n  d = parser.GetDimen(name);\n  let def: EnvList = {width: w, height: h, depth: d};\n  if (style !== 'blank') {\n    def['mathbackground'] = (parser.stack.env['color'] || 'black');\n  }\n  const node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle rule command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.rule = function(parser: TexParser, name: string) {\n  // @test Rule 2D\n  const v = parser.GetBrackets(name),\n  w = parser.GetDimen(name),\n  h = parser.GetDimen(name);\n  let mml = parser.create('node', 'mspace', [], {\n    width: w, height: h,\n    mathbackground: (parser.stack.env['color'] || 'black') });\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {voffset: v});\n    if (v.match(/^\\-/)) {\n      NodeUtil.setAttribute(mml, 'height', v);\n      NodeUtil.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n  parser.Push(mml);\n};\n\n/**\n * Handle big command sequences, e.g., \\\\big, \\\\Bigg.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The TeX class of the element.\n * @param {number} size The em size.\n */\nBaseMethods.MakeBig = function(parser: TexParser, name: string, mclass: number, size: number) {\n  // @test Choose, Over With Delims, Above With Delims\n  size *= P_HEIGHT;\n  let sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  const delim = parser.GetDelimiter(name, true);\n  const mo = parser.create('token', 'mo', {\n    minsize: sizeStr, maxsize: sizeStr,\n    fence: true, stretchy: true, symmetric: true\n  }, delim);\n  const node = parser.create('node', 'TeXAtom', [mo], {texClass: mclass});\n  parser.Push(node);\n};\n\n\n/**\n * Handle buildrel command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BuildRel = function(parser: TexParser, name: string) {\n  // @test BuildRel, BuildRel Expression\n  const top = parser.ParseUpTo(name, '\\\\over');\n  const bot = parser.ParseArg(name);\n  const node = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(node, 0, bot);\n  NodeUtil.setChild(node, 1, null);\n  NodeUtil.setChild(node, 2, top);\n  const atom = parser.create('node', 'TeXAtom', [node], {texClass: TEXCLASS.REL});\n  parser.Push(atom);\n};\n\n\n/**\n * Handle horizontal boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Box style.\n * @param {string} font The mathvariant to use\n */\nBaseMethods.HBox = function(parser: TexParser, name: string, style: string, font?: string) {\n  // @test Hbox\n  parser.PushAll(ParseUtil.internalMath(parser, parser.GetArgument(name), style, font));\n};\n\n/**\n * Handle framed boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FBox = function(parser: TexParser, name: string) {\n  // @test Fbox\n  const internal = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  const node = parser.create('node', 'menclose', internal, {notation: 'box'});\n  parser.Push(node);\n};\n\n/**\n * Handle framed boxes with options.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FrameBox = function(parser: TexParser, name: string) {\n  const width = parser.GetBrackets(name);\n  const pos = parser.GetBrackets(name) || 'c';\n  let mml = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width,\n      'data-align': lookup(pos, {l: 'left', r: 'right'}, 'center')\n    })];\n  }\n  const node = parser.create('node', 'TeXAtom',\n                             [parser.create('node', 'menclose', mml, {notation: 'box'})],\n                             {texClass: TEXCLASS.ORD});\n  parser.Push(node);\n};\n\n\n/**\n * Handle \\\\not.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Not = function(parser: TexParser, _name: string) {\n  // @test Negation Simple, Negation Complex, Negation Explicit,\n  //       Negation Large\n  parser.Push(parser.itemFactory.create('not'));\n};\n\n\n/**\n * Handle dots.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Dots = function(parser: TexParser, _name: string) {\n  // @test Operator Dots\n  const ldotsEntity = NodeUtil.createEntity('2026');\n  const cdotsEntity = NodeUtil.createEntity('22EF');\n  const ldots = parser.create('token', 'mo', {stretchy: false}, ldotsEntity);\n  const cdots = parser.create('token', 'mo', {stretchy: false}, cdotsEntity);\n  parser.Push(\n    parser.itemFactory.create('dots').setProperties({\n      ldots: ldots,\n      cdots: cdots\n    }) );\n};\n\n\n/**\n * Handle small matrix environments.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} cases Is it a cases environment.\n * @param {boolean} numbered Is it a numbered environment.\n */\nBaseMethods.Matrix = function(parser: TexParser, _name: string,\n                              open: string, close: string, align: string,\n                              spacing: string, vspacing: string, style: string,\n                              cases: boolean, numbered: boolean) {\n  const c = parser.GetNext();\n  if (c === '') {\n    // @test Matrix Error\n    throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (c === '{') {\n    // @test Matrix Braces, Matrix Columns, Matrix Rows.\n    parser.i++;\n  } else {\n    // @test Matrix Arg\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n  // @test Matrix Braces, Matrix Columns, Matrix Rows.\n  const array = parser.itemFactory.create('array').setProperty('requireClose', true) as sitem.ArrayItem;\n  array.arraydef = {\n    rowspacing: (vspacing || '4pt'),\n    columnspacing: (spacing || '1em')\n  };\n  if (cases) {\n    // @test Matrix Cases\n    array.setProperty('isCases', true);\n  }\n  if (numbered) {\n    // @test Matrix Numbered\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n  if (open || close) {\n    // @test Matrix Parens, Matrix Parens Subscript, Matrix Cases\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n  if (style === 'D') {\n    // @test Matrix Numbered\n    array.arraydef.displaystyle = true;\n  }\n  if (align != null) {\n    // @test Matrix Cases, Matrix Numbered\n    array.arraydef.columnalign = align;\n  }\n  parser.Push(array);\n};\n\n\n/**\n * Handle array entry.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Entry = function(parser: TexParser, name: string) {\n  // @test Label, Array, Cross Product Formula\n  parser.Push(parser.itemFactory.create('cell').setProperties({isEntry: true, name: name}));\n  const top = parser.stack.Top();\n  const env = top.getProperty('casesEnv') as string;\n  const cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  //\n  //  Make second column be in \\text{...} (unless it is already\n  //  in a \\text{...}, for backward compatibility).\n  //\n  const str = parser.string;\n  let braces = 0, close = -1, i = parser.i, m = str.length;\n  const end = (env ? new RegExp(`^\\\\\\\\end\\\\s*\\\\{${env.replace(/\\*/, '\\\\*')}\\\\}`) : null);\n  //\n  //  Look through the string character by character...\n  //\n  while (i < m) {\n    const c = str.charAt(i);\n    if (c === '{') {\n      //\n      //  Increase the nested brace count and go on\n      //\n      braces++;\n      i++;\n    } else if (c === '}') {\n      //\n      //  If there are too many close braces, just end (we will get an\n      //    error message later when the rest of the string is parsed)\n      //  Otherwise\n      //    decrease the nested brace count,\n      //    if it is now zero and we haven't already marked the end of the\n      //      first brace group, record the position (use to check for \\text{} later)\n      //    go on to the next character.\n      //\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      //\n      //  Extra alignment tabs are not allowed in cases\n      //\n      // @test ExtraAlignTab\n      throw new TexError('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      //\n      //  If the macro is \\cr or \\\\, end the search, otherwise skip the macro\n      //  (multi-letter names don't matter, as we will skip the rest of the\n      //   characters in the main loop)\n      //\n      const rest = str.substr(i);\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || (end && rest.match(end))) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      //\n      //  Go on to the next character\n      //\n      i++;\n    }\n  }\n  //\n  //  Check if the second column text is already in \\text{};\n  //  If not, process the second column as text and continue parsing from there,\n  //    (otherwise process the second column as normal, since it is in \\text{}\n  //\n  const text = str.substr(parser.i, i - parser.i);\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    const internal = ParseUtil.internalMath(parser, ParseUtil.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\n\n/**\n * Handle newline in array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Cr = function(parser: TexParser, name: string) {\n  // @test Cr Linebreak, Misplaced Cr\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name}));\n};\n\n\n/**\n * Handle newline outside array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} nobrackets Flag indicating if newline is followed by\n *     brackets.\n */\nBaseMethods.CrLaTeX = function(parser: TexParser, name: string, nobrackets: boolean = false) {\n  let n: string;\n  if (!nobrackets) {\n    // TODO: spaces before * and [ are not allowed in AMS environments like align, but\n    //       should be allowed in array and eqnarray.  This distinction should be honored here.\n    if (parser.string.charAt(parser.i) === '*') {  // The * controls page breaking, so ignore it\n      parser.i++;\n    }\n    if (parser.string.charAt(parser.i) === '[') {\n      let dim = parser.GetBrackets(name, '');\n      let [value, unit, ] = ParseUtil.matchDimen(dim);\n      // @test Custom Linebreak\n      if (dim && !value) {\n        // @test Dimension Error\n        throw new TexError('BracketMustBeDimension',\n                           'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n      n = value + unit;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name, linebreak: true})\n  );\n  const top = parser.stack.Top();\n  let node: MmlNode;\n  if (top instanceof sitem.ArrayItem) {\n    // @test Array\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      // @test Custom Linebreak\n      node = parser.create('node', 'mspace', [], {depth: n});\n      parser.Push(node);\n    }\n    // @test Linebreak\n    node = parser.create('node', 'mspace', [], {linebreak: TexConstant.LineBreak.NEWLINE});\n    parser.Push(node);\n  }\n};\n\n/**\n * Handle horizontal lines in arrays.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Style of the line. E.g., dashed.\n */\nBaseMethods.HLine = function(parser: TexParser, _name: string, style: string) {\n  if (style == null) {\n    style = 'solid';\n  }\n  const top = parser.stack.Top();\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    // @test Misplaced hline\n    throw new TexError('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n  if (!top.table.length) {\n    // @test Enclosed top, Enclosed top bottom\n    top.frame.push('top');\n  } else {\n    // @test Enclosed bottom, Enclosed top bottom\n    const lines = (top.arraydef['rowlines'] ? (top.arraydef['rowlines'] as string).split(/ /) : []);\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\n\n\n/**\n * Handle hfill commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HFill = function(parser: TexParser, _name: string) {\n  const top = parser.stack.Top();\n  if (top instanceof sitem.ArrayItem) {\n    // @test Hfill\n    top.hfill.push(top.Size());\n  } else {\n    // @test UnsupportedHFill\n    throw new TexError('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\n\n\n/**\n *   LaTeX environments\n */\n\n/**\n * Handle begin and end environments. This is a macro method.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BeginEnd = function(parser: TexParser, name: string) {\n  // @test Array1, Array2, Array Test\n  let env = parser.GetArgument(name);\n  if (env.match(/\\\\/i)) {\n    // @test InvalidEnv\n    throw new TexError('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n  let macro = parser.configuration.handlers.get('environment').lookup(env) as Macro;\n  if (macro && name === '\\\\end') {\n    // If the first argument is true, we have some sort of user defined\n    // environment. Otherwise we have a standard LaTeX environment that is\n    // handled with begin and end items.\n    if (!macro.args[0]) {\n      const mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n    // Remember the user defined environment we are closing.\n    parser.stack.env['closing'] = env;\n  }\n  ParseUtil.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\n\n\n/**\n * Handle array environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} raggedHeight Does the height need to be adjusted?\n */\nBaseMethods.Array = function(parser: TexParser, begin: StackItem,\n                             open: string, close: string, align: string,\n                             spacing: string, vspacing: string, style: string,\n                             raggedHeight: boolean) {\n  if (!align) {\n    // @test Array Single\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n  let lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  const array = parser.itemFactory.create('array') as sitem.ArrayItem;\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: (vspacing || '4pt')\n  };\n  if (lines.match(/[|:]/)) {\n    // @test Enclosed left right\n    if (lines.charAt(0).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed left\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed right\n      array.frame.push('right');\n    }\n    // @test Enclosed left right\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines =\n      lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n  if (open)  {\n    // @test Cross Product\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n  if (close) {\n    // @test Cross Product\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n  if (style === 'D') {\n    // TODO: This case never seems to occur! No test.\n    array.arraydef['displaystyle'] = true;\n  }\n  else if (style) {\n    // @test Subarray, Small Matrix\n    array.arraydef['displaystyle'] = false;\n  }\n  if (style === 'S') {\n    // @test Subarray, Small Matrix\n    array.arraydef['scriptlevel'] = 1;\n  }\n  if (raggedHeight)  {\n    // @test Subarray, Small Matrix\n    array.arraydef['useHeight'] = false;\n  }\n  parser.Push(begin);\n  return array;\n};\n\n\n/**\n * Handle aligned arrays.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n */\nBaseMethods.AlignedArray = function(parser: TexParser, begin: StackItem) {\n  // @test Array1, Array2, Array Test\n  const align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  let item = BaseMethods.Array(parser, begin);\n  return ParseUtil.setArrayAlign(item as sitem.ArrayItem, align);\n};\n\n\n/**\n * Handle equation environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n */\nBaseMethods.Equation = function (parser: TexParser, begin: StackItem, numbered: boolean) {\n  parser.Push(begin);\n  ParseUtil.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).\n    setProperty('name', begin.getName());\n};\n\n\n/**\n * Handle eqnarray.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n * @param {boolean} taggable True if taggable.\n * @param {string} align Alignment string.\n * @param {string} spacing Spacing between columns.\n */\nBaseMethods.EqnArray = function(parser: TexParser, begin: StackItem,\n                                numbered: boolean, taggable: boolean,\n                                align: string, spacing: string) {\n  // @test The Lorenz Equations, Maxwell's Equations, Cubic Binomial\n  parser.Push(begin);\n  if (taggable) {\n    ParseUtil.checkEqnEnv(parser);\n  }\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  let newItem = parser.itemFactory.create('eqnarray', begin.getName(),\n                                          numbered, taggable, parser.stack.global) as sitem.ArrayItem;\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\n\n\n/**\n * Handles no tag commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleNoTag = function(parser: TexParser, _name: string) {\n  parser.tags.notag();\n};\n\n\n/**\n * Record a label name for a tag\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleLabel = function(parser: TexParser, name: string) {\n  // @test Label, Label Empty\n  let label = parser.GetArgument(name);\n  if (label === '') {\n    // @test Label Empty\n    return;\n  }\n  if (!parser.tags.refUpdate) {\n    // @test Label, Ref, Ref Unknown\n    if (parser.tags.label) {\n      // @test Double Label Error\n      throw new TexError('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n    parser.tags.label = label;\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      // @ Duplicate Label Error\n      throw new TexError('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n    // TODO: This should be set in the tags structure!\n    parser.tags.labels[label] = new Label(); // will be replaced by tag value later\n  }\n};\n\n\n/**\n * Handle a label reference.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} eqref True if formatted as eqref.\n */\nBaseMethods.HandleRef = function(parser: TexParser, name: string, eqref: boolean) {\n  // @test Ref, Ref Unknown, Eqref, Ref Default, Ref Named\n  let label = parser.GetArgument(name);\n  let ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n  if (!ref) {\n    // @test Ref Unknown\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n    ref = new Label();\n  }\n  let tag = ref.tag;\n  if (eqref) {\n    // @test Eqref\n    tag = parser.tags.formatTag(tag);\n  }\n  let node = parser.create('node', 'mrow', ParseUtil.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL), 'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\n\n\n\n/**\n * Macros\n */\nBaseMethods.Macro = function(parser: TexParser, name: string,\n                             macro: string, argcount: number,\n                             def?: string) {\n  if (argcount) {\n    const args: string[] = [];\n    if (def != null) {\n      const optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n    for (let i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n    macro = ParseUtil.substituteArgs(parser, args, macro);\n  }\n  parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil.checkMaxMacros(parser);\n};\n\n\n/**\n * Handle MathChoice for elements whose exact size/style properties can only be\n * determined after the expression has been parsed.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MathChoice = function(parser: TexParser, name: string) {\n  const D  = parser.ParseArg(name);\n  const T  = parser.ParseArg(name);\n  const S  = parser.ParseArg(name);\n  const SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\n\n\nexport default BaseMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}