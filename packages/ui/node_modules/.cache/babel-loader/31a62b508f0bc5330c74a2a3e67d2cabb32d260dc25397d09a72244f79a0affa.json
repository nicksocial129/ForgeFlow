{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParserConfiguration = exports.ConfigurationHandler = exports.Configuration = void 0;\nvar Options_js_1 = require(\"../../util/Options.js\");\nvar MapHandler_js_1 = require(\"./MapHandler.js\");\nvar FunctionList_js_1 = require(\"../../util/FunctionList.js\");\nvar PrioritizedList_js_1 = require(\"../../util/PrioritizedList.js\");\nvar Tags_js_1 = require(\"./Tags.js\");\nvar Configuration = function () {\n  function Configuration(name, handler, fallback, items, tags, options, nodes, preprocessors, postprocessors, initMethod, configMethod, priority, parser) {\n    if (handler === void 0) {\n      handler = {};\n    }\n    if (fallback === void 0) {\n      fallback = {};\n    }\n    if (items === void 0) {\n      items = {};\n    }\n    if (tags === void 0) {\n      tags = {};\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    if (nodes === void 0) {\n      nodes = {};\n    }\n    if (preprocessors === void 0) {\n      preprocessors = [];\n    }\n    if (postprocessors === void 0) {\n      postprocessors = [];\n    }\n    if (initMethod === void 0) {\n      initMethod = null;\n    }\n    if (configMethod === void 0) {\n      configMethod = null;\n    }\n    this.name = name;\n    this.handler = handler;\n    this.fallback = fallback;\n    this.items = items;\n    this.tags = tags;\n    this.options = options;\n    this.nodes = nodes;\n    this.preprocessors = preprocessors;\n    this.postprocessors = postprocessors;\n    this.initMethod = initMethod;\n    this.configMethod = configMethod;\n    this.priority = priority;\n    this.parser = parser;\n    this.handler = Object.assign({\n      character: [],\n      delimiter: [],\n      macro: [],\n      environment: []\n    }, handler);\n  }\n  Configuration.makeProcessor = function (func, priority) {\n    return Array.isArray(func) ? func : [func, priority];\n  };\n  Configuration._create = function (name, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = {};\n    }\n    var priority = config.priority || PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY;\n    var init = config.init ? this.makeProcessor(config.init, priority) : null;\n    var conf = config.config ? this.makeProcessor(config.config, priority) : null;\n    var preprocessors = (config.preprocessors || []).map(function (pre) {\n      return _this.makeProcessor(pre, priority);\n    });\n    var postprocessors = (config.postprocessors || []).map(function (post) {\n      return _this.makeProcessor(post, priority);\n    });\n    var parser = config.parser || 'tex';\n    return new Configuration(name, config.handler || {}, config.fallback || {}, config.items || {}, config.tags || {}, config.options || {}, config.nodes || {}, preprocessors, postprocessors, init, conf, priority, parser);\n  };\n  Configuration.create = function (name, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var configuration = Configuration._create(name, config);\n    ConfigurationHandler.set(name, configuration);\n    return configuration;\n  };\n  Configuration.local = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n    return Configuration._create('', config);\n  };\n  Object.defineProperty(Configuration.prototype, \"init\", {\n    get: function () {\n      return this.initMethod ? this.initMethod[0] : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Configuration.prototype, \"config\", {\n    get: function () {\n      return this.configMethod ? this.configMethod[0] : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Configuration;\n}();\nexports.Configuration = Configuration;\nvar ConfigurationHandler;\n(function (ConfigurationHandler) {\n  var maps = new Map();\n  ConfigurationHandler.set = function (name, map) {\n    maps.set(name, map);\n  };\n  ConfigurationHandler.get = function (name) {\n    return maps.get(name);\n  };\n  ConfigurationHandler.keys = function () {\n    return maps.keys();\n  };\n})(ConfigurationHandler = exports.ConfigurationHandler || (exports.ConfigurationHandler = {}));\nvar ParserConfiguration = function () {\n  function ParserConfiguration(packages, parsers) {\n    var e_1, _a, e_2, _b;\n    if (parsers === void 0) {\n      parsers = ['tex'];\n    }\n    this.initMethod = new FunctionList_js_1.FunctionList();\n    this.configMethod = new FunctionList_js_1.FunctionList();\n    this.configurations = new PrioritizedList_js_1.PrioritizedList();\n    this.parsers = [];\n    this.handlers = new MapHandler_js_1.SubHandlers();\n    this.items = {};\n    this.tags = {};\n    this.options = {};\n    this.nodes = {};\n    this.parsers = parsers;\n    try {\n      for (var _c = __values(packages.slice().reverse()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var pkg = _d.value;\n        this.addPackage(pkg);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    try {\n      for (var _e = __values(this.configurations), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var _g = _f.value,\n          config = _g.item,\n          priority = _g.priority;\n        this.append(config, priority);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  }\n  ParserConfiguration.prototype.init = function () {\n    this.initMethod.execute(this);\n  };\n  ParserConfiguration.prototype.config = function (jax) {\n    var e_3, _a;\n    this.configMethod.execute(this, jax);\n    try {\n      for (var _b = __values(this.configurations), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var config = _c.value;\n        this.addFilters(jax, config.item);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  ParserConfiguration.prototype.addPackage = function (pkg) {\n    var name = typeof pkg === 'string' ? pkg : pkg[0];\n    var conf = this.getPackage(name);\n    conf && this.configurations.add(conf, typeof pkg === 'string' ? conf.priority : pkg[1]);\n  };\n  ParserConfiguration.prototype.add = function (name, jax, options) {\n    var e_4, _a;\n    if (options === void 0) {\n      options = {};\n    }\n    var config = this.getPackage(name);\n    this.append(config);\n    this.configurations.add(config, config.priority);\n    this.init();\n    var parser = jax.parseOptions;\n    parser.nodeFactory.setCreators(config.nodes);\n    try {\n      for (var _b = __values(Object.keys(config.items)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var kind = _c.value;\n        parser.itemFactory.setNodeClass(kind, config.items[kind]);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    Tags_js_1.TagsFactory.addTags(config.tags);\n    (0, Options_js_1.defaultOptions)(parser.options, config.options);\n    (0, Options_js_1.userOptions)(parser.options, options);\n    this.addFilters(jax, config);\n    if (config.config) {\n      config.config(this, jax);\n    }\n  };\n  ParserConfiguration.prototype.getPackage = function (name) {\n    var config = ConfigurationHandler.get(name);\n    if (config && this.parsers.indexOf(config.parser) < 0) {\n      throw Error(\"Package \".concat(name, \" doesn't target the proper parser\"));\n    }\n    return config;\n  };\n  ParserConfiguration.prototype.append = function (config, priority) {\n    priority = priority || config.priority;\n    if (config.initMethod) {\n      this.initMethod.add(config.initMethod[0], config.initMethod[1]);\n    }\n    if (config.configMethod) {\n      this.configMethod.add(config.configMethod[0], config.configMethod[1]);\n    }\n    this.handlers.add(config.handler, config.fallback, priority);\n    Object.assign(this.items, config.items);\n    Object.assign(this.tags, config.tags);\n    (0, Options_js_1.defaultOptions)(this.options, config.options);\n    Object.assign(this.nodes, config.nodes);\n  };\n  ParserConfiguration.prototype.addFilters = function (jax, config) {\n    var e_5, _a, e_6, _b;\n    try {\n      for (var _c = __values(config.preprocessors), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = __read(_d.value, 2),\n          pre = _e[0],\n          priority = _e[1];\n        jax.preFilters.add(pre, priority);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    try {\n      for (var _f = __values(config.postprocessors), _g = _f.next(); !_g.done; _g = _f.next()) {\n        var _h = __read(_g.value, 2),\n          post = _h[0],\n          priority = _h[1];\n        jax.postFilters.add(post, priority);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n  return ParserConfiguration;\n}();\nexports.ParserConfiguration = ParserConfiguration;","map":{"version":3,"names":["Options_js_1","require","MapHandler_js_1","FunctionList_js_1","PrioritizedList_js_1","Tags_js_1","Configuration","name","handler","fallback","items","tags","options","nodes","preprocessors","postprocessors","initMethod","configMethod","priority","parser","Object","assign","character","delimiter","macro","environment","makeProcessor","func","Array","isArray","_create","config","_this","PrioritizedList","DEFAULTPRIORITY","init","conf","map","pre","post","create","configuration","ConfigurationHandler","set","local","defineProperty","prototype","get","exports","maps","Map","keys","ParserConfiguration","packages","parsers","FunctionList","configurations","handlers","SubHandlers","_c","__values","slice","reverse","_d","next","done","pkg","value","addPackage","_e","_f","_g","item","append","execute","jax","_b","addFilters","getPackage","add","parseOptions","nodeFactory","setCreators","kind","itemFactory","setNodeClass","TagsFactory","addTags","defaultOptions","userOptions","indexOf","Error","concat","__read","preFilters","_h","postFilters"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/Configuration.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Configuration options for the TexParser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {HandlerConfig, FallbackConfig} from './MapHandler.js';\nimport {StackItemClass} from './StackItem.js';\nimport {TagsClass} from './Tags.js';\nimport {userOptions, defaultOptions, OptionList} from '../../util/Options.js';\nimport {SubHandlers} from './MapHandler.js';\nimport {FunctionList} from '../../util/FunctionList.js';\nimport {TeX} from '../tex.js';\nimport {PrioritizedList} from '../../util/PrioritizedList.js';\nimport {TagsFactory} from './Tags.js';\n\n\nexport type StackItemConfig = {[kind: string]: StackItemClass};\nexport type TagsConfig = {[kind: string]: TagsClass};\nexport type Processor<T> = [T, number];\nexport type ProtoProcessor<T> = Processor<T> | T;\nexport type ProcessorList = Processor<Function>[];\nexport type ConfigMethod = (c: ParserConfiguration, j: TeX<any, any, any>) => void;\nexport type InitMethod = (c: ParserConfiguration) => void;\n\n\n\nexport class Configuration {\n\n  /**\n   * Creates a function priority pair.\n   * @param {ProtoProcessor<T>} func The function or processor.\n   * @param {number} priority The default priority.\n   * @return {Processor} The processor pair.\n   * @template T\n   */\n  private static makeProcessor<T>(func: ProtoProcessor<T>, priority: number): Processor<T> {\n    return Array.isArray(func) ? func : [func, priority];\n  }\n\n  /**\n   * Creates a configuration for a package.\n   * @param {string} name The package name or empty string.\n   * @param {Object} config See `create` method.\n   * @return {Configuration} The newly generated configuration.\n   */\n  private static _create(name: string,\n                         config: {handler?: HandlerConfig,\n                                  fallback?: FallbackConfig,\n                                  items?: StackItemConfig,\n                                  tags?: TagsConfig,\n                                  options?: OptionList,\n                                  nodes?: {[key: string]: any},\n                                  preprocessors?: ProtoProcessor<Function>[],\n                                  postprocessors?: ProtoProcessor<Function>[],\n                                  init?: ProtoProcessor<InitMethod>,\n                                  config?: ProtoProcessor<ConfigMethod>,\n                                  priority?: number,\n                                  parser?: string,\n                                 } = {}): Configuration {\n    let priority = config.priority || PrioritizedList.DEFAULTPRIORITY;\n    let init = config.init ? this.makeProcessor(config.init, priority) : null;\n    let conf = config.config ? this.makeProcessor(config.config, priority) : null;\n    let preprocessors = (config.preprocessors || []).map(\n      pre => this.makeProcessor(pre, priority));\n    let postprocessors = (config.postprocessors || []).map(\n      post => this.makeProcessor(post, priority));\n    let parser = config.parser || 'tex';\n    return new Configuration(\n      name,\n      config.handler || {},\n      config.fallback || {},\n      config.items || {},\n      config.tags || {},\n      config.options || {},\n      config.nodes || {},\n      preprocessors, postprocessors, init, conf, priority,\n      parser\n    );\n  }\n\n  /**\n   * Creator pattern for creating a named package configuration. This will be\n   * administered in the configuration handler and can be retrieved again.\n   * @param {string} name The package name.\n   * @param {Object} config The configuration parameters:\n   * Configuration for the TexParser consist of the following:\n   *  * _handler_  configuration mapping handler types to lists of symbol mappings.\n   *  * _fallback_ configuration mapping handler types to fallback methods.\n   *  * _items_ for the StackItem factory.\n   *  * _tags_ mapping tagging configurations to tagging objects.\n   *  * _options_ parse options for the packages.\n   *  * _nodes_ for the Node factory.\n   *  * _preprocessors_ list of functions for preprocessing the LaTeX\n   *      string wrt. to given parse options. Can contain a priority.\n   *  * _postprocessors_ list of functions for postprocessing the MmlNode\n   *      wrt. to given parse options. Can contain a priority.\n   *  * _init_ init method and optionally its priority.\n   *  * _config_ config method and optionally its priority.\n   *  * _priority_ default priority of the configuration.\n   *  * _parser_ the name of the parser that this configuration targets.\n   * @return {Configuration} The newly generated configuration.\n   */\n  public static create(name: string,\n                       config: {handler?: HandlerConfig,\n                                fallback?: FallbackConfig,\n                                items?: StackItemConfig,\n                                tags?: TagsConfig,\n                                options?: OptionList,\n                                nodes?: {[key: string]: any},\n                                preprocessors?: ProtoProcessor<Function>[],\n                                postprocessors?: ProtoProcessor<Function>[],\n                                init?: ProtoProcessor<InitMethod>,\n                                config?: ProtoProcessor<ConfigMethod>,\n                                priority?: number,\n                                parser?: string,\n                               } = {}): Configuration {\n    let configuration = Configuration._create(name, config);\n    ConfigurationHandler.set(name, configuration);\n    return configuration;\n  }\n\n  /**\n   * Creates an unnamed, ephemeral package configuration. It will not added to\n   * the configuration handler.\n   * @param {Object} config See `create` method.\n   * @return {Configuration} The ephemeral package configuration.\n   */\n  public static local(config: {handler?: HandlerConfig,\n                              fallback?: FallbackConfig,\n                              items?: StackItemConfig,\n                              tags?: TagsConfig,\n                              options?: OptionList,\n                              nodes?: {[key: string]: any},\n                              preprocessors?: ProtoProcessor<Function>[],\n                              postprocessors?: ProtoProcessor<Function>[],\n                              init?: ProtoProcessor<InitMethod>,\n                              config?: ProtoProcessor<ConfigMethod>,\n                              priority?: number,\n                              parser?: string,\n                             } = {}): Configuration {\n    return Configuration._create('', config);\n  }\n\n\n  /**\n   * @constructor\n   */\n  private constructor(readonly name: string,\n                      readonly handler: HandlerConfig = {},\n                      readonly fallback: FallbackConfig = {},\n                      readonly items: StackItemConfig = {},\n                      readonly tags: TagsConfig = {},\n                      readonly options: OptionList = {},\n                      readonly nodes: {[key: string]: any} = {},\n                      readonly preprocessors: ProcessorList = [],\n                      readonly postprocessors: ProcessorList = [],\n                      readonly initMethod: Processor<InitMethod> = null,\n                      readonly configMethod: Processor<ConfigMethod> = null,\n                      public priority: number,\n                      readonly parser: string\n                     ) {\n    this.handler = Object.assign(\n      {character: [], delimiter: [], macro: [], environment: []}, handler);\n  }\n\n  /**\n   * The init method.\n   * @type {Function}\n   */\n  public get init(): InitMethod {\n    return this.initMethod ? this.initMethod[0] : null;\n  }\n\n  /**\n   * The config method to call once jax is ready.\n   * @type {FunctionList}\n   */\n  public get config(): ConfigMethod {\n    return this.configMethod ? this.configMethod[0] : null;\n  }\n\n}\n\n\nexport namespace ConfigurationHandler {\n\n  let maps: Map<string, Configuration> = new Map();\n\n  /**\n   * Adds a new configuration to the handler overwriting old ones.\n   *\n   * @param {string} name The name of the configuration.\n   * @param {Configuration} map The configuration mapping.\n   */\n  export let set = function(name: string, map: Configuration): void {\n    maps.set(name, map);\n  };\n\n\n  /**\n   * Looks up a configuration.\n   *\n   * @param {string} name The name of the configuration.\n   * @return {Configuration} The configuration with the given name or null.\n   */\n  export let get = function(name: string): Configuration {\n    return maps.get(name);\n  };\n\n  /**\n   * @return {string[]} All configurations in the handler.\n   */\n  export let keys = function(): IterableIterator<string> {\n    return maps.keys();\n  };\n\n}\n\n\n/**\n * Parser configuration combines the configurations of the currently selected\n * packages.\n * @constructor\n */\nexport class ParserConfiguration {\n\n  /**\n   * Priority list of init methods.\n   * @type {FunctionList}\n   */\n  protected initMethod: FunctionList = new FunctionList();\n\n  /**\n   * Priority list of init methods to call once jax is ready.\n   * @type {FunctionList}\n   */\n  protected configMethod: FunctionList = new FunctionList();\n\n  /**\n   * An ordered list of cofigurations.\n   * @type {PrioritizedList<Configuration>}\n   */\n  protected configurations: PrioritizedList<Configuration> = new PrioritizedList();\n\n  /**\n   * The list of parsers this configuration targets\n   */\n  protected parsers: string[] = [];\n\n  /**\n   * The subhandlers for this configuration.\n   * @type {SubHandlers}\n   */\n  public handlers: SubHandlers = new SubHandlers();\n\n  /**\n   * The collated stack items.\n   * @type {StackItemConfig}\n   */\n  public items: StackItemConfig = {};\n\n  /**\n   * The collated tag configurations.\n   * @type {TagsConfig}\n   */\n  public tags: TagsConfig = {};\n\n  /**\n   * The collated options.\n   * @type {OptionList}\n   */\n  public options: OptionList = {};\n\n  /**\n   * The collated node creators.\n   * @type {{[key: string]: any}}\n   */\n  public nodes: {[key: string]: any}  = {};\n\n  /**\n   * @constructor\n   * @param {(string|[string,number])[]} packages A list of packages with\n   *     optional priorities.\n   * @parm {string[]} parsers   The names of the parsers this package targets\n   */\n  constructor(packages: (string | [string, number])[], parsers: string[] = ['tex']) {\n    this.parsers = parsers;\n    for (const pkg of packages.slice().reverse()) {\n      this.addPackage(pkg);\n    }\n    for (let {item: config, priority: priority} of this.configurations) {\n      this.append(config, priority);\n    }\n  }\n\n  /**\n   * Init method for the configuration;\n   */\n  public init() {\n    this.initMethod.execute(this);\n  }\n\n  /**\n   * Init method for when the jax is ready\n   * @param {TeX} jax The TeX jax for this configuration\n   */\n  public config(jax: TeX<any, any, any>) {\n    this.configMethod.execute(this, jax);\n    for (const config of this.configurations) {\n      this.addFilters(jax, config.item);\n    }\n  }\n\n  /**\n   * Retrieves and adds configuration for a package with priority.\n   * @param {(string | [string, number]} pkg Package with priority.\n   */\n  public addPackage(pkg: (string | [string, number])) {\n    const name = typeof pkg === 'string' ? pkg : pkg[0];\n    const conf = this.getPackage(name);\n    conf && this.configurations.add(conf, typeof pkg === 'string' ? conf.priority : pkg[1]);\n  }\n\n  /**\n   * Adds a configuration after the input jax is created.  (Used by \\require.)\n   * Sets items, nodes and runs configuration method explicitly.\n   *\n   * @param {string} name            The name of the package to add\n   * @param {TeX} jax                The TeX jax where it is being registered\n   * @param {OptionList=} options    The options for the configuration.\n   */\n  public add(name: string, jax: TeX<any, any, any>, options: OptionList = {}) {\n    const config = this.getPackage(name);\n    this.append(config);\n    this.configurations.add(config, config.priority);\n    this.init();\n    const parser = jax.parseOptions;\n    parser.nodeFactory.setCreators(config.nodes);\n    for (const kind of Object.keys(config.items)) {\n      parser.itemFactory.setNodeClass(kind, config.items[kind]);\n    }\n    TagsFactory.addTags(config.tags);\n    defaultOptions(parser.options, config.options);\n    userOptions(parser.options, options);\n    this.addFilters(jax, config);\n    if (config.config) {\n      config.config(this, jax);\n    }\n  }\n\n /**\n  * Find a package and check that it is for the targeted parser\n  *\n  * @param {string} name       The name of the package to check\n  * @return {Configuration}    The configuration for the package\n  */\n  protected getPackage(name: string): Configuration {\n    const config = ConfigurationHandler.get(name);\n    if (config && this.parsers.indexOf(config.parser) < 0) {\n      throw Error(`Package ${name} doesn't target the proper parser`);\n    }\n    return config;\n  }\n\n  /**\n   * Appends a configuration to the overall configuration object.\n   * @param {Configuration} config A configuration.\n   * @param {number} priority The configurations optional priority.\n   */\n  public append(config: Configuration, priority?: number) {\n    priority = priority || config.priority;\n    if (config.initMethod) {\n      this.initMethod.add(config.initMethod[0], config.initMethod[1]);\n    }\n    if (config.configMethod) {\n        this.configMethod.add(config.configMethod[0], config.configMethod[1]);\n      }\n    this.handlers.add(config.handler, config.fallback, priority);\n    Object.assign(this.items, config.items);\n    Object.assign(this.tags, config.tags);\n    defaultOptions(this.options, config.options);\n    Object.assign(this.nodes, config.nodes);\n  }\n\n  /**\n   * Adds pre- and postprocessor as filters to the jax.\n   * @param {TeX<any} jax The TeX Jax.\n   * @param {Configuration} config The configuration whose processors are added.\n   */\n  private addFilters(jax: TeX<any, any, any>, config: Configuration) {\n    for (const [pre, priority] of config.preprocessors) {\n      jax.preFilters.add(pre, priority);\n    }\n    for (const [post, priority] of config.postprocessors) {\n      jax.postFilters.add(post, priority);\n    }\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}