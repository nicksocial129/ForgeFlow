{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.split = exports.isPercent = exports.unicodeString = exports.unicodeChars = exports.quotePattern = exports.sortLength = void 0;\nfunction sortLength(a, b) {\n  return a.length !== b.length ? b.length - a.length : a === b ? 0 : a < b ? -1 : 1;\n}\nexports.sortLength = sortLength;\nfunction quotePattern(text) {\n  return text.replace(/([\\^$(){}+*?\\-|\\[\\]\\:\\\\])/g, '\\\\$1');\n}\nexports.quotePattern = quotePattern;\nfunction unicodeChars(text) {\n  return Array.from(text).map(function (c) {\n    return c.codePointAt(0);\n  });\n}\nexports.unicodeChars = unicodeChars;\nfunction unicodeString(data) {\n  return String.fromCodePoint.apply(String, __spreadArray([], __read(data), false));\n}\nexports.unicodeString = unicodeString;\nfunction isPercent(x) {\n  return !!x.match(/%\\s*$/);\n}\nexports.isPercent = isPercent;\nfunction split(x) {\n  return x.trim().split(/\\s+/);\n}\nexports.split = split;","map":{"version":3,"names":["sortLength","a","b","length","exports","quotePattern","text","replace","unicodeChars","Array","from","map","c","codePointAt","unicodeString","data","String","fromCodePoint","apply","__spreadArray","__read","isPercent","x","match","split","trim"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/util/string.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements some string utility functions\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n\n/**\n * Sort strings by length\n *\n * @param {string} a  First string to be compared\n * @param {string} b  Second string to be compared\n * @return {number}  -1 id a < b, 0 of a === b, 1 if a > b\n */\nexport function sortLength(a: string, b: string): number {\n  return a.length !== b.length ? b.length - a.length : a === b ? 0 : a < b ? -1 : 1;\n}\n\n/**\n * Quote a string for use in regular expressions\n *\n * @param {string} text  The text whose regex characters are to be quoted\n * @return {string}  The quoted string\n */\nexport function quotePattern(text: string): string {\n  return text.replace(/([\\^$(){}+*?\\-|\\[\\]\\:\\\\])/g, '\\\\$1');\n}\n\n/**\n * Convert a UTF-8 string to an array of unicode code points\n *\n * @param {string} text  The string to be turned into unicode positions\n * @return {number[]}  Array of numbers representing the string's unicode character positions\n */\nexport function unicodeChars(text: string): number[] {\n  return Array.from(text).map((c) => c.codePointAt(0));\n}\n\n/**\n * Convert an array of unicode code points to a string\n *\n * @param {number[]} data   The array of unicode code points\n * @return {string}         The string consisting of the characters at those points\n */\nexport function unicodeString(data: number[]): string {\n  return String.fromCodePoint(...data);\n}\n\n/**\n * Test if a value is a percentage\n *\n * @param {string} x   The string to test\n * @return {boolean}   True if the string ends with a percent sign\n */\nexport function isPercent(x: string): boolean {\n  return !!x.match(/%\\s*$/);\n}\n\n/**\n * Split a space-separated string of values\n *\n * @param {string} x   The string to be split\n * @return {string[]}  The list of white-space-separated \"words\" in the string\n */\nexport function split(x: string): string[] {\n  return x.trim().split(/\\s+/);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAAgBA,UAAUA,CAACC,CAAS,EAAEC,CAAS;EAC7C,OAAOD,CAAC,CAACE,MAAM,KAAKD,CAAC,CAACC,MAAM,GAAGD,CAAC,CAACC,MAAM,GAAGF,CAAC,CAACE,MAAM,GAAGF,CAAC,KAAKC,CAAC,GAAG,CAAC,GAAGD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;AACnF;AAFAE,OAAA,CAAAJ,UAAA,GAAAA,UAAA;AAUA,SAAgBK,YAAYA,CAACC,IAAY;EACvC,OAAOA,IAAI,CAACC,OAAO,CAAC,4BAA4B,EAAE,MAAM,CAAC;AAC3D;AAFAH,OAAA,CAAAC,YAAA,GAAAA,YAAA;AAUA,SAAgBG,YAAYA,CAACF,IAAY;EACvC,OAAOG,KAAK,CAACC,IAAI,CAACJ,IAAI,CAAC,CAACK,GAAG,CAAC,UAACC,CAAC;IAAK,OAAAA,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;EAAhB,CAAgB,CAAC;AACtD;AAFAT,OAAA,CAAAI,YAAA,GAAAA,YAAA;AAUA,SAAgBM,aAAaA,CAACC,IAAc;EAC1C,OAAOC,MAAM,CAACC,aAAa,CAAAC,KAAA,CAApBF,MAAM,EAAAG,aAAA,KAAAC,MAAA,CAAkBL,IAAI;AACrC;AAFAX,OAAA,CAAAU,aAAA,GAAAA,aAAA;AAUA,SAAgBO,SAASA,CAACC,CAAS;EACjC,OAAO,CAAC,CAACA,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC;AAC3B;AAFAnB,OAAA,CAAAiB,SAAA,GAAAA,SAAA;AAUA,SAAgBG,KAAKA,CAACF,CAAS;EAC7B,OAAOA,CAAC,CAACG,IAAI,EAAE,CAACD,KAAK,CAAC,KAAK,CAAC;AAC9B;AAFApB,OAAA,CAAAoB,KAAA,GAAAA,KAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}