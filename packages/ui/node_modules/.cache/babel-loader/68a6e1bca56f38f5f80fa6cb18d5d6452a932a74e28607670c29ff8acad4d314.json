{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NEW_OPS = exports.AmsMethods = void 0;\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar ParseMethods_js_1 = __importDefault(require(\"../ParseMethods.js\"));\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar TexConstants_js_1 = require(\"../TexConstants.js\");\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar Symbol_js_1 = require(\"../Symbol.js\");\nvar BaseMethods_js_1 = __importDefault(require(\"../base/BaseMethods.js\"));\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nexports.AmsMethods = {};\nexports.AmsMethods.AmsEqnArray = function (parser, begin, numbered, taggable, align, spacing, style) {\n  var args = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  var array = BaseMethods_js_1.default.EqnArray(parser, begin, numbered, taggable, align, spacing, style);\n  return ParseUtil_js_1.default.setArrayAlign(array, args);\n};\nexports.AmsMethods.AlignAt = function (parser, begin, numbered, taggable) {\n  var name = begin.getName();\n  var n,\n    valign,\n    align = '',\n    spacing = [];\n  if (!taggable) {\n    valign = parser.GetBrackets('\\\\begin{' + name + '}');\n  }\n  n = parser.GetArgument('\\\\begin{' + name + '}');\n  if (n.match(/[^0-9]/)) {\n    throw new TexError_js_1.default('PositiveIntegerArg', 'Argument to %1 must me a positive integer', '\\\\begin{' + name + '}');\n  }\n  var count = parseInt(n, 10);\n  while (count > 0) {\n    align += 'rl';\n    spacing.push('0em 0em');\n    count--;\n  }\n  var spaceStr = spacing.join(' ');\n  if (taggable) {\n    return exports.AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);\n  }\n  var array = exports.AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);\n  return ParseUtil_js_1.default.setArrayAlign(array, valign);\n};\nexports.AmsMethods.Multline = function (parser, begin, numbered) {\n  parser.Push(begin);\n  ParseUtil_js_1.default.checkEqnEnv(parser);\n  var item = parser.itemFactory.create('multline', numbered, parser.stack);\n  item.arraydef = {\n    displaystyle: true,\n    rowspacing: '.5em',\n    columnspacing: '100%',\n    width: parser.options.ams['multlineWidth'],\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent'],\n    framespacing: parser.options.ams['multlineIndent'] + ' 0',\n    frame: '',\n    'data-width-includes-label': true\n  };\n  return item;\n};\nexports.AmsMethods.XalignAt = function (parser, begin, numbered, padded) {\n  var n = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  if (n.match(/[^0-9]/)) {\n    throw new TexError_js_1.default('PositiveIntegerArg', 'Argument to %1 must me a positive integer', '\\\\begin{' + begin.getName() + '}');\n  }\n  var align = padded ? 'crl' : 'rlc';\n  var width = padded ? 'fit auto auto' : 'auto auto fit';\n  var item = exports.AmsMethods.FlalignArray(parser, begin, numbered, padded, false, align, width, true);\n  item.setProperty('xalignat', 2 * parseInt(n));\n  return item;\n};\nexports.AmsMethods.FlalignArray = function (parser, begin, numbered, padded, center, align, width, zeroWidthLabel) {\n  if (zeroWidthLabel === void 0) {\n    zeroWidthLabel = false;\n  }\n  parser.Push(begin);\n  ParseUtil_js_1.default.checkEqnEnv(parser);\n  align = align.split('').join(' ').replace(/r/g, 'right').replace(/l/g, 'left').replace(/c/g, 'center');\n  var item = parser.itemFactory.create('flalign', begin.getName(), numbered, padded, center, parser.stack);\n  item.arraydef = {\n    width: '100%',\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: '0em',\n    columnwidth: width,\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: zeroWidthLabel ? '0' : parser.options['tagIndent'],\n    'data-width-includes-label': true\n  };\n  item.setProperty('zeroWidthLabel', zeroWidthLabel);\n  return item;\n};\nexports.NEW_OPS = 'ams-declare-ops';\nexports.AmsMethods.HandleDeclareOp = function (parser, name) {\n  var star = parser.GetStar() ? '*' : '';\n  var cs = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n  if (cs.charAt(0) === '\\\\') {\n    cs = cs.substr(1);\n  }\n  var op = parser.GetArgument(name);\n  parser.configuration.handlers.retrieve(exports.NEW_OPS).add(cs, new Symbol_js_1.Macro(cs, exports.AmsMethods.Macro, [\"\\\\operatorname\".concat(star, \"{\").concat(op, \"}\")]));\n};\nexports.AmsMethods.HandleOperatorName = function (parser, name) {\n  var star = parser.GetStar();\n  var op = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n  var mml = new TexParser_js_1.default(op, __assign(__assign({}, parser.stack.env), {\n    font: TexConstants_js_1.TexConstant.Variant.NORMAL,\n    multiLetterIdentifiers: /^[-*a-z]+/i,\n    operatorLetters: true\n  }), parser.configuration).mml();\n  if (!mml.isKind('mi')) {\n    mml = parser.create('node', 'TeXAtom', [mml]);\n  }\n  NodeUtil_js_1.default.setProperties(mml, {\n    movesupsub: star,\n    movablelimits: true,\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  });\n  if (!star) {\n    var c = parser.GetNext(),\n      i = parser.i;\n    if (c === '\\\\' && ++parser.i && parser.GetCS() !== 'limits') {\n      parser.i = i;\n    }\n  }\n  parser.Push(mml);\n};\nexports.AmsMethods.SideSet = function (parser, name) {\n  var _a = __read(splitSideSet(parser.ParseArg(name)), 2),\n    preScripts = _a[0],\n    preRest = _a[1];\n  var _b = __read(splitSideSet(parser.ParseArg(name)), 2),\n    postScripts = _b[0],\n    postRest = _b[1];\n  var base = parser.ParseArg(name);\n  var mml = base;\n  if (preScripts) {\n    if (preRest) {\n      preScripts.replaceChild(parser.create('node', 'mphantom', [parser.create('node', 'mpadded', [ParseUtil_js_1.default.copyNode(base, parser)], {\n        width: 0\n      })]), NodeUtil_js_1.default.getChildAt(preScripts, 0));\n    } else {\n      mml = parser.create('node', 'mmultiscripts', [base]);\n      if (postScripts) {\n        NodeUtil_js_1.default.appendChildren(mml, [NodeUtil_js_1.default.getChildAt(postScripts, 1) || parser.create('node', 'none'), NodeUtil_js_1.default.getChildAt(postScripts, 2) || parser.create('node', 'none')]);\n      }\n      NodeUtil_js_1.default.setProperty(mml, 'scriptalign', 'left');\n      NodeUtil_js_1.default.appendChildren(mml, [parser.create('node', 'mprescripts'), NodeUtil_js_1.default.getChildAt(preScripts, 1) || parser.create('node', 'none'), NodeUtil_js_1.default.getChildAt(preScripts, 2) || parser.create('node', 'none')]);\n    }\n  }\n  if (postScripts && mml === base) {\n    postScripts.replaceChild(base, NodeUtil_js_1.default.getChildAt(postScripts, 0));\n    mml = postScripts;\n  }\n  var mrow = parser.create('node', 'TeXAtom', [], {\n    texClass: MmlNode_js_1.TEXCLASS.OP,\n    movesupsub: true,\n    movablelimits: true\n  });\n  if (preRest) {\n    preScripts && mrow.appendChild(preScripts);\n    mrow.appendChild(preRest);\n  }\n  mrow.appendChild(mml);\n  postRest && mrow.appendChild(postRest);\n  parser.Push(mrow);\n};\nfunction splitSideSet(mml) {\n  if (!mml || mml.isInferred && mml.childNodes.length === 0) return [null, null];\n  if (mml.isKind('msubsup') && checkSideSetBase(mml)) return [mml, null];\n  var child = NodeUtil_js_1.default.getChildAt(mml, 0);\n  if (!(mml.isInferred && child && checkSideSetBase(child))) return [null, mml];\n  mml.childNodes.splice(0, 1);\n  return [child, mml];\n}\nfunction checkSideSetBase(mml) {\n  var base = mml.childNodes[0];\n  return base && base.isKind('mi') && base.getText() === '';\n}\nexports.AmsMethods.operatorLetter = function (parser, c) {\n  return parser.stack.env.operatorLetters ? ParseMethods_js_1.default.variable(parser, c) : false;\n};\nexports.AmsMethods.MultiIntegral = function (parser, name, integral) {\n  var next = parser.GetNext();\n  if (next === '\\\\') {\n    var i = parser.i;\n    next = parser.GetArgument(name);\n    parser.i = i;\n    if (next === '\\\\limits') {\n      if (name === '\\\\idotsint') {\n        integral = '\\\\!\\\\!\\\\mathop{\\\\,\\\\,' + integral + '}';\n      } else {\n        integral = '\\\\!\\\\!\\\\!\\\\mathop{\\\\,\\\\,\\\\,' + integral + '}';\n      }\n    }\n  }\n  parser.string = integral + ' ' + parser.string.slice(parser.i);\n  parser.i = 0;\n};\nexports.AmsMethods.xArrow = function (parser, name, chr, l, r) {\n  var def = {\n    width: '+' + ParseUtil_js_1.default.Em((l + r) / 18),\n    lspace: ParseUtil_js_1.default.Em(l / 18)\n  };\n  var bot = parser.GetBrackets(name);\n  var first = parser.ParseArg(name);\n  var dstrut = parser.create('node', 'mspace', [], {\n    depth: '.25em'\n  });\n  var arrow = parser.create('token', 'mo', {\n    stretchy: true,\n    texClass: MmlNode_js_1.TEXCLASS.REL\n  }, String.fromCodePoint(chr));\n  arrow = parser.create('node', 'mstyle', [arrow], {\n    scriptlevel: 0\n  });\n  var mml = parser.create('node', 'munderover', [arrow]);\n  var mpadded = parser.create('node', 'mpadded', [first, dstrut], def);\n  NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '-.2em');\n  NodeUtil_js_1.default.setAttribute(mpadded, 'height', '-.2em');\n  NodeUtil_js_1.default.setChild(mml, mml.over, mpadded);\n  if (bot) {\n    var bottom = new TexParser_js_1.default(bot, parser.stack.env, parser.configuration).mml();\n    var bstrut = parser.create('node', 'mspace', [], {\n      height: '.75em'\n    });\n    mpadded = parser.create('node', 'mpadded', [bottom, bstrut], def);\n    NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '.15em');\n    NodeUtil_js_1.default.setAttribute(mpadded, 'depth', '-.15em');\n    NodeUtil_js_1.default.setChild(mml, mml.under, mpadded);\n  }\n  NodeUtil_js_1.default.setProperty(mml, 'subsupOK', true);\n  parser.Push(mml);\n};\nexports.AmsMethods.HandleShove = function (parser, _name, shove) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'multline') {\n    throw new TexError_js_1.default('CommandOnlyAllowedInEnv', '%1 only allowed in %2 environment', parser.currentCS, 'multline');\n  }\n  if (top.Size()) {\n    throw new TexError_js_1.default('CommandAtTheBeginingOfLine', '%1 must come at the beginning of the line', parser.currentCS);\n  }\n  top.setProperty('shove', shove);\n};\nexports.AmsMethods.CFrac = function (parser, name) {\n  var lr = ParseUtil_js_1.default.trimSpaces(parser.GetBrackets(name, ''));\n  var num = parser.GetArgument(name);\n  var den = parser.GetArgument(name);\n  var lrMap = {\n    l: TexConstants_js_1.TexConstant.Align.LEFT,\n    r: TexConstants_js_1.TexConstant.Align.RIGHT,\n    '': ''\n  };\n  var numNode = new TexParser_js_1.default('\\\\strut\\\\textstyle{' + num + '}', parser.stack.env, parser.configuration).mml();\n  var denNode = new TexParser_js_1.default('\\\\strut\\\\textstyle{' + den + '}', parser.stack.env, parser.configuration).mml();\n  var frac = parser.create('node', 'mfrac', [numNode, denNode]);\n  lr = lrMap[lr];\n  if (lr == null) {\n    throw new TexError_js_1.default('IllegalAlign', 'Illegal alignment specified in %1', parser.currentCS);\n  }\n  if (lr) {\n    NodeUtil_js_1.default.setProperties(frac, {\n      numalign: lr,\n      denomalign: lr\n    });\n  }\n  parser.Push(frac);\n};\nexports.AmsMethods.Genfrac = function (parser, name, left, right, thick, style) {\n  if (left == null) {\n    left = parser.GetDelimiterArg(name);\n  }\n  if (right == null) {\n    right = parser.GetDelimiterArg(name);\n  }\n  if (thick == null) {\n    thick = parser.GetArgument(name);\n  }\n  if (style == null) {\n    style = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n  }\n  var num = parser.ParseArg(name);\n  var den = parser.ParseArg(name);\n  var frac = parser.create('node', 'mfrac', [num, den]);\n  if (thick !== '') {\n    NodeUtil_js_1.default.setAttribute(frac, 'linethickness', thick);\n  }\n  if (left || right) {\n    NodeUtil_js_1.default.setProperty(frac, 'withDelims', true);\n    frac = ParseUtil_js_1.default.fixedFence(parser.configuration, left, frac, right);\n  }\n  if (style !== '') {\n    var styleDigit = parseInt(style, 10);\n    var styleAlpha = ['D', 'T', 'S', 'SS'][styleDigit];\n    if (styleAlpha == null) {\n      throw new TexError_js_1.default('BadMathStyleFor', 'Bad math style for %1', parser.currentCS);\n    }\n    frac = parser.create('node', 'mstyle', [frac]);\n    if (styleAlpha === 'D') {\n      NodeUtil_js_1.default.setProperties(frac, {\n        displaystyle: true,\n        scriptlevel: 0\n      });\n    } else {\n      NodeUtil_js_1.default.setProperties(frac, {\n        displaystyle: false,\n        scriptlevel: styleDigit - 1\n      });\n    }\n  }\n  parser.Push(frac);\n};\nexports.AmsMethods.HandleTag = function (parser, name) {\n  if (!parser.tags.currentTag.taggable && parser.tags.env) {\n    throw new TexError_js_1.default('CommandNotAllowedInEnv', '%1 not allowed in %2 environment', parser.currentCS, parser.tags.env);\n  }\n  if (parser.tags.currentTag.tag) {\n    throw new TexError_js_1.default('MultipleCommand', 'Multiple %1', parser.currentCS);\n  }\n  var star = parser.GetStar();\n  var tagId = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n  parser.tags.tag(tagId, star);\n};\nexports.AmsMethods.HandleNoTag = BaseMethods_js_1.default.HandleNoTag;\nexports.AmsMethods.HandleRef = BaseMethods_js_1.default.HandleRef;\nexports.AmsMethods.Macro = BaseMethods_js_1.default.Macro;\nexports.AmsMethods.Accent = BaseMethods_js_1.default.Accent;\nexports.AmsMethods.Tilde = BaseMethods_js_1.default.Tilde;\nexports.AmsMethods.Array = BaseMethods_js_1.default.Array;\nexports.AmsMethods.Spacer = BaseMethods_js_1.default.Spacer;\nexports.AmsMethods.NamedOp = BaseMethods_js_1.default.NamedOp;\nexports.AmsMethods.EqnArray = BaseMethods_js_1.default.EqnArray;\nexports.AmsMethods.Equation = BaseMethods_js_1.default.Equation;","map":{"version":3,"names":["ParseUtil_js_1","__importDefault","require","ParseMethods_js_1","NodeUtil_js_1","TexConstants_js_1","TexParser_js_1","TexError_js_1","Symbol_js_1","BaseMethods_js_1","MmlNode_js_1","exports","AmsMethods","AmsEqnArray","parser","begin","numbered","taggable","align","spacing","style","args","GetBrackets","getName","array","default","EqnArray","setArrayAlign","AlignAt","name","n","valign","GetArgument","match","count","parseInt","push","spaceStr","join","Multline","Push","checkEqnEnv","item","itemFactory","create","stack","arraydef","displaystyle","rowspacing","columnspacing","width","options","ams","side","minlabelspacing","framespacing","frame","XalignAt","padded","FlalignArray","setProperty","center","zeroWidthLabel","split","replace","columnalign","columnwidth","NEW_OPS","HandleDeclareOp","star","GetStar","cs","trimSpaces","charAt","substr","op","configuration","handlers","retrieve","add","Macro","concat","HandleOperatorName","mml","__assign","env","font","TexConstant","Variant","NORMAL","multiLetterIdentifiers","operatorLetters","isKind","setProperties","movesupsub","movablelimits","texClass","TEXCLASS","OP","c","GetNext","i","GetCS","SideSet","_a","__read","splitSideSet","ParseArg","preScripts","preRest","_b","postScripts","postRest","base","replaceChild","copyNode","getChildAt","appendChildren","mrow","appendChild","isInferred","childNodes","length","checkSideSetBase","child","splice","getText","operatorLetter","variable","MultiIntegral","integral","next","string","slice","xArrow","chr","l","r","def","Em","lspace","bot","first","dstrut","depth","arrow","stretchy","REL","String","fromCodePoint","scriptlevel","mpadded","setAttribute","setChild","over","bottom","bstrut","height","under","HandleShove","_name","shove","top","Top","kind","currentCS","Size","CFrac","lr","num","den","lrMap","Align","LEFT","RIGHT","numNode","denNode","frac","numalign","denomalign","Genfrac","left","right","thick","GetDelimiterArg","fixedFence","styleDigit","styleAlpha","HandleTag","tags","currentTag","tag","tagId","HandleNoTag","HandleRef","Accent","Tilde","Array","Spacer","NamedOp","Equation"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/ams/AmsMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The AMS Parse methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {StackItem} from '../StackItem.js';\nimport {ParseMethod} from '../Types.js';\nimport ParseUtil from '../ParseUtil.js';\nimport ParseMethods from '../ParseMethods.js';\nimport NodeUtil from '../NodeUtil.js';\nimport {TexConstant} from '../TexConstants.js';\nimport TexParser from '../TexParser.js';\nimport TexError from '../TexError.js';\nimport {Macro} from '../Symbol.js';\nimport {CommandMap} from '../SymbolMap.js';\nimport {ArrayItem} from '../base/BaseItems.js';\nimport {FlalignItem} from './AmsItems.js';\nimport BaseMethods from '../base/BaseMethods.js';\nimport {TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMunderover} from '../../../core/MmlTree/MmlNodes/munderover.js';\nimport {MmlNode, AbstractMmlTokenNode} from '../../../core/MmlTree/MmlNode.js';\n\n\n// Namespace\nexport const AmsMethods: Record<string, ParseMethod> = {};\n\n\n/**\n * Handle AMS array environments.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered Environment numbered.\n * @param {boolean} taggable Environment taggable (e.g., align* is taggable,\n *     split is not).\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} style Display style indicator.\n */\nAmsMethods.AmsEqnArray = function(parser: TexParser, begin: StackItem,\n                                      numbered: boolean, taggable: boolean,\n                                      align: string, spacing: string,\n                                      style: string) {\n  // @test Aligned, Gathered\n  const args = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  const array = BaseMethods.EqnArray(parser, begin, numbered, taggable, align, spacing, style);\n  return ParseUtil.setArrayAlign(array as ArrayItem, args);\n};\n\n\n/**\n * Handle AMS  alignat environments.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered Environment numbered.\n * @param {boolean} taggable Environment taggable (e.g., align* is taggable,\n *     split is not).\n */\nAmsMethods.AlignAt = function(parser: TexParser, begin: StackItem,\n                              numbered: boolean, taggable: boolean) {\n  const name = begin.getName();\n  let n, valign, align = '', spacing = [];\n  if (!taggable) {\n    // @test Alignedat\n    valign = parser.GetBrackets('\\\\begin{' + name + '}');\n  }\n  n = parser.GetArgument('\\\\begin{' + name + '}');\n  if (n.match(/[^0-9]/)) {\n    // @test PositiveIntegerArg\n    throw new TexError('PositiveIntegerArg',\n                        'Argument to %1 must me a positive integer',\n                        '\\\\begin{' + name + '}');\n  }\n  let count = parseInt(n, 10);\n  while (count > 0) {\n    align  += 'rl';\n    spacing.push('0em 0em');\n    count--;\n  }\n  let spaceStr = spacing.join(' ');\n  if (taggable) {\n    // @test Alignat, Alignat Star\n    return AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);\n  }\n  // @test Alignedat\n  let array = AmsMethods.EqnArray(parser, begin, numbered, taggable, align, spaceStr);\n  return ParseUtil.setArrayAlign(array as ArrayItem, valign);\n};\n\n\n/**\n * Implements multline environment (mostly handled through STACKITEM below)\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered Environment numbered.\n */\nAmsMethods.Multline = function (parser: TexParser, begin: StackItem, numbered: boolean) {\n  // @test Shove*, Multline\n  parser.Push(begin);\n  ParseUtil.checkEqnEnv(parser);\n  const item = parser.itemFactory.create('multline', numbered, parser.stack) as ArrayItem;\n  item.arraydef = {\n    displaystyle: true,\n    rowspacing: '.5em',\n    columnspacing: '100%',\n    width: parser.options.ams['multlineWidth'],\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent'],\n    framespacing: parser.options.ams['multlineIndent'] + ' 0',\n    frame: '',   // Use frame spacing with no actual frame\n    'data-width-includes-label': true // take label space out of 100% width\n  };\n  return item;\n};\n\n\n/**\n * Generate an align at environment.\n * @param {TexParser} parser The current TeX parser.\n * @param {StackItem} begin The begin stackitem.\n * @param {boolean} numbered Is this a numbered array.\n * @param {boolean} padded Is it padded.\n */\nAmsMethods.XalignAt = function(parser: TexParser, begin: StackItem,\n                                  numbered: boolean, padded: boolean) {\n  let n = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  if (n.match(/[^0-9]/)) {\n    throw new TexError('PositiveIntegerArg',\n                       'Argument to %1 must me a positive integer',\n                       '\\\\begin{' + begin.getName() + '}');\n  }\n  const align = (padded ? 'crl' : 'rlc');\n  const width = (padded ? 'fit auto auto' : 'auto auto fit');\n  const item = AmsMethods.FlalignArray(parser, begin, numbered, padded, false, align, width, true) as FlalignItem;\n  item.setProperty('xalignat', 2 * parseInt(n));\n  return item;\n};\n\n\n/**\n * Generate an flalign environment.\n * @param {TexParser} parser The current TeX parser.\n * @param {StackItem} begin The begin stackitem.\n * @param {boolean} numbered Is this a numbered array.\n * @param {boolean} padded Is it padded.\n * @param {boolean} center Is it centered.\n * @param {string} align The horizontal alignment for columns\n * @param {string} width The column widths of the table\n * @param {boolean} zeroWidthLabel True if the label should be in llap/rlap\n */\nAmsMethods.FlalignArray = function(parser: TexParser, begin: StackItem, numbered: boolean,\n                                  padded: boolean, center: boolean, align: string,\n                                  width: string, zeroWidthLabel: boolean = false) {\n  parser.Push(begin);\n  ParseUtil.checkEqnEnv(parser);\n  align = align\n    .split('')\n    .join(' ')\n    .replace(/r/g, 'right')\n    .replace(/l/g, 'left')\n    .replace(/c/g, 'center');\n  const item = parser.itemFactory.create(\n    'flalign', begin.getName(), numbered, padded, center, parser.stack) as FlalignItem;\n  item.arraydef = {\n    width: '100%',\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: '0em',\n    columnwidth: width,\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: (zeroWidthLabel ? '0' : parser.options['tagIndent']),\n    'data-width-includes-label': true,\n  };\n  item.setProperty('zeroWidthLabel', zeroWidthLabel);\n  return item;\n};\n\n\nexport const NEW_OPS = 'ams-declare-ops';\n\n/**\n * Handle DeclareMathOperator.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsMethods.HandleDeclareOp =  function (parser: TexParser, name: string) {\n  let star = (parser.GetStar() ? '*' : '');\n  let cs = ParseUtil.trimSpaces(parser.GetArgument(name));\n  if (cs.charAt(0) === '\\\\') {\n    cs = cs.substr(1);\n  }\n  let op = parser.GetArgument(name);\n  (parser.configuration.handlers.retrieve(NEW_OPS) as CommandMap).\n    add(cs, new Macro(cs, AmsMethods.Macro, [`\\\\operatorname${star}{${op}}`]));\n};\n\n\n/**\n * Handle operatorname.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsMethods.HandleOperatorName = function(parser: TexParser, name: string) {\n  // @test Operatorname\n  const star = parser.GetStar();\n  //\n  //  Parse the argument using operator letters and grouping multiple letters.\n  //\n  let op = ParseUtil.trimSpaces(parser.GetArgument(name));\n  let mml = new TexParser(op, {\n    ...parser.stack.env,\n    font: TexConstant.Variant.NORMAL,\n    multiLetterIdentifiers: /^[-*a-z]+/i as any,\n    operatorLetters: true\n  }, parser.configuration).mml();\n  //\n  //  If we get something other than a single mi, wrap in a TeXAtom.\n  //\n  if (!mml.isKind('mi')) {\n    mml = parser.create('node', 'TeXAtom', [mml]);\n  }\n  //\n  //  Mark the limit properties and the TeX class.\n  //\n  NodeUtil.setProperties(mml, {movesupsub: star, movablelimits: true, texClass: TEXCLASS.OP});\n  //\n  //  Skip a following \\limits macro if not a starred operator\n  //\n  if (!star) {\n    const c = parser.GetNext(), i = parser.i;\n    if (c === '\\\\' && ++parser.i && parser.GetCS() !== 'limits') {\n      parser.i = i;\n    }\n  }\n  //\n  parser.Push(mml);\n};\n\n/**\n * Handle sideset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsMethods.SideSet = function (parser: TexParser, name: string) {\n  //\n  //  Get the pre- and post-scripts, and any extra material from the arguments\n  //\n  const [preScripts, preRest] = splitSideSet(parser.ParseArg(name));\n  const [postScripts, postRest] = splitSideSet(parser.ParseArg(name));\n  const base = parser.ParseArg(name);\n  let mml = base;\n  //\n  //  If there are pre-scripts...\n  //\n  if (preScripts) {\n    //\n    //  If there is other material...\n    //\n    if (preRest) {\n      //\n      //  Replace the empty base of the prescripts with a phantom element of the\n      //    original base, with width 0 (but still of the correct height and depth).\n      //    so the scripts will be at the right heights.\n      //\n      preScripts.replaceChild(\n        parser.create('node', 'mphantom', [\n          parser.create('node', 'mpadded', [ParseUtil.copyNode(base, parser)], {width: 0})\n        ]),\n        NodeUtil.getChildAt(preScripts, 0)\n      );\n    } else {\n      //\n      //  If there is no extra meterial, make a mmultiscripts element\n      //\n      mml = parser.create('node', 'mmultiscripts', [base]);\n      //\n      //  Add any postscripts\n      //\n      if (postScripts) {\n        NodeUtil.appendChildren(mml, [\n          NodeUtil.getChildAt(postScripts, 1) || parser.create('node', 'none'),\n          NodeUtil.getChildAt(postScripts, 2) || parser.create('node', 'none')\n        ]);\n      }\n      //\n      //  Add the prescripts (left aligned)\n      //\n      NodeUtil.setProperty(mml, 'scriptalign', 'left');\n      NodeUtil.appendChildren(mml, [\n        parser.create('node', 'mprescripts'),\n        NodeUtil.getChildAt(preScripts, 1) || parser.create('node', 'none'),\n        NodeUtil.getChildAt(preScripts, 2) || parser.create('node', 'none')\n      ]);\n    }\n  }\n  //\n  //  If there are postscripts and we didn't make a mmultiscript element above...\n  //\n  if (postScripts && mml === base) {\n    //\n    //  Replace the emtpy base with actual base, and use that as the mml\n    //\n    postScripts.replaceChild(base, NodeUtil.getChildAt(postScripts, 0));\n    mml = postScripts;\n  }\n  //\n  //  Put the needed pieces into a TeXAtom of class OP.\n  //  Note that the postScripts are in the mml element,\n  //    either as part of the mmultiscripts node, or the\n  //    msubsup with the base inserted into it.\n  //\n  const mrow = parser.create('node', 'TeXAtom', [], {texClass: TEXCLASS.OP, movesupsub: true, movablelimits: true});\n  if (preRest) {\n    preScripts && mrow.appendChild(preScripts);\n    mrow.appendChild(preRest);\n  }\n  mrow.appendChild(mml);\n  postRest && mrow.appendChild(postRest);\n  parser.Push(mrow);\n};\n\n/**\n * Utility for breaking the \\sideset scripts from any other material.\n * @param {MmlNode} mml The node to check.\n * @return {[MmlNode, MmlNode]} The msubsup with the scripts together with any extra nodes.\n */\nfunction splitSideSet(mml: MmlNode): [MmlNode, MmlNode] {\n    if (!mml || (mml.isInferred && mml.childNodes.length === 0)) return [null, null];\n    if (mml.isKind('msubsup') && checkSideSetBase(mml)) return [mml, null];\n    const child = NodeUtil.getChildAt(mml, 0);\n    if (!(mml.isInferred && child && checkSideSetBase(child))) return [null, mml];\n    mml.childNodes.splice(0, 1); // remove first child\n    return [child, mml];\n}\n\n/**\n * Utility for checking if a \\sideset argument has scripts with an empty base.\n * @param {MmlNode} mml The node to check.\n * @return {boolean} True if the base is not and empty mi element.\n */\nfunction checkSideSetBase(mml: MmlNode): boolean {\n  const base = mml.childNodes[0];\n  return base && base.isKind('mi') && (base as AbstractMmlTokenNode).getText() === '';\n}\n\n\n/**\n * Handle extra letters in \\operatorname (- and *), default to normal otherwise.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The letter being checked\n */\nAmsMethods.operatorLetter = function (parser: TexParser, c: string) {\n  return parser.stack.env.operatorLetters ? ParseMethods.variable(parser, c) : false;\n};\n\n\n/**\n * Handle multi integral signs.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} integral The actual integral sign.\n */\nAmsMethods.MultiIntegral = function(parser: TexParser, name: string,\n                                    integral: string) {\n  let next = parser.GetNext();\n  if (next === '\\\\') {\n    // @test MultiInt with Command\n    let i = parser.i;\n    next = parser.GetArgument(name);\n    parser.i = i;\n    if (next === '\\\\limits') {\n      if (name === '\\\\idotsint') {\n       // @test MultiInt with Limits\n        integral = '\\\\!\\\\!\\\\mathop{\\\\,\\\\,' + integral + '}';\n      }\n      else {\n        // Question: This is not used anymore?\n        integral = '\\\\!\\\\!\\\\!\\\\mathop{\\\\,\\\\,\\\\,' + integral + '}';\n      }\n    }\n  }\n  // @test MultiInt, MultiInt in Context\n  parser.string = integral + ' ' + parser.string.slice(parser.i);\n  parser.i = 0;\n};\n\n\n/**\n *  Handle stretchable arrows.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} chr The arrow character in hex code.\n * @param {number} l Left width.\n * @param {number} r Right width.\n */\nAmsMethods.xArrow = function(parser: TexParser, name: string,\n                             chr: number, l: number, r: number) {\n  let def = {width: '+' + ParseUtil.Em((l + r) / 18), lspace: ParseUtil.Em(l / 18)};\n  let bot = parser.GetBrackets(name);\n  let first = parser.ParseArg(name);\n  let dstrut = parser.create('node', 'mspace', [], {depth: '.25em'});\n  let arrow = parser.create('token',\n    'mo', {stretchy: true, texClass: TEXCLASS.REL}, String.fromCodePoint(chr));\n  arrow = parser.create('node', 'mstyle', [arrow], {scriptlevel: 0});\n  let mml = parser.create('node', 'munderover', [arrow]) as MmlMunderover;\n  let mpadded = parser.create('node', 'mpadded', [first, dstrut], def);\n  NodeUtil.setAttribute(mpadded, 'voffset', '-.2em');\n  NodeUtil.setAttribute(mpadded, 'height', '-.2em');\n  NodeUtil.setChild(mml, mml.over, mpadded);\n  if (bot) {\n    // @test Above Below Left Arrow, Above Below Right Arrow\n    let bottom = new TexParser(bot, parser.stack.env, parser.configuration).mml();\n    let bstrut = parser.create('node', 'mspace', [], {height: '.75em'});\n    mpadded = parser.create('node', 'mpadded', [bottom, bstrut], def);\n    NodeUtil.setAttribute(mpadded, 'voffset', '.15em');\n    NodeUtil.setAttribute(mpadded, 'depth', '-.15em');\n    NodeUtil.setChild(mml, mml.under, mpadded);\n  }\n  // @test Above Left Arrow, Above Right Arrow, Above Left Arrow in Context,\n  //       Above Right Arrow in Context\n  NodeUtil.setProperty(mml, 'subsupOK', true);\n  parser.Push(mml);\n};\n\n\n/**\n * Record presence of \\shoveleft and \\shoveright\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} shove The shove value.\n */\nAmsMethods.HandleShove = function(parser: TexParser, _name: string,\n                                  shove: string) {\n  let top = parser.stack.Top();\n  // @test Shove (Left|Right) (Top|Middle|Bottom)\n  if (top.kind !== 'multline') {\n    // @test Shove Error Environment\n    throw new TexError('CommandOnlyAllowedInEnv',\n                        '%1 only allowed in %2 environment',\n                        parser.currentCS, 'multline');\n  }\n  if (top.Size()) {\n    // @test Shove Error (Top|Middle|Bottom)\n    throw new TexError('CommandAtTheBeginingOfLine',\n                        '%1 must come at the beginning of the line', parser.currentCS);\n  }\n  top.setProperty('shove', shove);\n};\n\n\n/**\n * Handle \\cfrac\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsMethods.CFrac = function(parser: TexParser, name: string) {\n  let lr  = ParseUtil.trimSpaces(parser.GetBrackets(name, ''));\n  let num = parser.GetArgument(name);\n  let den = parser.GetArgument(name);\n  let lrMap: {[key: string]: string} = {\n    l: TexConstant.Align.LEFT, r: TexConstant.Align.RIGHT, '': ''};\n  let numNode = new TexParser('\\\\strut\\\\textstyle{' + num + '}',\n                              parser.stack.env, parser.configuration).mml();\n  let denNode = new TexParser('\\\\strut\\\\textstyle{' + den + '}',\n                              parser.stack.env, parser.configuration).mml();\n  let frac = parser.create('node', 'mfrac', [numNode, denNode]);\n  lr = lrMap[lr];\n  if (lr == null) {\n    // @test Center Fraction Error\n    throw new TexError('IllegalAlign', 'Illegal alignment specified in %1', parser.currentCS);\n  }\n  if (lr) {\n    // @test Right Fraction, Left Fraction\n    NodeUtil.setProperties(frac, {numalign: lr, denomalign: lr});\n  }\n  // @test Center Fraction\n  parser.Push(frac);\n};\n\n\n/**\n * Implement AMS generalized fraction.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} left Left delimiter.\n * @param {string} right Right delimiter.\n * @param {string} thick Line thickness.\n * @param {string} style Math style.\n */\nAmsMethods.Genfrac = function(parser: TexParser, name: string, left: string,\n                              right: string, thick: string, style: string) {\n  if (left  == null) { // @test Genfrac\n    left = parser.GetDelimiterArg(name);\n  }\n  if (right == null) { // @test Genfrac\n    right = parser.GetDelimiterArg(name);\n  }\n  if (thick == null) { // @test Genfrac\n    thick = parser.GetArgument(name);\n  }\n  if (style == null) { // @test Genfrac\n    style = ParseUtil.trimSpaces(parser.GetArgument(name));\n  }\n  let num = parser.ParseArg(name);\n  let den = parser.ParseArg(name);\n  let frac = parser.create('node', 'mfrac', [num, den]);\n  if (thick !== '') {\n    // @test Normal Binomial, Text Binomial, Display Binomial\n    NodeUtil.setAttribute(frac, 'linethickness', thick);\n  }\n  if (left || right) {\n    // @test Normal Binomial, Text Binomial, Display Binomial\n    NodeUtil.setProperty(frac, 'withDelims', true);\n    frac = ParseUtil.fixedFence(parser.configuration, left, frac, right);\n  }\n  if (style !== '') {\n    let styleDigit = parseInt(style, 10);\n    let styleAlpha = ['D', 'T', 'S', 'SS'][styleDigit];\n    if (styleAlpha == null) {\n      // @test Genfrac Error\n      throw new TexError('BadMathStyleFor', 'Bad math style for %1', parser.currentCS);\n    }\n    frac = parser.create('node', 'mstyle', [frac]);\n    if (styleAlpha === 'D') {\n      // @test Display Fraction, Display Sub Fraction, Display Binomial,\n      //       Display Sub Binomial\n      NodeUtil.setProperties(frac, {displaystyle: true, scriptlevel: 0});\n    }\n    else {\n      // @test Text Fraction, Text Sub Fraction, Text Binomial,\n      //       Text Sub Binomial\n      NodeUtil.setProperties(frac, {displaystyle: false,\n                                      scriptlevel: styleDigit - 1});\n    }\n  }\n  // @test Text Fraction, Normal Sub Binomial, Normal Binomial\n  parser.Push(frac);\n};\n\n\n\n/**\n * Add the tag to the environment (to be added to the table row later).\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsMethods.HandleTag = function(parser: TexParser, name: string) {\n  if (!parser.tags.currentTag.taggable && parser.tags.env) {\n    // @test Illegal Tag Error\n    throw new TexError('CommandNotAllowedInEnv',\n                        '%1 not allowed in %2 environment',\n                        parser.currentCS, parser.tags.env);\n  }\n  if (parser.tags.currentTag.tag) {\n    // @test Double Tag Error\n    throw new TexError('MultipleCommand', 'Multiple %1', parser.currentCS);\n  }\n  let star = parser.GetStar();\n  let tagId = ParseUtil.trimSpaces(parser.GetArgument(name));\n  parser.tags.tag(tagId, star);\n};\n\n\nAmsMethods.HandleNoTag = BaseMethods.HandleNoTag;\n\nAmsMethods.HandleRef = BaseMethods.HandleRef;\n\nAmsMethods.Macro = BaseMethods.Macro;\n\nAmsMethods.Accent = BaseMethods.Accent;\n\nAmsMethods.Tilde = BaseMethods.Tilde;\n\nAmsMethods.Array = BaseMethods.Array;\n\nAmsMethods.Spacer = BaseMethods.Spacer;\n\nAmsMethods.NamedOp = BaseMethods.NamedOp;\n\nAmsMethods.EqnArray = BaseMethods.EqnArray;\n\nAmsMethods.Equation = BaseMethods.Equation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}