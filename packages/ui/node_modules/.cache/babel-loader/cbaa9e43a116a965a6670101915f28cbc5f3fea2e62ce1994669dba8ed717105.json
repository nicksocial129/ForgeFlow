{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar BussproofsUtil = __importStar(require(\"./BussproofsUtil.js\"));\nvar BussproofsMethods = {};\nBussproofsMethods.Prooftree = function (parser, begin) {\n  parser.Push(begin);\n  var newItem = parser.itemFactory.create('proofTree').setProperties({\n    name: begin.getName(),\n    line: 'solid',\n    currentLine: 'solid',\n    rootAtTop: false\n  });\n  return newItem;\n};\nBussproofsMethods.Axiom = function (parser, name) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  var content = paddedContent(parser, parser.GetArgument(name));\n  BussproofsUtil.setProperty(content, 'axiom', true);\n  top.Push(content);\n};\nvar paddedContent = function (parser, content) {\n  var nodes = ParseUtil_js_1.default.internalMath(parser, ParseUtil_js_1.default.trimSpaces(content), 0);\n  if (!nodes[0].childNodes[0].childNodes.length) {\n    return parser.create('node', 'mrow', []);\n  }\n  var lpad = parser.create('node', 'mspace', [], {\n    width: '.5ex'\n  });\n  var rpad = parser.create('node', 'mspace', [], {\n    width: '.5ex'\n  });\n  return parser.create('node', 'mrow', __spreadArray(__spreadArray([lpad], __read(nodes), false), [rpad], false));\n};\nBussproofsMethods.Inference = function (parser, name, n) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  if (top.Size() < n) {\n    throw new TexError_js_1.default('BadProofTree', 'Proof tree badly specified.');\n  }\n  var rootAtTop = top.getProperty('rootAtTop');\n  var childCount = n === 1 && !top.Peek()[0].childNodes.length ? 0 : n;\n  var children = [];\n  do {\n    if (children.length) {\n      children.unshift(parser.create('node', 'mtd', [], {}));\n    }\n    children.unshift(parser.create('node', 'mtd', [top.Pop()], {\n      'rowalign': rootAtTop ? 'top' : 'bottom'\n    }));\n    n--;\n  } while (n > 0);\n  var row = parser.create('node', 'mtr', children, {});\n  var table = parser.create('node', 'mtable', [row], {\n    framespacing: '0 0'\n  });\n  var conclusion = paddedContent(parser, parser.GetArgument(name));\n  var style = top.getProperty('currentLine');\n  if (style !== top.getProperty('line')) {\n    top.setProperty('currentLine', top.getProperty('line'));\n  }\n  var rule = createRule(parser, table, [conclusion], top.getProperty('left'), top.getProperty('right'), style, rootAtTop);\n  top.setProperty('left', null);\n  top.setProperty('right', null);\n  BussproofsUtil.setProperty(rule, 'inference', childCount);\n  parser.configuration.addNode('inference', rule);\n  top.Push(rule);\n};\nfunction createRule(parser, premise, conclusions, left, right, style, rootAtTop) {\n  var upper = parser.create('node', 'mtr', [parser.create('node', 'mtd', [premise], {})], {});\n  var lower = parser.create('node', 'mtr', [parser.create('node', 'mtd', conclusions, {})], {});\n  var rule = parser.create('node', 'mtable', rootAtTop ? [lower, upper] : [upper, lower], {\n    align: 'top 2',\n    rowlines: style,\n    framespacing: '0 0'\n  });\n  BussproofsUtil.setProperty(rule, 'inferenceRule', rootAtTop ? 'up' : 'down');\n  var leftLabel, rightLabel;\n  if (left) {\n    leftLabel = parser.create('node', 'mpadded', [left], {\n      height: '+.5em',\n      width: '+.5em',\n      voffset: '-.15em'\n    });\n    BussproofsUtil.setProperty(leftLabel, 'prooflabel', 'left');\n  }\n  if (right) {\n    rightLabel = parser.create('node', 'mpadded', [right], {\n      height: '+.5em',\n      width: '+.5em',\n      voffset: '-.15em'\n    });\n    BussproofsUtil.setProperty(rightLabel, 'prooflabel', 'right');\n  }\n  var children, label;\n  if (left && right) {\n    children = [leftLabel, rule, rightLabel];\n    label = 'both';\n  } else if (left) {\n    children = [leftLabel, rule];\n    label = 'left';\n  } else if (right) {\n    children = [rule, rightLabel];\n    label = 'right';\n  } else {\n    return rule;\n  }\n  rule = parser.create('node', 'mrow', children);\n  BussproofsUtil.setProperty(rule, 'labelledRule', label);\n  return rule;\n}\nBussproofsMethods.Label = function (parser, name, side) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  var content = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), 0);\n  var label = content.length > 1 ? parser.create('node', 'mrow', content, {}) : content[0];\n  top.setProperty(side, label);\n};\nBussproofsMethods.SetLine = function (parser, _name, style, always) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  top.setProperty('currentLine', style);\n  if (always) {\n    top.setProperty('line', style);\n  }\n};\nBussproofsMethods.RootAtTop = function (parser, _name, where) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  top.setProperty('rootAtTop', where);\n};\nBussproofsMethods.AxiomF = function (parser, name) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  var line = parseFCenterLine(parser, name);\n  BussproofsUtil.setProperty(line, 'axiom', true);\n  top.Push(line);\n};\nfunction parseFCenterLine(parser, name) {\n  var dollar = parser.GetNext();\n  if (dollar !== '$') {\n    throw new TexError_js_1.default('IllegalUseOfCommand', 'Use of %1 does not match it\\'s definition.', name);\n  }\n  parser.i++;\n  var axiom = parser.GetUpTo(name, '$');\n  if (axiom.indexOf('\\\\fCenter') === -1) {\n    throw new TexError_js_1.default('IllegalUseOfCommand', 'Missing \\\\fCenter in %1.', name);\n  }\n  var _a = __read(axiom.split('\\\\fCenter'), 2),\n    prem = _a[0],\n    conc = _a[1];\n  var premise = new TexParser_js_1.default(prem, parser.stack.env, parser.configuration).mml();\n  var conclusion = new TexParser_js_1.default(conc, parser.stack.env, parser.configuration).mml();\n  var fcenter = new TexParser_js_1.default('\\\\fCenter', parser.stack.env, parser.configuration).mml();\n  var left = parser.create('node', 'mtd', [premise], {});\n  var middle = parser.create('node', 'mtd', [fcenter], {});\n  var right = parser.create('node', 'mtd', [conclusion], {});\n  var row = parser.create('node', 'mtr', [left, middle, right], {});\n  var table = parser.create('node', 'mtable', [row], {\n    columnspacing: '.5ex',\n    columnalign: 'center 2'\n  });\n  BussproofsUtil.setProperty(table, 'sequent', true);\n  parser.configuration.addNode('sequent', row);\n  return table;\n}\nBussproofsMethods.FCenter = function (_parser, _name) {};\nBussproofsMethods.InferenceF = function (parser, name, n) {\n  var top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError_js_1.default('IllegalProofCommand', 'Proof commands only allowed in prooftree environment.');\n  }\n  if (top.Size() < n) {\n    throw new TexError_js_1.default('BadProofTree', 'Proof tree badly specified.');\n  }\n  var rootAtTop = top.getProperty('rootAtTop');\n  var childCount = n === 1 && !top.Peek()[0].childNodes.length ? 0 : n;\n  var children = [];\n  do {\n    if (children.length) {\n      children.unshift(parser.create('node', 'mtd', [], {}));\n    }\n    children.unshift(parser.create('node', 'mtd', [top.Pop()], {\n      'rowalign': rootAtTop ? 'top' : 'bottom'\n    }));\n    n--;\n  } while (n > 0);\n  var row = parser.create('node', 'mtr', children, {});\n  var table = parser.create('node', 'mtable', [row], {\n    framespacing: '0 0'\n  });\n  var conclusion = parseFCenterLine(parser, name);\n  var style = top.getProperty('currentLine');\n  if (style !== top.getProperty('line')) {\n    top.setProperty('currentLine', top.getProperty('line'));\n  }\n  var rule = createRule(parser, table, [conclusion], top.getProperty('left'), top.getProperty('right'), style, rootAtTop);\n  top.setProperty('left', null);\n  top.setProperty('right', null);\n  BussproofsUtil.setProperty(rule, 'inference', childCount);\n  parser.configuration.addNode('inference', rule);\n  top.Push(rule);\n};\nexports.default = BussproofsMethods;","map":{"version":3,"names":["TexError_js_1","__importDefault","require","TexParser_js_1","ParseUtil_js_1","BussproofsUtil","__importStar","BussproofsMethods","Prooftree","parser","begin","Push","newItem","itemFactory","create","setProperties","name","getName","line","currentLine","rootAtTop","Axiom","top","stack","Top","kind","default","content","paddedContent","GetArgument","setProperty","nodes","internalMath","trimSpaces","childNodes","length","lpad","width","rpad","__spreadArray","__read","Inference","n","Size","getProperty","childCount","Peek","children","unshift","Pop","row","table","framespacing","conclusion","style","rule","createRule","configuration","addNode","premise","conclusions","left","right","upper","lower","align","rowlines","leftLabel","rightLabel","height","voffset","label","Label","side","SetLine","_name","always","RootAtTop","where","AxiomF","parseFCenterLine","dollar","GetNext","i","axiom","GetUpTo","indexOf","_a","split","prem","conc","env","mml","fcenter","middle","columnspacing","columnalign","FCenter","_parser","InferenceF","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/bussproofs/BussproofsMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Mappings for TeX parsing for the bussproofs package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {ParseMethod} from '../Types.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {StackItem} from '../StackItem.js';\nimport {MmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport * as BussproofsUtil from './BussproofsUtil.js';\n\n\n// Namespace\nlet BussproofsMethods: Record<string, ParseMethod> = {};\n\n/**\n * Implements the proof tree environment.\n * @param {TexParser} parser The current parser.\n * @param {StackItem} begin The opening element of the environment.\n * @return {StackItem} The proof tree stackitem.\n */\n// TODO: Error handling if we have leftover elements or elements are not in the\n// required order.\nBussproofsMethods.Prooftree = function(parser: TexParser, begin: StackItem): StackItem {\n  parser.Push(begin);\n  // TODO: Check if opening a proof tree is legal.\n  let newItem = parser.itemFactory.create('proofTree').\n    setProperties({name: begin.getName(),\n                   line: 'solid', currentLine: 'solid', rootAtTop: false});\n  // parser.Push(item);\n  return newItem;\n};\n\n\n/**\n * Implements the Axiom command.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n */\nBussproofsMethods.Axiom = function(parser: TexParser, name: string) {\n  let top = parser.stack.Top();\n  // TODO: Label error\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  let content = paddedContent(parser, parser.GetArgument(name));\n  BussproofsUtil.setProperty(content, 'axiom', true);\n  top.Push(content);\n};\n\n\n/**\n * Pads content of an inference rule.\n * @param {TexParser} parser The calling parser.\n * @param {string} content The content to be padded.\n * @return {MmlNode} The mrow element with padded content.\n */\nconst paddedContent = function(parser: TexParser, content: string): MmlNode {\n  // Add padding on either site.\n  let nodes = ParseUtil.internalMath(parser, ParseUtil.trimSpaces(content), 0);\n  if (!nodes[0].childNodes[0].childNodes.length) {\n    return parser.create('node', 'mrow', []);\n  }\n  let lpad = parser.create('node', 'mspace', [], {width: '.5ex'});\n  let rpad = parser.create('node', 'mspace', [], {width: '.5ex'});\n  return parser.create('node', 'mrow', [lpad, ...nodes, rpad]);\n};\n\n\n/**\n * Implements the Inference rule commands.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n * @param {number} n Number of premises for this inference rule.\n */\nBussproofsMethods.Inference = function(parser: TexParser, name: string, n: number) {\n  let top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  if (top.Size() < n) {\n    throw new TexError('BadProofTree', 'Proof tree badly specified.');\n  }\n  const rootAtTop = top.getProperty('rootAtTop') as boolean;\n  const childCount = (n === 1 && !top.Peek()[0].childNodes.length) ? 0 : n;\n  let children: MmlNode[] = [];\n  do {\n    if (children.length) {\n      children.unshift(parser.create('node', 'mtd', [], {}));\n    }\n    children.unshift(\n      parser.create('node', 'mtd', [top.Pop()],\n                    {'rowalign': (rootAtTop ? 'top' : 'bottom')}));\n    n--;\n  } while (n > 0);\n  let row = parser.create('node', 'mtr', children, {});\n  let table = parser.create('node', 'mtable', [row], {framespacing: '0 0'});\n  let conclusion = paddedContent(parser, parser.GetArgument(name));\n  let style = top.getProperty('currentLine') as string;\n  if (style !== top.getProperty('line')) {\n    top.setProperty('currentLine', top.getProperty('line'));\n  }\n  let rule = createRule(\n    parser, table, [conclusion], top.getProperty('left') as MmlNode,\n    top.getProperty('right') as MmlNode, style, rootAtTop);\n  top.setProperty('left', null);\n  top.setProperty('right', null);\n  BussproofsUtil.setProperty(rule, 'inference', childCount);\n  parser.configuration.addNode('inference', rule);\n  top.Push(rule);\n};\n\n\n/**\n * Creates a ND style inference rule.\n * @param {TexParser} parser The calling parser.\n * @param {MmlNode} premise The premise (a single table).\n * @param {MmlNode[]} conclusions Elements that are combined into the conclusion.\n * @param {MmlNode|null} left The left label if it exists.\n * @param {MmlNode|null} right The right label if it exists.\n * @param {string} style Style of inference rule line.\n * @param {boolean} rootAtTop Direction of inference rule: true for root at top.\n */\nfunction createRule(parser: TexParser, premise: MmlNode,\n                    conclusions: MmlNode[], left: MmlNode | null,\n                    right: MmlNode | null, style: string,\n                    rootAtTop: boolean) {\n  const upper = parser.create(\n    'node', 'mtr', [parser.create('node', 'mtd', [premise], {})], {});\n  const lower = parser.create(\n    'node', 'mtr', [parser.create('node', 'mtd', conclusions, {})], {});\n  let rule = parser.create('node', 'mtable', rootAtTop ? [lower, upper] : [upper, lower],\n                           {align: 'top 2', rowlines: style, framespacing: '0 0'});\n  BussproofsUtil.setProperty(rule, 'inferenceRule', rootAtTop ? 'up' : 'down');\n  let leftLabel, rightLabel;\n  if (left) {\n    leftLabel = parser.create(\n      'node', 'mpadded', [left],\n      {height: '+.5em', width: '+.5em', voffset: '-.15em'});\n    BussproofsUtil.setProperty(leftLabel, 'prooflabel', 'left');\n  }\n  if (right) {\n    rightLabel = parser.create(\n      'node', 'mpadded', [right],\n      {height: '+.5em', width: '+.5em', voffset: '-.15em'});\n    BussproofsUtil.setProperty(rightLabel, 'prooflabel', 'right');\n  }\n  let children, label;\n  if (left && right) {\n    children = [leftLabel, rule, rightLabel];\n    label = 'both';\n  } else if (left) {\n    children = [leftLabel, rule];\n    label = 'left';\n  } else if (right) {\n    children = [rule, rightLabel];\n    label = 'right';\n  } else {\n    return rule;\n  }\n  rule = parser.create('node', 'mrow', children);\n  BussproofsUtil.setProperty(rule, 'labelledRule', label);\n  return rule;\n}\n\n\n/**\n * Implements the label command.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n * @param {string} side The side of the label.\n */\nBussproofsMethods.Label = function(parser: TexParser, name: string, side: string) {\n  let top = parser.stack.Top();\n  // Label error\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  let content = ParseUtil.internalMath(parser, parser.GetArgument(name), 0);\n  let label = (content.length > 1) ?\n    parser.create('node', 'mrow', content, {}) : content[0];\n  top.setProperty(side, label);\n};\n\n\n/**\n * Sets line style for inference rules.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n * @param {string} style The line style to set.\n * @param {boolean} always Set as permanent style.\n */\nBussproofsMethods.SetLine = function(parser: TexParser, _name: string, style: string, always: boolean) {\n  let top = parser.stack.Top();\n  // Label error\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  top.setProperty('currentLine', style);\n  if (always) {\n    top.setProperty('line', style);\n  }\n};\n\n\n/**\n * Implements commands indicating where the root of the proof tree is.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n * @param {string} where If true root is at top, otherwise at bottom.\n */\nBussproofsMethods.RootAtTop = function(parser: TexParser, _name: string, where: boolean) {\n  let top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  top.setProperty('rootAtTop', where);\n};\n\n\n/**\n * Implements Axiom command for sequents.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n */\nBussproofsMethods.AxiomF = function(parser: TexParser, name: string) {\n  let top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  let line = parseFCenterLine(parser, name);\n  BussproofsUtil.setProperty(line, 'axiom', true);\n  top.Push(line);\n};\n\n\n/**\n * Parses a line with a sequent (i.e., one containing \\\\fcenter).\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the calling command.\n * @return {MmlNode} The parsed line.\n */\nfunction parseFCenterLine(parser: TexParser, name: string): MmlNode {\n  let dollar = parser.GetNext();\n  if (dollar !== '$') {\n    throw new TexError('IllegalUseOfCommand',\n                       'Use of %1 does not match it\\'s definition.', name);\n  }\n  parser.i++;\n  let axiom = parser.GetUpTo(name, '$');\n  if (axiom.indexOf('\\\\fCenter') === -1) {\n    throw new TexError('IllegalUseOfCommand',\n                       'Missing \\\\fCenter in %1.', name);\n  }\n  // Check for fCenter and throw error?\n  let [prem, conc] = axiom.split('\\\\fCenter');\n  let premise = (new TexParser(prem, parser.stack.env, parser.configuration)).mml();\n  let conclusion = (new TexParser(conc, parser.stack.env, parser.configuration)).mml();\n  let fcenter = (new TexParser('\\\\fCenter', parser.stack.env, parser.configuration)).mml();\n  const left = parser.create('node', 'mtd', [premise], {});\n  const middle = parser.create('node', 'mtd', [fcenter], {});\n  const right = parser.create('node', 'mtd', [conclusion], {});\n  const row = parser.create('node', 'mtr', [left, middle, right], {});\n  const table = parser.create('node', 'mtable', [row], {columnspacing: '.5ex', columnalign: 'center 2'});\n  BussproofsUtil.setProperty(table, 'sequent', true);\n  parser.configuration.addNode('sequent', row);\n  return table;\n}\n\n\n/**\n * Placeholder for Fcenter macro that can be overwritten with renewcommand.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n */\nBussproofsMethods.FCenter = function(_parser: TexParser, _name: string) { };\n\n\n/**\n * Implements inference rules for sequents.\n * @param {TexParser} parser The current parser.\n * @param {string} name The name of the command.\n * @param {number} n Number of premises for this inference rule.\n */\nBussproofsMethods.InferenceF = function(parser: TexParser, name: string, n: number) {\n  let top = parser.stack.Top();\n  if (top.kind !== 'proofTree') {\n    throw new TexError('IllegalProofCommand',\n                       'Proof commands only allowed in prooftree environment.');\n  }\n  if (top.Size() < n) {\n    throw new TexError('BadProofTree', 'Proof tree badly specified.');\n  }\n  const rootAtTop = top.getProperty('rootAtTop') as boolean;\n  const childCount = (n === 1 && !top.Peek()[0].childNodes.length) ? 0 : n;\n  let children: MmlNode[] = [];\n  do {\n    if (children.length) {\n      children.unshift(parser.create('node', 'mtd', [], {}));\n    }\n    children.unshift(\n      parser.create('node', 'mtd', [top.Pop()],\n                    {'rowalign': (rootAtTop ? 'top' : 'bottom')}));\n    n--;\n  } while (n > 0);\n  let row = parser.create('node', 'mtr', children, {});\n  let table = parser.create('node', 'mtable', [row], {framespacing: '0 0'});\n\n  let conclusion = parseFCenterLine(parser, name); // TODO: Padding\n  let style = top.getProperty('currentLine') as string;\n  if (style !== top.getProperty('line')) {\n    top.setProperty('currentLine', top.getProperty('line'));\n  }\n  let rule = createRule(\n    parser, table, [conclusion], top.getProperty('left') as MmlNode,\n    top.getProperty('right') as MmlNode, style, rootAtTop);\n  top.setProperty('left', null);\n  top.setProperty('right', null);\n  BussproofsUtil.setProperty(rule, 'inference', childCount);\n  parser.configuration.addNode('inference', rule);\n  top.Push(rule);\n};\n\nexport default BussproofsMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}