{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonMencloseMixin = void 0;\nvar Notation = __importStar(require(\"../Notation.js\"));\nvar string_js_1 = require(\"../../../util/string.js\");\nfunction CommonMencloseMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n      _this.notations = {};\n      _this.renderChild = null;\n      _this.msqrt = null;\n      _this.padding = Notation.PADDING;\n      _this.thickness = Notation.THICKNESS;\n      _this.arrowhead = {\n        x: Notation.ARROWX,\n        y: Notation.ARROWY,\n        dx: Notation.ARROWDX\n      };\n      _this.TRBL = [0, 0, 0, 0];\n      _this.getParameters();\n      _this.getNotations();\n      _this.removeRedundantNotations();\n      _this.initializeNotations();\n      _this.TRBL = _this.getBBoxExtenders();\n      return _this;\n    }\n    class_1.prototype.getParameters = function () {\n      var attributes = this.node.attributes;\n      var padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      var thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      var arrowhead = attributes.get('data-arrowhead');\n      if (arrowhead !== undefined) {\n        var _b = __read((0, string_js_1.split)(arrowhead), 3),\n          x = _b[0],\n          y = _b[1],\n          dx = _b[2];\n        this.arrowhead = {\n          x: x ? parseFloat(x) : Notation.ARROWX,\n          y: y ? parseFloat(y) : Notation.ARROWY,\n          dx: dx ? parseFloat(dx) : Notation.ARROWDX\n        };\n      }\n    };\n    class_1.prototype.getNotations = function () {\n      var e_1, _b;\n      var Notations = this.constructor.notations;\n      try {\n        for (var _c = __values((0, string_js_1.split)(this.node.attributes.get('notation'))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          var notation = Notations.get(name_1);\n          if (notation) {\n            this.notations[name_1] = notation;\n            if (notation.renderChild) {\n              this.renderChild = notation.renderer;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n    class_1.prototype.removeRedundantNotations = function () {\n      var e_2, _b, e_3, _c;\n      try {\n        for (var _d = __values(Object.keys(this.notations)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var name_2 = _e.value;\n          if (this.notations[name_2]) {\n            var remove = this.notations[name_2].remove || '';\n            try {\n              for (var _f = (e_3 = void 0, __values(remove.split(/ /))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var notation = _g.value;\n                delete this.notations[notation];\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n    class_1.prototype.initializeNotations = function () {\n      var e_4, _b;\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_3 = _d.value;\n          var init = this.notations[name_3].init;\n          init && init(this);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    };\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n      var _b = __read(this.TRBL, 4),\n        T = _b[0],\n        R = _b[1],\n        B = _b[2],\n        L = _b[3];\n      var child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    };\n    class_1.prototype.getBBoxExtenders = function () {\n      var e_5, _b;\n      var TRBL = [0, 0, 0, 0];\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_4 = _d.value;\n          this.maximizeEntries(TRBL, this.notations[name_4].bbox(this));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      return TRBL;\n    };\n    class_1.prototype.getPadding = function () {\n      var e_6, _b;\n      var _this = this;\n      var BTRBL = [0, 0, 0, 0];\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_5 = _d.value;\n          var border = this.notations[name_5].border;\n          if (border) {\n            this.maximizeEntries(BTRBL, border(this));\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n      return [0, 1, 2, 3].map(function (i) {\n        return _this.TRBL[i] - BTRBL[i];\n      });\n    };\n    class_1.prototype.maximizeEntries = function (X, Y) {\n      for (var i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    };\n    class_1.prototype.getOffset = function (direction) {\n      var _b = __read(this.TRBL, 4),\n        T = _b[0],\n        R = _b[1],\n        B = _b[2],\n        L = _b[3];\n      var d = (direction === 'X' ? R - L : B - T) / 2;\n      return Math.abs(d) > .001 ? d : 0;\n    };\n    class_1.prototype.getArgMod = function (w, h) {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    };\n    class_1.prototype.arrow = function (_w, _a, _double, _offset, _dist) {\n      if (_offset === void 0) {\n        _offset = '';\n      }\n      if (_dist === void 0) {\n        _dist = 0;\n      }\n      return null;\n    };\n    class_1.prototype.arrowData = function () {\n      var _b = __read([this.padding, this.thickness], 2),\n        p = _b[0],\n        t = _b[1];\n      var r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      var _c = this.childNodes[0].getBBox(),\n        h = _c.h,\n        d = _c.d,\n        w = _c.w;\n      var H = h + d;\n      var R = Math.sqrt(H * H + w * w);\n      var x = Math.max(p, r * w / R);\n      var y = Math.max(p, r * H / R);\n      var _d = __read(this.getArgMod(w + 2 * x, H + 2 * y), 2),\n        a = _d[0],\n        W = _d[1];\n      return {\n        a: a,\n        W: W,\n        x: x,\n        y: y\n      };\n    };\n    class_1.prototype.arrowAW = function () {\n      var _b = this.childNodes[0].getBBox(),\n        h = _b.h,\n        d = _b.d,\n        w = _b.w;\n      var _c = __read(this.TRBL, 4),\n        T = _c[0],\n        R = _c[1],\n        B = _c[2],\n        L = _c[3];\n      return this.getArgMod(L + w + R, T + h + d + B);\n    };\n    class_1.prototype.createMsqrt = function (child) {\n      var mmlFactory = this.node.factory;\n      var mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      var node = this.wrap(mml);\n      node.parent = this;\n      return node;\n    };\n    class_1.prototype.sqrtTRBL = function () {\n      var bbox = this.msqrt.getBBox();\n      var cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    };\n    return class_1;\n  }(Base);\n}\nexports.CommonMencloseMixin = CommonMencloseMixin;","map":{"version":3,"names":["Notation","__importStar","require","string_js_1","CommonMencloseMixin","Base","_super","__extends","class_1","args","_i","arguments","length","_this","apply","__spreadArray","__read","notations","renderChild","msqrt","padding","PADDING","thickness","THICKNESS","arrowhead","x","ARROWX","y","ARROWY","dx","ARROWDX","TRBL","getParameters","getNotations","removeRedundantNotations","initializeNotations","getBBoxExtenders","prototype","attributes","node","get","undefined","length2em","_b","split","parseFloat","Notations","constructor","_c","__values","_d","next","done","name_1","value","notation","renderer","Object","keys","_e","name_2","remove","_f","e_3","_g","name_3","init","computeBBox","bbox","recompute","T","R","B","L","child","childNodes","getBBox","combine","h","d","w","setChildPWidths","name_4","maximizeEntries","getPadding","BTRBL","name_5","border","map","i","X","Y","getOffset","direction","Math","abs","getArgMod","atan2","sqrt","arrow","_w","_a","_double","_offset","_dist","arrowData","p","t","r","max","H","a","W","arrowAW","createMsqrt","mmlFactory","factory","mml","create","inheritAttributesFrom","wrap","parent","sqrtTRBL","cbox","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/output/common/Wrappers/menclose.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport * as Notation from '../Notation.js';\nimport {CommonMsqrt} from './msqrt.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {AbstractMmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {split} from '../../../util/string.js';\n\n/*****************************************************************/\n/**\n * The CommonMenclose interface\n *\n * @template W  The menclose wrapper type\n */\nexport interface CommonMenclose<W extends AnyWrapper, S extends CommonMsqrt, N> extends AnyWrapper {\n  /**\n   *  The notations active on this menclose, and the one to use for the child, if any\n   */\n  notations: Notation.List<W, N>;\n  renderChild: Notation.Renderer<W, N>;\n\n  /**\n   * fake msqrt for radial notation (if used)\n   */\n  msqrt: S;\n\n  /**\n   * The padding, thickness, and shape of the arrow head\n   *   (may be overridden using data-padding, data-thickness, and data-arrowhead attibutes)\n   */\n  padding: number;\n  thickness: number;\n  arrowhead: {x: number, y: number, dx: number};\n\n  /**\n   * The top, right, bottom, and left padding, added by notations\n   */\n  TRBL: Notation.PaddingData;\n\n  /**\n   * Look up the data-* attributes and override the default values\n   */\n  getParameters(): void;\n\n  /**\n   *  Get the notations given in the notation attribute\n   *    and check if any are used to render the child nodes\n   */\n  getNotations(): void;\n\n  /**\n   *  Remove any redundant notations\n   */\n  removeRedundantNotations(): void;\n\n  /**\n   *  Run any initialization needed by notations in use\n   */\n  initializeNotations(): void;\n\n  /**\n   * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n   */\n  getBBoxExtenders(): Notation.PaddingData;\n\n  /**\n   * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n   */\n  getPadding(): Notation.PaddingData;\n\n  /**\n   * Each entry in X gets replaced by the corresponding one in Y if it is larger\n   *\n   * @param {Notation.PaddingData} X   An array of numbers\n   * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n   */\n  maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData): void;\n\n  /**\n   * Get the offset amount for the given direction for vertical and horizontal centering\n   *\n   * @param {string} direction    The direction 'X' or 'Y' for the offset\n   * @return {number}             The amount of offset in that direction\n   */\n  getOffset(direction: string): number;\n\n  /**\n   * @param {number} w    The width of the box whose diagonal is needed\n   * @param {number} h    The height of the box whose diagonal is needed\n   * @return {number[]}   The angle and width of the diagonal of the box\n   */\n  getArgMod(w: number, h: number): [number, number];\n\n  /**\n   * Create an arrow for output\n   *\n   * @param {number} w         The length of the arrow\n   * @param {number} a         The angle for the arrow\n   * @param {boolean} double   True if this is a double-headed arrow\n   * @param {string} offset    'X' for vertical arrow, 'Y' for horizontal\n   * @param {number} trans     Distance to translate in the offset direction\n   * @return {N}               The newly created arrow\n   */\n  arrow(w: number, a: number, double: boolean, offset?: string, trans?: number): N;\n\n  /**\n   * Get the angle and width of a diagonal arrow, plus the x and y extension\n   *   past the content bounding box\n   */\n  arrowData(): {a: number, W: number, x: number, y: number};\n\n  /**\n   * Get the angle and width for a diagonal arrow\n   *\n   * @return {[number, number]}   The angle and width\n   */\n  arrowAW(): [number, number];\n\n  /**\n   * Create an unattached msqrt wrapper to render the 'radical' notation.\n   *   We replace the inferred mrow of the msqrt with the one from the menclose\n   *   but without changing the parent pointer, so as not to detach it from\n   *   the menclose (which would desrtoy the original MathML tree).\n   *\n   * @param {W} child   The inferred mrow that is the child of this menclose\n   * @return {S}        The newly created (but detached) msqrt wrapper\n   */\n  createMsqrt(child: W): S;\n\n  /**\n   * @return {number[]}  The differences between the msqrt bounding box\n   *                     and its child bounding box (i.e., the extra space\n   *                     created by the radical symbol).\n   */\n  sqrtTRBL(): number[];\n}\n\n/**\n * The CommonMenclose class interface\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n */\nexport interface CommonMencloseClass<W extends AnyWrapper, N> extends AnyWrapperClass {\n  /**\n   *  The definitions of the various notations\n   */\n  notations: Notation.DefList<W, N>;\n}\n\n/**\n * Shorthand for the CommonMenclose constructor\n *\n * @template W  The menclose wrapper type\n */\nexport type MencloseConstructor<W extends AnyWrapper, S extends CommonMsqrt, N> = Constructor<CommonMenclose<W, S, N>>;\n\n/*****************************************************************/\n/**\n * The CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n * @templare S  The msqrt wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonMencloseMixin<\n  W extends AnyWrapper,\n  S extends CommonMsqrt,\n  N,\n  T extends WrapperConstructor\n>(Base: T): MencloseConstructor<W, S, N> & T {\n\n  return class extends Base {\n\n    /**\n     *  The notations active on this menclose, if any\n     */\n    public notations: Notation.List<W, N> = {};\n\n    /**\n     *  The notation to use for the child, if any\n     */\n    public renderChild: Notation.Renderer<W, N> = null;\n\n    /**\n     * fake msqrt for radial notation (if used)\n     */\n    public msqrt: S = null;\n\n    /**\n     * The padding of the arrow head (may be overridden using data-padding attibute)\n     */\n    public padding: number = Notation.PADDING;\n    /**\n     * The thickness of the arrow head (may be overridden using data-thickness attibute)\n     */\n    public thickness: number = Notation.THICKNESS;\n    /**\n     * The shape of the arrow head (may be overridden using data-arrowhead attibutes)\n     */\n    public arrowhead = {x: Notation.ARROWX, y: Notation.ARROWY, dx: Notation.ARROWDX};\n\n    /**\n     * The top, right, bottom, and left padding (added by notations)\n     */\n    public TRBL: Notation.PaddingData = [0, 0, 0, 0];\n\n    /**\n     * @override\n     * @constructor\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      this.getParameters();\n      this.getNotations();\n      this.removeRedundantNotations();\n      this.initializeNotations();\n      this.TRBL = this.getBBoxExtenders();\n    }\n\n    /**\n     * Look up the data-* attributes and override the default values\n     */\n    public getParameters() {\n      const attributes = this.node.attributes;\n      const padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      const thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      const arrowhead = attributes.get('data-arrowhead') as string;\n      if (arrowhead !== undefined) {\n        let [x, y, dx] = split(arrowhead);\n        this.arrowhead = {\n          x: (x ? parseFloat(x) : Notation.ARROWX),\n          y: (y ? parseFloat(y) : Notation.ARROWY),\n          dx: (dx ? parseFloat(dx) : Notation.ARROWDX)\n        };\n      }\n    }\n\n    /**\n     *  Get the notations given in the notation attribute\n     *    and check if any are used to render the child nodes\n     */\n    public getNotations() {\n      const Notations = (this.constructor as CommonMencloseClass<W, N>).notations;\n      for (const name of split(this.node.attributes.get('notation') as string)) {\n        const notation = Notations.get(name);\n        if (notation) {\n          this.notations[name] = notation;\n          if (notation.renderChild) {\n            this.renderChild = notation.renderer;\n          }\n        }\n      }\n    }\n\n    /**\n     *  Remove any redundant notations\n     */\n    public removeRedundantNotations() {\n      for (const name of Object.keys(this.notations)) {\n        if (this.notations[name]) {\n          const remove = this.notations[name].remove || '';\n          for (const notation of remove.split(/ /)) {\n            delete this.notations[notation];\n          }\n        }\n      }\n    }\n\n    /**\n     *  Run any initialization needed by notations in use\n     */\n    public initializeNotations() {\n      for (const name of Object.keys(this.notations)) {\n        const init = this.notations[name].init;\n        init && init(this as any);\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      //\n      //  Combine the BBox from the child and add the extenders\n      //\n      let [T, R, B, L] = this.TRBL;\n      const child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n     */\n    public getBBoxExtenders(): Notation.PaddingData {\n      let TRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        this.maximizeEntries(TRBL, this.notations[name].bbox(this as any));\n      }\n      return TRBL;\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n     */\n    public getPadding(): Notation.PaddingData {\n      let BTRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        const border = this.notations[name].border;\n        if (border) {\n          this.maximizeEntries(BTRBL, border(this as any));\n        }\n      }\n      return [0, 1, 2, 3].map(i => this.TRBL[i] - BTRBL[i]) as Notation.PaddingData;\n    }\n\n    /**\n     * Each entry in X gets replaced by the corresponding one in Y if it is larger\n     *\n     * @param {Notation.PaddingData} X   An array of numbers\n     * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n     */\n    public maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData) {\n      for (let i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * Get the offset amount for the given direction for vertical and horizontal centering\n     *\n     * @param {string} direction    The direction 'X' or 'Y' for the offset\n     * @return {number}             The amount of offset in that direction\n     */\n    public getOffset(direction: string): number {\n      let [T, R, B, L] = this.TRBL;\n      const d = (direction === 'X' ? R - L : B - T) / 2;\n      return (Math.abs(d) > .001 ? d : 0);\n    }\n\n    /**\n     * @param {number} w    The width of the box whose diagonal is needed\n     * @param {number} h    The height of the box whose diagonal is needed\n     * @return {number[]}   The angle and width of the diagonal of the box\n     */\n    public getArgMod(w: number, h: number): [number, number] {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    }\n\n    /**\n     * Create an arrow using an svg element\n     *\n     * @param {number} w        The length of the arrow\n     * @param {number} a        The angle for the arrow\n     * @param {boolean} double  True if this is a double-headed arrow\n     * @param {string} offset   'X' for vertical arrow, 'Y' for horizontal\n     * @param {number} dist     Distance to translate in the offset direction\n     * @return {N}              The newly created arrow\n     */\n    public arrow(_w: number, _a: number, _double: boolean, _offset: string = '', _dist: number = 0): N {\n      return null as N;\n    }\n\n    /**\n     * Get the angle and width of a diagonal arrow, plus the x and y extension\n     *   past the content bounding box\n     *\n     * @return {Object}  The angle, width, and x and y extentions\n     */\n    public arrowData(): {a: number, W: number, x: number, y: number} {\n      const [p, t] = [this.padding, this.thickness];\n      const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const H = h + d;\n      const R = Math.sqrt(H * H + w * w);\n      const x = Math.max(p, r * w / R);\n      const y = Math.max(p, r * H / R);\n      const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);\n      return {a, W, x, y};\n    }\n\n    /**\n     * Get the angle and width for a diagonal arrow\n     *\n     * @return {[number, number]}   The angle and width\n     */\n    public arrowAW(): [number, number] {\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const [T, R, B, L] = this.TRBL;\n      return this.getArgMod(L + w + R, T + h + d + B);\n    }\n\n    /********************************************************/\n\n    /**\n     * Create an unattached msqrt wrapper to render the 'radical' notation.\n     *   We replace the inferred mrow of the msqrt with the one from the menclose\n     *   but without changing the parent pointer, so as not to detach it from\n     *   the menclose (which would desrtoy the original MathML tree).\n     *\n     * @param {W} child   The inferred mrow that is the child of this menclose\n     * @return {S}        The newly created (but detached) msqrt wrapper\n     */\n    public createMsqrt(child: W): S {\n      const mmlFactory = (this.node as AbstractMmlNode).factory;\n      const mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      const node = this.wrap(mml) as S;\n      node.parent = this;\n      return node;\n    }\n\n    /**\n     * @return {number[]}  The differences between the msqrt bounding box\n     *                     and its child bounding box (i.e., the extra space\n     *                     created by the radical symbol).\n     */\n    public sqrtTRBL(): [number, number, number, number] {\n      const bbox = this.msqrt.getBBox();\n      const cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    }\n\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}