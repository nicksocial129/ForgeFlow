{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar mo_js_1 = require(\"../../core/MmlTree/MmlNodes/mo.js\");\nvar NodeUtil;\n(function (NodeUtil) {\n  var attrs = new Map([['autoOP', true], ['fnOP', true], ['movesupsub', true], ['subsupOK', true], ['texprimestyle', true], ['useHeight', true], ['variantForm', true], ['withDelims', true], ['mathaccent', true], ['open', true], ['close', true]]);\n  function createEntity(code) {\n    return String.fromCodePoint(parseInt(code, 16));\n  }\n  NodeUtil.createEntity = createEntity;\n  function getChildren(node) {\n    return node.childNodes;\n  }\n  NodeUtil.getChildren = getChildren;\n  function getText(node) {\n    return node.getText();\n  }\n  NodeUtil.getText = getText;\n  function appendChildren(node, children) {\n    var e_1, _a;\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        node.appendChild(child);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n  NodeUtil.appendChildren = appendChildren;\n  function setAttribute(node, attribute, value) {\n    node.attributes.set(attribute, value);\n  }\n  NodeUtil.setAttribute = setAttribute;\n  function setProperty(node, property, value) {\n    node.setProperty(property, value);\n  }\n  NodeUtil.setProperty = setProperty;\n  function setProperties(node, properties) {\n    var e_2, _a;\n    try {\n      for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        var value = properties[name_1];\n        if (name_1 === 'texClass') {\n          node.texClass = value;\n          node.setProperty(name_1, value);\n        } else if (name_1 === 'movablelimits') {\n          node.setProperty('movablelimits', value);\n          if (node.isKind('mo') || node.isKind('mstyle')) {\n            node.attributes.set('movablelimits', value);\n          }\n        } else if (name_1 === 'inferred') {} else if (attrs.has(name_1)) {\n          node.setProperty(name_1, value);\n        } else {\n          node.attributes.set(name_1, value);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  }\n  NodeUtil.setProperties = setProperties;\n  function getProperty(node, property) {\n    return node.getProperty(property);\n  }\n  NodeUtil.getProperty = getProperty;\n  function getAttribute(node, attr) {\n    return node.attributes.get(attr);\n  }\n  NodeUtil.getAttribute = getAttribute;\n  function removeProperties(node) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      properties[_i - 1] = arguments[_i];\n    }\n    node.removeProperty.apply(node, __spreadArray([], __read(properties), false));\n  }\n  NodeUtil.removeProperties = removeProperties;\n  function getChildAt(node, position) {\n    return node.childNodes[position];\n  }\n  NodeUtil.getChildAt = getChildAt;\n  function setChild(node, position, child) {\n    var children = node.childNodes;\n    children[position] = child;\n    if (child) {\n      child.parent = node;\n    }\n  }\n  NodeUtil.setChild = setChild;\n  function copyChildren(oldNode, newNode) {\n    var children = oldNode.childNodes;\n    for (var i = 0; i < children.length; i++) {\n      setChild(newNode, i, children[i]);\n    }\n  }\n  NodeUtil.copyChildren = copyChildren;\n  function copyAttributes(oldNode, newNode) {\n    newNode.attributes = oldNode.attributes;\n    setProperties(newNode, oldNode.getAllProperties());\n  }\n  NodeUtil.copyAttributes = copyAttributes;\n  function isType(node, kind) {\n    return node.isKind(kind);\n  }\n  NodeUtil.isType = isType;\n  function isEmbellished(node) {\n    return node.isEmbellished;\n  }\n  NodeUtil.isEmbellished = isEmbellished;\n  function getTexClass(node) {\n    return node.texClass;\n  }\n  NodeUtil.getTexClass = getTexClass;\n  function getCoreMO(node) {\n    return node.coreMO();\n  }\n  NodeUtil.getCoreMO = getCoreMO;\n  function isNode(item) {\n    return item instanceof MmlNode_js_1.AbstractMmlNode || item instanceof MmlNode_js_1.AbstractMmlEmptyNode;\n  }\n  NodeUtil.isNode = isNode;\n  function isInferred(node) {\n    return node.isInferred;\n  }\n  NodeUtil.isInferred = isInferred;\n  function getForm(node) {\n    var e_3, _a;\n    if (!isType(node, 'mo')) {\n      return null;\n    }\n    var mo = node;\n    var forms = mo.getForms();\n    try {\n      for (var forms_1 = __values(forms), forms_1_1 = forms_1.next(); !forms_1_1.done; forms_1_1 = forms_1.next()) {\n        var form = forms_1_1.value;\n        var symbol = mo_js_1.MmlMo.OPTABLE[form][mo.getText()];\n        if (symbol) {\n          return symbol;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (forms_1_1 && !forms_1_1.done && (_a = forms_1.return)) _a.call(forms_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return null;\n  }\n  NodeUtil.getForm = getForm;\n})(NodeUtil || (NodeUtil = {}));\nexports.default = NodeUtil;","map":{"version":3,"names":["MmlNode_js_1","require","mo_js_1","NodeUtil","attrs","Map","createEntity","code","String","fromCodePoint","parseInt","getChildren","node","childNodes","getText","appendChildren","children","children_1","__values","children_1_1","next","done","child","value","appendChild","setAttribute","attribute","attributes","set","setProperty","property","setProperties","properties","_b","Object","keys","_c","name_1","texClass","isKind","has","getProperty","getAttribute","attr","get","removeProperties","_i","arguments","length","removeProperty","apply","__spreadArray","__read","getChildAt","position","setChild","parent","copyChildren","oldNode","newNode","i","copyAttributes","getAllProperties","isType","kind","isEmbellished","getTexClass","getCoreMO","coreMO","isNode","item","AbstractMmlNode","AbstractMmlEmptyNode","isInferred","getForm","mo","forms","getForms","forms_1","forms_1_1","form","symbol","MmlMo","OPTABLE","exports","default"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/NodeUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Node utility methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TextNode, MMLNODE, MmlNode, AbstractMmlNode, AbstractMmlEmptyNode} from '../../core/MmlTree/MmlNode.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Property, PropertyList} from '../../core/Tree/Node.js';\nimport {Args} from './Types.js';\nimport {OperatorDef} from '../../core/MmlTree/OperatorDictionary.js';\n\n\nnamespace NodeUtil {\n\n  const attrs: Map<String, boolean> = new Map([\n    ['autoOP', true],\n    ['fnOP', true],\n    ['movesupsub', true],\n    ['subsupOK', true],\n    ['texprimestyle', true],\n    ['useHeight', true],\n    ['variantForm', true],\n    ['withDelims', true],\n    ['mathaccent', true],\n    ['open', true],\n    ['close', true]\n  ]);\n\n\n  /**\n   * Creates a single character from a unicode hex string.\n   * @param {string} code The code.\n   * @return {string} The newly created entity.\n   */\n  export function createEntity(code: string): string  {\n    return String.fromCodePoint(parseInt(code, 16));\n  }\n\n\n  /**\n   * Get the children of the a node.\n   * @param {MmlNode} node The node.\n   * @return {MMLNODE[]} Its children.\n   */\n  export function getChildren(node: MmlNode): MMLNODE[] {\n    return (node.childNodes as MMLNODE[]);\n  }\n\n\n  /**\n   * Get text content of a node.\n   * @param {TextNode} node The node.\n   * @return {string} Its text content.\n   */\n  export function getText(node: TextNode): string {\n    return node.getText();\n  }\n\n\n  /**\n   * Append children to a node.\n   * @param {MmlNode} node The node.\n   * @param {MMLNODE[]} children A list of new children.\n   */\n  export function appendChildren(node: MmlNode, children: MMLNODE[])  {\n    for (let child of children) {\n      node.appendChild(child);\n    }\n  }\n\n\n  /**\n   * Sets an attribute of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} attribute An attribute.\n   * @param {Args} value The attribute value.\n   */\n  export function setAttribute(node: MmlNode, attribute: string, value: Args) {\n    node.attributes.set(attribute, value);\n  }\n\n\n  /**\n   * Sets a property of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} property The property.\n   * @param {Args} value The property value.\n   */\n  export function setProperty(node: MmlNode, property: string, value: Args) {\n    node.setProperty(property, value);\n  }\n\n\n  /**\n   * Sets properties and attributes of a node.\n   * @param {MmlNode} node The node.\n   * @param {PropertyList} properties A list of property/attribute value pairs.\n   */\n  export function setProperties(node: MmlNode, properties: PropertyList) {\n    for (const name of Object.keys(properties)) {\n      let value = properties[name];\n      if (name === 'texClass') {\n        node.texClass = (value as number);\n        node.setProperty(name, value);\n      } else if (name === 'movablelimits') {\n        node.setProperty('movablelimits', value);\n        if (node.isKind('mo') || node.isKind('mstyle')) {\n          node.attributes.set('movablelimits', value);\n        }\n      } else if (name === 'inferred') {\n        // ignore\n      } else if (attrs.has(name)) {\n        node.setProperty(name, value);\n      } else {\n        node.attributes.set(name, value);\n      }\n    }\n  }\n\n\n  /**\n   * Returns the property of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} property A property name.\n   * @return {Property} Value of the property.\n   */\n  export function getProperty(node: MmlNode, property: string): Property  {\n    return node.getProperty(property);\n  }\n\n\n  /**\n   * Returns the attribute of a node.\n   * @param {MmlNode} node The node.\n   * @param {string} attr A attribute name.\n   * @return {Property} Value of the attribute.\n   */\n  export function getAttribute(node: MmlNode, attr: string): Property  {\n    return node.attributes.get(attr);\n  }\n\n\n  /**\n   * Removes a set of properties from a node.\n   * @param {MmlNode} node The node.\n   * @param {string[]} ...properties  A list of properties.\n   */\n  export function removeProperties(node: MmlNode, ...properties: string[]) {\n    node.removeProperty(...properties);\n  }\n\n\n  /**\n   * Returns a child node at a given position.\n   * @param {MmlNode} node The node.\n   * @param {number} position The position of the child.\n   * @return {MMLNODE} The child node at position.\n   */\n  export function getChildAt(node: MmlNode, position: number): MMLNODE {\n    return (node.childNodes[position] as MMLNODE);\n  }\n\n\n  /**\n   * Set node child at position.\n   * @param {MmlNode} node The node.\n   * @param {number} position The position of the new child.\n   * @param {MmlNode} child The new child.\n   */\n  export function setChild(node: MmlNode, position: number, child: MmlNode) {\n    let children = node.childNodes;\n    children[position] = child;\n    if (child) {\n      child.parent = node;\n    }\n  }\n\n\n  /**\n   * Copies children between nodes.\n   * @param {MmlNode} oldNode The source node.\n   * @param {MmlNode} newNode The target node.\n   */\n  export function copyChildren(oldNode: MmlNode, newNode: MmlNode) {\n    let children = oldNode.childNodes as (TextNode | MmlNode)[];\n    for (let i = 0; i < children.length; i++) {\n      setChild(newNode, i, children[i]);\n    }\n  }\n\n\n  /**\n   * Copies attributes between nodes.\n   * @param {MmlNode} oldNode The source node.\n   * @param {MmlNode} newNode The target node.\n   */\n  export function copyAttributes(oldNode: MmlNode, newNode: MmlNode) {\n    newNode.attributes = oldNode.attributes;\n    setProperties(newNode, oldNode.getAllProperties());\n  }\n\n\n  /**\n   * Checks if node is of a particular type.\n   * @param {MmlNode} node The node.\n   * @param {string} kind The type to check.\n   * @return {boolean} True if node is of the given type.\n   */\n  export function isType(node: MmlNode, kind: string): boolean  {\n    return node.isKind(kind);\n  }\n\n\n  /**\n   * Checks if the node is embellished.\n   * @param {MmlNode} node The node.\n   * @return {boolean} True if node is embellished.\n   */\n  export function isEmbellished(node: MmlNode): boolean {\n    return node.isEmbellished;\n  }\n\n\n  /**\n   * Gets the texclass of a node.\n   * @param {MmlNode} node The node.\n   * @return {number} Its texclass.\n   */\n  export function getTexClass(node: MmlNode): number  {\n    return node.texClass;\n  }\n\n\n  /**\n   * Gets the mo element at the core of the node.\n   * @param {MmlNode} node The node.\n   * @return {MmlNode} The MO node at the core.\n   */\n  export function getCoreMO(node: MmlNode): MmlNode  {\n    return node.coreMO();\n  }\n\n\n  /**\n   * Checks if an object is a node.\n   * @param {any} item The object.\n   * @return {boolean} True if it is a node.\n   */\n  export function isNode(item: any): boolean  {\n    return item instanceof AbstractMmlNode || item instanceof AbstractMmlEmptyNode;\n  }\n\n\n  /**\n   * Checks if the node is an inferred mrow.\n   * @param {MmlNode} node The node.\n   * @return {boolean} True if the node is an inferred mrow.\n   */\n  export function isInferred(node: MmlNode): boolean {\n    return node.isInferred;\n  }\n\n\n  /**\n   * Gets the operator definition of a node.\n   * @param {MmlNode} node The node.\n   * @return {OperatorDef} If node is an MO returns the operator definition. O/w\n   *    null.\n   */\n  export function getForm(node: MmlNode): OperatorDef {\n    if (!isType(node, 'mo')) {\n      return null;\n    }\n    let mo = node as MmlMo;\n    let forms = mo.getForms();\n    for (let form of forms) {\n      let symbol = MmlMo.OPTABLE[form][mo.getText()];\n      if (symbol) {\n        return symbol;\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default NodeUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}