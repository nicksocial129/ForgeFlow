{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar BaseConfiguration_js_1 = require(\"../base/BaseConfiguration.js\");\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar AmsCdMethods = {};\nAmsCdMethods.CD = function (parser, begin) {\n  parser.Push(begin);\n  var item = parser.itemFactory.create('array');\n  var options = parser.configuration.options.amscd;\n  item.setProperties({\n    minw: parser.stack.env.CD_minw || options.harrowsize,\n    minh: parser.stack.env.CD_minh || options.varrowsize\n  });\n  item.arraydef = {\n    columnalign: 'center',\n    columnspacing: options.colspace,\n    rowspacing: options.rowspace,\n    displaystyle: true\n  };\n  return item;\n};\nAmsCdMethods.arrow = function (parser, name) {\n  var c = parser.string.charAt(parser.i);\n  if (!c.match(/[><VA.|=]/)) {\n    return (0, BaseConfiguration_js_1.Other)(parser, name);\n  } else {\n    parser.i++;\n  }\n  var first = parser.stack.Top();\n  if (!first.isKind('array') || first.Size()) {\n    AmsCdMethods.cell(parser, name);\n    first = parser.stack.Top();\n  }\n  var top = first;\n  var arrowRow = top.table.length % 2 === 1;\n  var n = (top.row.length + (arrowRow ? 0 : 1)) % 2;\n  while (n) {\n    AmsCdMethods.cell(parser, name);\n    n--;\n  }\n  var mml;\n  var hdef = {\n      minsize: top.getProperty('minw'),\n      stretchy: true\n    },\n    vdef = {\n      minsize: top.getProperty('minh'),\n      stretchy: true,\n      symmetric: true,\n      lspace: 0,\n      rspace: 0\n    };\n  if (c === '.') {} else if (c === '|') {\n    mml = parser.create('token', 'mo', vdef, '\\u2225');\n  } else if (c === '=') {\n    mml = parser.create('token', 'mo', hdef, '=');\n  } else {\n    var arrow = {\n      '>': '\\u2192',\n      '<': '\\u2190',\n      'V': '\\u2193',\n      'A': '\\u2191'\n    }[c];\n    var a = parser.GetUpTo(name + c, c);\n    var b = parser.GetUpTo(name + c, c);\n    if (c === '>' || c === '<') {\n      mml = parser.create('token', 'mo', hdef, arrow);\n      if (!a) {\n        a = '\\\\kern ' + top.getProperty('minw');\n      }\n      if (a || b) {\n        var pad = {\n          width: '+.67em',\n          lspace: '.33em'\n        };\n        mml = parser.create('node', 'munderover', [mml]);\n        if (a) {\n          var nodeA = new TexParser_js_1.default(a, parser.stack.env, parser.configuration).mml();\n          var mpadded = parser.create('node', 'mpadded', [nodeA], pad);\n          NodeUtil_js_1.default.setAttribute(mpadded, 'voffset', '.1em');\n          NodeUtil_js_1.default.setChild(mml, mml.over, mpadded);\n        }\n        if (b) {\n          var nodeB = new TexParser_js_1.default(b, parser.stack.env, parser.configuration).mml();\n          NodeUtil_js_1.default.setChild(mml, mml.under, parser.create('node', 'mpadded', [nodeB], pad));\n        }\n        if (parser.configuration.options.amscd.hideHorizontalLabels) {\n          mml = parser.create('node', 'mpadded', mml, {\n            depth: 0,\n            height: '.67em'\n          });\n        }\n      }\n    } else {\n      var arrowNode = parser.create('token', 'mo', vdef, arrow);\n      mml = arrowNode;\n      if (a || b) {\n        mml = parser.create('node', 'mrow');\n        if (a) {\n          NodeUtil_js_1.default.appendChildren(mml, [new TexParser_js_1.default('\\\\scriptstyle\\\\llap{' + a + '}', parser.stack.env, parser.configuration).mml()]);\n        }\n        arrowNode.texClass = MmlNode_js_1.TEXCLASS.ORD;\n        NodeUtil_js_1.default.appendChildren(mml, [arrowNode]);\n        if (b) {\n          NodeUtil_js_1.default.appendChildren(mml, [new TexParser_js_1.default('\\\\scriptstyle\\\\rlap{' + b + '}', parser.stack.env, parser.configuration).mml()]);\n        }\n      }\n    }\n  }\n  if (mml) {\n    parser.Push(mml);\n  }\n  AmsCdMethods.cell(parser, name);\n};\nAmsCdMethods.cell = function (parser, name) {\n  var top = parser.stack.Top();\n  if ((top.table || []).length % 2 === 0 && (top.row || []).length === 0) {\n    parser.Push(parser.create('node', 'mpadded', [], {\n      height: '8.5pt',\n      depth: '2pt'\n    }));\n  }\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isEntry: true,\n    name: name\n  }));\n};\nAmsCdMethods.minCDarrowwidth = function (parser, name) {\n  parser.stack.env.CD_minw = parser.GetDimen(name);\n};\nAmsCdMethods.minCDarrowheight = function (parser, name) {\n  parser.stack.env.CD_minh = parser.GetDimen(name);\n};\nexports.default = AmsCdMethods;","map":{"version":3,"names":["TexParser_js_1","__importDefault","require","BaseConfiguration_js_1","MmlNode_js_1","NodeUtil_js_1","AmsCdMethods","CD","parser","begin","Push","item","itemFactory","create","options","configuration","amscd","setProperties","minw","stack","env","CD_minw","harrowsize","minh","CD_minh","varrowsize","arraydef","columnalign","columnspacing","colspace","rowspacing","rowspace","displaystyle","arrow","name","c","string","charAt","i","match","Other","first","Top","isKind","Size","cell","top","arrowRow","table","length","n","row","mml","hdef","minsize","getProperty","stretchy","vdef","symmetric","lspace","rspace","a","GetUpTo","b","pad","width","nodeA","default","mpadded","setAttribute","setChild","over","nodeB","under","hideHorizontalLabels","depth","height","arrowNode","appendChildren","texClass","TEXCLASS","ORD","isEntry","minCDarrowwidth","GetDimen","minCDarrowheight","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/amscd/AmsCdMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Methods for the AMScd package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport TexParser from '../TexParser.js';\nimport {ParseMethod} from '../Types.js';\nimport {StackItem, EnvList} from '../StackItem.js';\nimport {ArrayItem} from '../base/BaseItems.js';\nimport {Other} from '../base/BaseConfiguration.js';\nimport {MmlMunderover} from '../../../core/MmlTree/MmlNodes/munderover.js';\nimport {TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport NodeUtil from '../NodeUtil.js';\n\n\n// Namespace\nlet AmsCdMethods: Record<string, ParseMethod> = {};\n\n\n/**\n * Handles CD environment for commutative diagrams.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n */\nAmsCdMethods.CD = function(parser: TexParser, begin: StackItem) {\n  parser.Push(begin);\n  let item = parser.itemFactory.create('array') as ArrayItem;\n  let options = parser.configuration.options.amscd;\n  item.setProperties({\n    minw: parser.stack.env.CD_minw || options.harrowsize,\n    minh: parser.stack.env.CD_minh || options.varrowsize\n  });\n  item.arraydef = {\n      columnalign: 'center',\n      columnspacing: options.colspace,\n      rowspacing: options.rowspace,\n      displaystyle: true\n  };\n  return item;\n};\n\n\n/**\n * Converts arrows.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsCdMethods.arrow = function(parser: TexParser, name: string) {\n  let c = parser.string.charAt(parser.i);\n  if (!c.match(/[><VA.|=]/)) {\n    return Other(parser, name);\n  } else {\n    parser.i++;\n  }\n  let first = parser.stack.Top();\n  if (!first.isKind('array') || first.Size()) {\n    AmsCdMethods.cell(parser, name);\n    first = parser.stack.Top();\n  }\n  let top = first as ArrayItem;\n  //\n  //  Add enough cells to place the arrow correctly\n  //\n  let arrowRow = ((top.table.length % 2) === 1);\n  let n = (top.row.length + (arrowRow ? 0 : 1)) % 2;\n  while (n) {\n    AmsCdMethods.cell(parser, name);\n    n--;\n  }\n\n  let mml;\n  let hdef = {minsize: top.getProperty('minw'), stretchy: true},\n  vdef = {minsize: top.getProperty('minh'),\n          stretchy: true, symmetric: true, lspace: 0, rspace: 0};\n\n  if (c === '.') {\n  } else if (c === '|') {\n    mml = parser.create('token', 'mo',  vdef, '\\u2225');\n  } else if (c === '=') {\n    mml = parser.create('token', 'mo', hdef, '=');\n  } else {\n    //\n    //  for @>>> @<<< @VVV and @AAA, get the arrow and labels\n    //\n    // TODO: cleanup!\n    let arrow: string = ({\n      '>': '\\u2192', '<': '\\u2190', 'V': '\\u2193', 'A': '\\u2191'} as {[key: string]: string}) [c];\n    let a = parser.GetUpTo(name + c, c);\n    let b = parser.GetUpTo(name + c, c);\n    if (c === '>' || c === '<') {\n      //\n      //  Lay out horizontal arrows with munderover if it has labels\n      //\n      mml = parser.create('token', 'mo', hdef, arrow);\n      if (!a) {\n        a = '\\\\kern ' + top.getProperty('minw');\n      } // minsize needs work\n      if (a || b) {\n        let pad: EnvList = {width: '+.67em', lspace: '.33em'};\n        mml = parser.create('node', 'munderover', [mml]) as MmlMunderover;\n        if (a) {\n          let nodeA = new TexParser(a, parser.stack.env, parser.configuration).mml();\n          let mpadded = parser.create('node', 'mpadded', [nodeA], pad);\n          NodeUtil.setAttribute(mpadded, 'voffset', '.1em');\n          NodeUtil.setChild(mml, mml.over, mpadded);\n        }\n        if (b) {\n          let nodeB = new TexParser(b, parser.stack.env, parser.configuration).mml();\n          NodeUtil.setChild(mml, mml.under, parser.create('node', 'mpadded', [nodeB], pad));\n        }\n        if (parser.configuration.options.amscd.hideHorizontalLabels) {\n          mml = parser.create('node', 'mpadded', mml, {depth: 0, height: '.67em'});\n        }\n      }\n    } else {\n      //\n      //  Lay out vertical arrows with mrow if there are labels\n      //\n      let arrowNode = parser.create('token', 'mo', vdef, arrow);\n      mml = arrowNode;\n      if (a || b) {\n        mml = parser.create('node', 'mrow');\n        if (a) {\n          NodeUtil.appendChildren(\n            mml, [new TexParser('\\\\scriptstyle\\\\llap{' + a + '}', parser.stack.env, parser.configuration).mml()]);\n        }\n        arrowNode.texClass = TEXCLASS.ORD;\n        NodeUtil.appendChildren(mml, [arrowNode]);\n        if (b) {\n          NodeUtil.appendChildren(mml, [new TexParser('\\\\scriptstyle\\\\rlap{' + b + '}',\n                                                      parser.stack.env, parser.configuration).mml()]);\n        }\n      }\n    }\n  }\n  if (mml) {\n    parser.Push(mml);\n  }\n  AmsCdMethods.cell(parser, name);\n};\n\n\n/**\n * Converts a cell in the diagram.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsCdMethods.cell = function(parser: TexParser, name: string) {\n  let top = parser.stack.Top() as ArrayItem;\n  if ((top.table || []).length % 2 === 0 && (top.row || []).length === 0) {\n    //\n    // Add a strut to the first cell in even rows to get\n    // better spacing of arrow rows.\n    //\n    parser.Push(parser.create('node', 'mpadded', [], {height: '8.5pt', depth: '2pt'}));\n  }\n  parser.Push(parser.itemFactory.create('cell').setProperties({isEntry: true, name: name}));\n};\n\n\n/**\n * Sets minimal width for arrows.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsCdMethods.minCDarrowwidth = function(parser: TexParser, name: string) {\n  parser.stack.env.CD_minw = parser.GetDimen(name);\n};\n\n\n/**\n * Sets minimal height for arrows.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nAmsCdMethods.minCDarrowheight = function(parser: TexParser, name: string) {\n  parser.stack.env.CD_minh = parser.GetDimen(name);\n};\n\n\nexport default AmsCdMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}