{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ParseUtil_js_1 = __importDefault(require(\"./ParseUtil.js\"));\nvar Stack_js_1 = __importDefault(require(\"./Stack.js\"));\nvar TexError_js_1 = __importDefault(require(\"./TexError.js\"));\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar TexParser = function () {\n  function TexParser(_string, env, configuration) {\n    var e_1, _a;\n    this._string = _string;\n    this.configuration = configuration;\n    this.macroCount = 0;\n    this.i = 0;\n    this.currentCS = '';\n    var inner = env.hasOwnProperty('isInner');\n    var isInner = env['isInner'];\n    delete env['isInner'];\n    var ENV;\n    if (env) {\n      ENV = {};\n      try {\n        for (var _b = __values(Object.keys(env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var id = _c.value;\n          ENV[id] = env[id];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    this.configuration.pushParser(this);\n    this.stack = new Stack_js_1.default(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n  Object.defineProperty(TexParser.prototype, \"options\", {\n    get: function () {\n      return this.configuration.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"itemFactory\", {\n    get: function () {\n      return this.configuration.itemFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"tags\", {\n    get: function () {\n      return this.configuration.tags;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"string\", {\n    get: function () {\n      return this._string;\n    },\n    set: function (str) {\n      this._string = str;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TexParser.prototype.parse = function (kind, input) {\n    return this.configuration.handlers.get(kind).parse(input);\n  };\n  TexParser.prototype.lookup = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  };\n  TexParser.prototype.contains = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  };\n  TexParser.prototype.toString = function () {\n    var e_2, _a;\n    var str = '';\n    try {\n      for (var _b = __values(Array.from(this.configuration.handlers.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var config = _c.value;\n        str += config + ': ' + this.configuration.handlers.get(config) + '\\n';\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return str;\n  };\n  TexParser.prototype.Parse = function () {\n    var c;\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  };\n  TexParser.prototype.Push = function (arg) {\n    if (arg instanceof MmlNode_js_1.AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  };\n  TexParser.prototype.PushAll = function (args) {\n    var e_3, _a;\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var arg = args_1_1.value;\n        this.stack.Push(arg);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  TexParser.prototype.mml = function () {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n    var node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  };\n  TexParser.prototype.convertDelimiter = function (c) {\n    var symbol = this.lookup('delimiter', c);\n    return symbol ? symbol.char : null;\n  };\n  TexParser.prototype.getCodePoint = function () {\n    var code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  };\n  TexParser.prototype.nextIsSpace = function () {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  };\n  TexParser.prototype.GetNext = function () {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    return this.getCodePoint();\n  };\n  TexParser.prototype.GetCS = function () {\n    var CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  };\n  TexParser.prototype.GetArgument = function (_name, noneOK) {\n    switch (this.GetNext()) {\n      case '':\n        if (!noneOK) {\n          throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', this.currentCS);\n        }\n        return null;\n      case '}':\n        if (!noneOK) {\n          throw new TexError_js_1.default('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n        }\n        return null;\n      case '\\\\':\n        this.i++;\n        return '\\\\' + this.GetCS();\n      case '{':\n        var j = ++this.i,\n          parens = 1;\n        while (this.i < this.string.length) {\n          switch (this.string.charAt(this.i++)) {\n            case '\\\\':\n              this.i++;\n              break;\n            case '{':\n              parens++;\n              break;\n            case '}':\n              if (--parens === 0) {\n                return this.string.slice(j, this.i - 1);\n              }\n              break;\n          }\n        }\n        throw new TexError_js_1.default('MissingCloseBrace', 'Missing close brace');\n    }\n    var c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  };\n  TexParser.prototype.GetBrackets = function (_name, def) {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n    var j = ++this.i,\n      parens = 0;\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n        case '{':\n          parens++;\n          break;\n        case '\\\\':\n          this.i++;\n          break;\n        case '}':\n          if (parens-- <= 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', '\\']\\'');\n          }\n          break;\n        case ']':\n          if (parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n          break;\n      }\n    }\n    throw new TexError_js_1.default('MissingCloseBracket', 'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  };\n  TexParser.prototype.GetDelimiter = function (name, braceOK) {\n    var c = this.GetNext();\n    this.i += c.length;\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n  TexParser.prototype.GetDimen = function (name) {\n    if (this.GetNext() === '{') {\n      var dimen = this.GetArgument(name);\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dimen), 2),\n        value = _a[0],\n        unit = _a[1];\n      if (value) {\n        return value + unit;\n      }\n    } else {\n      var dimen = this.string.slice(this.i);\n      var _b = __read(ParseUtil_js_1.default.matchDimen(dimen, true), 3),\n        value = _b[0],\n        unit = _b[1],\n        length_1 = _b[2];\n      if (value) {\n        this.i += length_1;\n        return value + unit;\n      }\n    }\n    throw new TexError_js_1.default('MissingDimOrUnits', 'Missing dimension or its units for %1', this.currentCS);\n  };\n  TexParser.prototype.GetUpTo = function (_name, token) {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    var j = this.i;\n    var parens = 0;\n    while (this.i < this.string.length) {\n      var k = this.i;\n      var c = this.GetNext();\n      this.i += c.length;\n      switch (c) {\n        case '\\\\':\n          c += this.GetCS();\n          break;\n        case '{':\n          parens++;\n          break;\n        case '}':\n          if (parens === 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', token);\n          }\n          parens--;\n          break;\n      }\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n    throw new TexError_js_1.default('TokenNotFoundForCommand', 'Could not find %1 for %2', token, this.currentCS);\n  };\n  TexParser.prototype.ParseArg = function (name) {\n    return new TexParser(this.GetArgument(name), this.stack.env, this.configuration).mml();\n  };\n  TexParser.prototype.ParseUpTo = function (name, token) {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env, this.configuration).mml();\n  };\n  TexParser.prototype.GetDelimiterArg = function (name) {\n    var c = ParseUtil_js_1.default.trimSpaces(this.GetArgument(name));\n    if (c === '') {\n      return null;\n    }\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n  TexParser.prototype.GetStar = function () {\n    var star = this.GetNext() === '*';\n    if (star) {\n      this.i++;\n    }\n    return star;\n  };\n  TexParser.prototype.create = function (kind) {\n    var _a;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    return (_a = this.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest), false));\n  };\n  return TexParser;\n}();\nexports.default = TexParser;","map":{"version":3,"names":["ParseUtil_js_1","__importDefault","require","Stack_js_1","TexError_js_1","MmlNode_js_1","TexParser","_string","env","configuration","macroCount","i","currentCS","inner","hasOwnProperty","isInner","ENV","_b","__values","Object","keys","_c","next","done","id","value","pushParser","stack","default","itemFactory","Parse","Push","create","defineProperty","prototype","get","options","tags","set","str","parse","kind","input","handlers","lookup","symbol","contains","toString","Array","from","config","c","string","length","getCodePoint","arg","AbstractMmlNode","isInferred","PushAll","childNodes","args","args_1","args_1_1","mml","Top","isKind","node","First","popParser","convertDelimiter","char","code","codePointAt","undefined","String","fromCodePoint","nextIsSpace","charAt","match","GetNext","GetCS","CS","slice","GetArgument","_name","noneOK","j","parens","GetBrackets","def","GetDelimiter","name","braceOK","trim","GetDimen","dimen","_a","__read","matchDimen","unit","length_1","GetUpTo","token","k","ParseArg","ParseUpTo","GetDelimiterArg","trimSpaces","GetStar","star","rest","_i","arguments","nodeFactory","apply","__spreadArray"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/TexParser.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The TexParser. Implements the basic parsing functionality and\n *     administers the global stack and tree objects.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport ParseUtil from './ParseUtil.js';\nimport {HandlerType} from './MapHandler.js';\nimport Stack from './Stack.js';\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport TexError from './TexError.js';\nimport {MmlNode, AbstractMmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {ParseInput, ParseResult} from './Types.js';\nimport ParseOptions from './ParseOptions.js';\nimport {StackItem, EnvList} from './StackItem.js';\nimport {Symbol} from './Symbol.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n * The main Tex Parser class.\n */\nexport default class TexParser {\n\n  /**\n   * Counter for recursive macros.\n   * @type {number}\n   */\n  public macroCount: number = 0;\n\n  /**\n   * The stack for items and created nodes.\n   * @type {Stack}\n   */\n  public stack: Stack;\n\n  /**\n   * Current position in the string that is parsed.\n   * @type {number}\n   */\n  public i: number = 0;\n\n  /**\n   * The last command sequence\n   * @type {string}\n   */\n  public currentCS: string = '';\n\n  /**\n   * @constructor\n   * @param {string} string The string to parse.\n   * @param {EnvList} env The intial environment representing the current parse\n   *     state of the overall expression translation.\n   * @param {ParseOptions} configuration A parser configuration.\n   */\n  constructor(private _string: string, env: EnvList, public configuration: ParseOptions) {\n    const inner = env.hasOwnProperty('isInner');\n    const isInner = env['isInner'] as boolean;\n    delete env['isInner'];\n    let ENV: EnvList;\n    if (env) {\n      ENV = {};\n      for (const id of Object.keys(env)) {\n        ENV[id] = env[id];\n      }\n    }\n    this.configuration.pushParser(this);\n    this.stack = new Stack(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  /**\n   * @return {OptionList} The configuration options.\n   */\n  get options(): OptionList {\n    return this.configuration.options;\n  }\n\n  /**\n   * @return {StackItemFactory} The factory for stack items.\n   */\n  get itemFactory(): StackItemFactory {\n    return this.configuration.itemFactory;\n  }\n\n  /**\n   * @return {Tags} The tags style of this configuration.\n   */\n  get tags(): Tags {\n    return this.configuration.tags;\n  }\n\n  /**\n   * Sets the string that should be parsed.\n   * @param {string} str The new string to parse.\n   */\n  set string(str: string) {\n    this._string = str;\n  }\n\n  /**\n   * @return {string} The string that is currently parsed.\n   */\n  get string(): string {\n    return this._string;\n  }\n\n\n  /**\n   * Parses the input with the specified kind of map.\n   * @param {HandlerType} kind Configuration name.\n   * @param {ParseInput} input Input to be parsed.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(kind: HandlerType, input: ParseInput): ParseResult {\n    return this.configuration.handlers.get(kind).parse(input);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {any} A boolean, Character, or Macro.\n   */\n  public lookup(kind: HandlerType, symbol: string): any {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of the\n   * specified kind.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the given types of\n   *     symbol mapping.\n   */\n  public contains(kind: HandlerType, symbol: string): boolean {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let str = '';\n    for (const config of Array.from(this.configuration.handlers.keys())) {\n      str += config + ': ' +\n        this.configuration.handlers.get(config as HandlerType) + '\\n';\n    }\n    return str;\n  }\n\n\n  /**\n   * Parses the current input string.\n   */\n  public Parse() {\n    let c: string;\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  }\n\n\n  /**\n   * Pushes a new item onto the stack. The item can also be a Mml node,\n   *   but if the mml item is an inferred row, push its children instead.\n   * @param {StackItem|MmlNode} arg The new item.\n   */\n  public Push(arg: StackItem | MmlNode) {\n    if (arg instanceof AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * Pushes a list of new items onto the stack.\n   * @param {StackItem|MmlNode[]} args The new items.\n   */\n  public PushAll(args: (StackItem | MmlNode)[]) {\n    for (const arg of args) {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * @return {MmlNode} The internal Mathml structure.\n   */\n  public mml(): MmlNode {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n    let node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  }\n\n  /************************************************************************\n   *\n   *   String handling routines\n   */\n\n  /**\n   * Convert delimiter to character.\n   * @param {string} c The delimiter name.\n   * @return {string} The corresponding character.\n   */\n  public convertDelimiter(c: string): string {\n    const symbol = this.lookup('delimiter', c) as Symbol;\n    return symbol ? symbol.char : null;\n  }\n\n  /**\n   * @return {string}   Get the next unicode character in the string\n   */\n  public getCodePoint(): string {\n    const code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  }\n\n  /**\n   * @return {boolean} True if the next character to parse is a space.\n   */\n  public nextIsSpace(): boolean {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  }\n\n  /**\n   * @return {string} Get the next non-space character.\n   */\n  public GetNext(): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    return this.getCodePoint();\n  }\n\n  /**\n   * @return {string} Get and return a control-sequence name\n   */\n  public GetCS(): string {\n    let CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  }\n\n  /**\n   * Get and return a TeX argument (either a single character or control\n   *     sequence, or the contents of the next set of braces).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} noneOK? True if no argument is OK.\n   * @return {string} The next argument.\n   */\n  public GetArgument(_name: string, noneOK?: boolean): string {\n    switch (this.GetNext()) {\n    case '':\n      if (!noneOK) {\n        // @test MissingArgFor\n        throw new TexError('MissingArgFor', 'Missing argument for %1', this.currentCS);\n      }\n      return null;\n    case '}':\n      if (!noneOK) {\n        // @test ExtraCloseMissingOpen\n        throw new TexError('ExtraCloseMissingOpen',\n                            'Extra close brace or missing open brace');\n      }\n      return null;\n    case '\\\\':\n      this.i++;\n      return '\\\\' + this.GetCS();\n    case '{':\n      let j = ++this.i, parens = 1;\n      while (this.i < this.string.length) {\n        switch (this.string.charAt(this.i++)) {\n        case '\\\\':  this.i++; break;\n        case '{':   parens++; break;\n        case '}':\n          if (--parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n          break;\n        }\n      }\n      // @test MissingCloseBrace\n      throw new TexError('MissingCloseBrace', 'Missing close brace');\n    }\n    const c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  }\n\n\n  /**\n   * Get an optional LaTeX argument in brackets.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} def? The default value for the optional argument.\n   * @return {string} The optional argument.\n   */\n  public GetBrackets(_name: string, def?: string): string {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n    let j = ++this.i, parens = 0;\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n      case '{':   parens++; break;\n      case '\\\\':  this.i++; break;\n      case '}':\n        if (parens-- <= 0) {\n          // @test ExtraCloseLooking1\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', '\\']\\'');\n        }\n        break;\n      case ']':\n        if (parens === 0) {\n          return this.string.slice(j, this.i - 1);\n        }\n        break;\n      }\n    }\n    // @test MissingCloseBracket\n    throw new TexError('MissingCloseBracket',\n                        'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  }\n\n  /**\n   *  Get the name of a delimiter (check it in the delimiter list).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} braceOK? Are braces around the delimiter OK.\n   * @return {string} The delimiter name.\n   */\n  public GetDelimiter(name: string, braceOK?: boolean): string {\n    let c = this.GetNext(); this.i += c.length;\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n    // @test MissingOrUnrecognizedDelim1, MissingOrUnrecognizedDelim2\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * Get a dimension (including its units).\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The dimension string.\n   */\n  public GetDimen(name: string): string {\n    if (this.GetNext() === '{') {\n      let dimen = this.GetArgument(name);\n      let [value, unit] = ParseUtil.matchDimen(dimen);\n      if (value) {\n        // @test Raise In Line, Lower 2, (Raise|Lower) Negative\n        return value + unit;\n      }\n    } else {\n      // @test Above, Raise, Lower, Modulo, Above With Delims\n      let dimen = this.string.slice(this.i);\n      let [value, unit, length] = ParseUtil.matchDimen(dimen, true);\n      if (value) {\n        this.i += length;\n        return value + unit;\n      }\n    }\n    // @test MissingDimOrUnits\n    throw new TexError('MissingDimOrUnits',\n                        'Missing dimension or its units for %1', this.currentCS);\n  }\n\n  /**\n   *  Get everything up to the given control sequence (token)\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token The element until where to parse.\n   * @return {string} The text between the current position and the given token.\n   */\n  public GetUpTo(_name: string, token: string): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    let j = this.i;\n    let parens = 0;\n    while (this.i < this.string.length) {\n      let k = this.i;\n      let c = this.GetNext(); this.i += c.length;\n      switch (c) {\n      case '\\\\':  c += this.GetCS(); break;\n      case '{':   parens++; break;\n      case '}':\n        if (parens === 0) {\n          // @test ExtraCloseLooking2\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', token);\n        }\n        parens--;\n        break;\n      }\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n    // @test TokenNotFoundForCommand\n    throw new TexError('TokenNotFoundForCommand',\n                        'Could not find %1 for %2', token, this.currentCS);\n  }\n\n  /**\n   * Parse the arguments of a control sequence in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseArg(name: string): MmlNode  {\n    return new TexParser(this.GetArgument(name), this.stack.env,\n                         this.configuration).mml();\n  }\n\n  /**\n   * Parses a given string up to a given token in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token A Token at which to end parsing.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseUpTo(name: string, token: string): MmlNode {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env,\n                         this.configuration).mml();\n  }\n\n\n  /**\n   * Get a delimiter or empty argument\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The delimiter.\n   */\n  public GetDelimiterArg(name: string): string {\n    let c = ParseUtil.trimSpaces(this.GetArgument(name));\n    if (c === '') {\n      return null;\n    }\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n    // @test MissingOrUnrecognizedDelim\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * @return {boolean} True if a star follows the control sequence name.\n   */\n  public GetStar(): boolean {\n    let star = (this.GetNext() === '*');\n    if (star) {\n      this.i++;\n    }\n    return star;\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory of the current\n   * configuration.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}