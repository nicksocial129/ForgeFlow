{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubHandlers = exports.SubHandler = exports.MapHandler = void 0;\nvar PrioritizedList_js_1 = require(\"../../util/PrioritizedList.js\");\nvar FunctionList_js_1 = require(\"../../util/FunctionList.js\");\nvar MapHandler;\n(function (MapHandler) {\n  var maps = new Map();\n  MapHandler.register = function (map) {\n    maps.set(map.name, map);\n  };\n  MapHandler.getMap = function (name) {\n    return maps.get(name);\n  };\n})(MapHandler = exports.MapHandler || (exports.MapHandler = {}));\nvar SubHandler = function () {\n  function SubHandler() {\n    this._configuration = new PrioritizedList_js_1.PrioritizedList();\n    this._fallback = new FunctionList_js_1.FunctionList();\n  }\n  SubHandler.prototype.add = function (maps, fallback, priority) {\n    var e_1, _a;\n    if (priority === void 0) {\n      priority = PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY;\n    }\n    try {\n      for (var _b = __values(maps.slice().reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        var map = MapHandler.getMap(name_1);\n        if (!map) {\n          this.warn('Configuration ' + name_1 + ' not found! Omitted.');\n          return;\n        }\n        this._configuration.add(map, priority);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    if (fallback) {\n      this._fallback.add(fallback, priority);\n    }\n  };\n  SubHandler.prototype.parse = function (input) {\n    var e_2, _a;\n    try {\n      for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var map = _c.value.item;\n        var result = map.parse(input);\n        if (result) {\n          return result;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    var _d = __read(input, 2),\n      env = _d[0],\n      symbol = _d[1];\n    Array.from(this._fallback)[0].item(env, symbol);\n  };\n  SubHandler.prototype.lookup = function (symbol) {\n    var map = this.applicable(symbol);\n    return map ? map.lookup(symbol) : null;\n  };\n  SubHandler.prototype.contains = function (symbol) {\n    return this.applicable(symbol) ? true : false;\n  };\n  SubHandler.prototype.toString = function () {\n    var e_3, _a;\n    var names = [];\n    try {\n      for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var map = _c.value.item;\n        names.push(map.name);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return names.join(', ');\n  };\n  SubHandler.prototype.applicable = function (symbol) {\n    var e_4, _a;\n    try {\n      for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var map = _c.value.item;\n        if (map.contains(symbol)) {\n          return map;\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    return null;\n  };\n  SubHandler.prototype.retrieve = function (name) {\n    var e_5, _a;\n    try {\n      for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var map = _c.value.item;\n        if (map.name === name) {\n          return map;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return null;\n  };\n  SubHandler.prototype.warn = function (message) {\n    console.log('TexParser Warning: ' + message);\n  };\n  return SubHandler;\n}();\nexports.SubHandler = SubHandler;\nvar SubHandlers = function () {\n  function SubHandlers() {\n    this.map = new Map();\n  }\n  SubHandlers.prototype.add = function (handlers, fallbacks, priority) {\n    var e_6, _a;\n    if (priority === void 0) {\n      priority = PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY;\n    }\n    try {\n      for (var _b = __values(Object.keys(handlers)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        var name_2 = key;\n        var subHandler = this.get(name_2);\n        if (!subHandler) {\n          subHandler = new SubHandler();\n          this.set(name_2, subHandler);\n        }\n        subHandler.add(handlers[name_2], fallbacks[name_2], priority);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n  SubHandlers.prototype.set = function (name, subHandler) {\n    this.map.set(name, subHandler);\n  };\n  SubHandlers.prototype.get = function (name) {\n    return this.map.get(name);\n  };\n  SubHandlers.prototype.retrieve = function (name) {\n    var e_7, _a;\n    try {\n      for (var _b = __values(this.map.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var handler = _c.value;\n        var map = handler.retrieve(name);\n        if (map) {\n          return map;\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n    return null;\n  };\n  SubHandlers.prototype.keys = function () {\n    return this.map.keys();\n  };\n  return SubHandlers;\n}();\nexports.SubHandlers = SubHandlers;","map":{"version":3,"names":["PrioritizedList_js_1","require","FunctionList_js_1","MapHandler","maps","Map","register","map","set","name","getMap","get","exports","SubHandler","_configuration","PrioritizedList","_fallback","FunctionList","prototype","add","fallback","priority","DEFAULTPRIORITY","_b","__values","slice","reverse","_c","next","done","name_1","value","warn","parse","input","item","result","_d","__read","env","symbol","Array","from","lookup","applicable","contains","toString","names","push","join","retrieve","message","console","log","SubHandlers","handlers","fallbacks","Object","keys","key","name_2","subHandler","values","handler"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/MapHandler.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Singleton class for handling symbol maps.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {AbstractSymbolMap, SymbolMap} from './SymbolMap.js';\nimport {ParseInput, ParseResult, ParseMethod} from './Types.js';\n// import {ParserConfiguration} from './Configuration.js';\nimport {PrioritizedList} from '../../util/PrioritizedList.js';\nimport {FunctionList} from '../../util/FunctionList.js';\n\n\nexport type HandlerType = 'delimiter' | 'macro' | 'character' | 'environment';\n\nexport type HandlerConfig = {[P in HandlerType]?: string[]};\nexport type FallbackConfig = {[P in HandlerType]?: ParseMethod};\n\n\nexport namespace MapHandler {\n\n  let maps: Map<string, SymbolMap> = new Map();\n\n  /**\n   * Adds a new symbol map to the map handler. Might overwrite an existing\n   * symbol map of the same name.\n   *\n   * @param {SymbolMap} map Registers a new symbol map.\n   */\n  export let register = function(map: SymbolMap): void {\n    maps.set(map.name, map);\n  };\n\n\n  /**\n   * Looks up a symbol map if it exists.\n   *\n   * @param {string} name The name of the symbol map.\n   * @return {SymbolMap} The symbol map with the given name or null.\n   */\n  export let getMap = function(name: string): SymbolMap {\n    return maps.get(name);\n  };\n\n}\n\n\n/**\n * Class of symbol mappings that are active in a configuration.\n */\nexport class SubHandler {\n\n  private _configuration: PrioritizedList<SymbolMap> = new PrioritizedList<SymbolMap>();\n  private _fallback: FunctionList = new FunctionList();\n\n  /**\n   * Adds a list of symbol maps to the handler.\n   * @param {string[]} maps The names of the symbol maps to add.\n   * @param {ParseMethod} fallback A fallback method.\n   * @param {number} priority Optionally a priority.\n   */\n  public add(maps: string[], fallback: ParseMethod,\n             priority: number = PrioritizedList.DEFAULTPRIORITY) {\n    for (const name of maps.slice().reverse()) {\n      let map = MapHandler.getMap(name);\n      if (!map) {\n        this.warn('Configuration ' + name + ' not found! Omitted.');\n        return;\n      }\n      this._configuration.add(map, priority);\n    }\n    if (fallback) {\n      this._fallback.add(fallback, priority);\n    }\n  }\n\n  /**\n   * Parses the given input with the first applicable symbol map.\n   * @param {ParseInput} input The input for the parser.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(input: ParseInput): ParseResult {\n    for (let {item: map} of this._configuration) {\n      const result = map.parse(input);\n      if (result) {\n        return result;\n      }\n    }\n    let [env, symbol] = input;\n    Array.from(this._fallback)[0].item(env, symbol);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   *\n   * @param {string} symbol The symbol to parse.\n   * @return {T} A boolean, Character, or Macro.\n   */\n  public lookup<T>(symbol: string): T {\n    let map = this.applicable(symbol) as AbstractSymbolMap<T>;\n    return map ? map.lookup(symbol) : null;\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of this\n   * configuration.\n   *\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the mapping.\n   */\n  public contains(symbol: string): boolean {\n    return this.applicable(symbol) ? true : false;\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let names = [];\n    for (let {item: map} of this._configuration) {\n      names.push(map.name);\n    }\n    return names.join(', ');\n  }\n\n\n  /**\n   * Retrieves the first applicable symbol map in the configuration.\n   * @param {string} symbol The symbol to parse.\n   * @return {SymbolMap} A map that can parse the symbol.\n   */\n  public applicable(symbol: string): SymbolMap {\n    for (let {item: map} of this._configuration) {\n      if (map.contains(symbol)) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Retrieves the map of the given name.\n   * @param {string} name Name of the symbol map.\n   * @return {SymbolMap} The map if it exists.\n   */\n  public retrieve(name: string): SymbolMap {\n    for (let {item: map} of this._configuration) {\n      if (map.name === name) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Prints a warning message.\n   * @param {string} message The warning.\n   */\n  private warn(message: string) {\n    console.log('TexParser Warning: ' + message);\n  }\n\n}\n\n\nexport class SubHandlers {\n\n  private map = new Map<HandlerType, SubHandler>();\n\n  /**\n   * Adds a symbol map to the configuration if it exists.\n   * @param {string} name of the symbol map.\n   */\n  public add(handlers: HandlerConfig, fallbacks: FallbackConfig,\n             priority: number = PrioritizedList.DEFAULTPRIORITY): void {\n    for (const key of Object.keys(handlers)) {\n      let name = key as HandlerType;\n      let subHandler = this.get(name);\n      if (!subHandler) {\n        subHandler = new SubHandler();\n        this.set(name, subHandler);\n      }\n      subHandler.add(handlers[name], fallbacks[name], priority);\n    }\n  }\n\n\n  /**\n   * Setter for subhandlers.\n   * @param {HandlerType} name The name of the subhandler.\n   * @param {SubHandler} subHandler The subhandler.\n   */\n  public set(name: HandlerType, subHandler: SubHandler) {\n    this.map.set(name, subHandler);\n  }\n\n\n  /**\n   * Getter for subhandler.\n   * @param {HandlerType} name Name of the subhandler.\n   * @return {SubHandler} The subhandler by that name if it exists.\n   */\n  public get(name: HandlerType): SubHandler {\n    return this.map.get(name);\n  }\n\n\n  /**\n   * Retrieves a symbol map of the given name.\n   * @param {string} name Name of the symbol map.\n   * @return {SymbolMap} The map if it exists. O/w null.\n   */\n  public retrieve(name: string): SymbolMap {\n    for (const handler of this.map.values()) {\n      let map = handler.retrieve(name);\n      if (map) {\n        return map;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * All names of registered subhandlers.\n   * @return {IterableIterator<string>} Iterable list of keys.\n   */\n  public keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}