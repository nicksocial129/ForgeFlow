{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonScriptbaseMixin = void 0;\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nfunction CommonScriptbaseMixin(Base) {\n  var _a;\n  return _a = function (_super) {\n    __extends(class_1, _super);\n    function class_1() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n      _this.baseScale = 1;\n      _this.baseIc = 0;\n      _this.baseRemoveIc = false;\n      _this.baseIsChar = false;\n      _this.baseHasAccentOver = null;\n      _this.baseHasAccentUnder = null;\n      _this.isLineAbove = false;\n      _this.isLineBelow = false;\n      _this.isMathAccent = false;\n      var core = _this.baseCore = _this.getBaseCore();\n      if (!core) return _this;\n      _this.setBaseAccentsFor(core);\n      _this.baseScale = _this.getBaseScale();\n      _this.baseIc = _this.getBaseIc();\n      _this.baseIsChar = _this.isCharBase();\n      _this.isMathAccent = _this.baseIsChar && _this.scriptChild && !!_this.scriptChild.coreMO().node.getProperty('mathaccent');\n      _this.checkLineAccents();\n      _this.baseRemoveIc = !_this.isLineAbove && !_this.isLineBelow && (!_this.constructor.useIC || _this.isMathAccent);\n      return _this;\n    }\n    Object.defineProperty(class_1.prototype, \"baseChild\", {\n      get: function () {\n        return this.childNodes[this.node.base];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(class_1.prototype, \"scriptChild\", {\n      get: function () {\n        return this.childNodes[1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    class_1.prototype.getBaseCore = function () {\n      var core = this.getSemanticBase() || this.childNodes[0];\n      while (core && (core.childNodes.length === 1 && (core.node.isKind('mrow') || core.node.isKind('TeXAtom') && core.node.texClass !== MmlNode_js_1.TEXCLASS.VCENTER || core.node.isKind('mstyle') || core.node.isKind('mpadded') || core.node.isKind('mphantom') || core.node.isKind('semantics')) || core.node.isKind('munderover') && core.isMathAccent)) {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    };\n    class_1.prototype.setBaseAccentsFor = function (core) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    };\n    class_1.prototype.getSemanticBase = function () {\n      var fence = this.node.attributes.getExplicit('data-semantic-fencepointer');\n      return this.getBaseFence(this.baseChild, fence);\n    };\n    class_1.prototype.getBaseFence = function (fence, id) {\n      var e_1, _a;\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      try {\n        for (var _b = __values(fence.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          var result = this.getBaseFence(child, id);\n          if (result) {\n            return result;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return null;\n    };\n    class_1.prototype.getBaseScale = function () {\n      var child = this.baseCore;\n      var scale = 1;\n      while (child && child !== this) {\n        var bbox = child.getOuterBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    };\n    class_1.prototype.getBaseIc = function () {\n      return this.baseCore.getOuterBBox().ic * this.baseScale;\n    };\n    class_1.prototype.getAdjustedIc = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    };\n    class_1.prototype.isCharBase = function () {\n      var base = this.baseCore;\n      return (base.node.isKind('mo') && base.size === null || base.node.isKind('mi') || base.node.isKind('mn')) && base.bbox.rscale === 1 && Array.from(base.getText()).length === 1;\n    };\n    class_1.prototype.checkLineAccents = function () {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        var mml = this;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    };\n    class_1.prototype.isLineAccent = function (script) {\n      var node = script.coreMO().node;\n      return node.isToken && node.getText() === '\\u2015';\n    };\n    class_1.prototype.getBaseWidth = function () {\n      var bbox = this.baseChild.getOuterBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    };\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n      var w = this.getBaseWidth();\n      var _a = __read(this.getOffset(), 2),\n        x = _a[0],\n        y = _a[1];\n      bbox.append(this.baseChild.getOuterBBox());\n      bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    };\n    class_1.prototype.getOffset = function () {\n      return [0, 0];\n    };\n    class_1.prototype.baseCharZero = function (n) {\n      var largeop = !!this.baseCore.node.attributes.get('largeop');\n      var scale = this.baseScale;\n      return this.baseIsChar && !largeop && scale === 1 ? 0 : n;\n    };\n    class_1.prototype.getV = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      var sbox = this.scriptChild.getOuterBBox();\n      var tex = this.font.params;\n      var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - 4 / 5 * tex.x_height);\n    };\n    class_1.prototype.getU = function () {\n      var bbox = this.baseCore.getOuterBBox();\n      var sbox = this.scriptChild.getOuterBBox();\n      var tex = this.font.params;\n      var attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      var prime = this.node.getProperty('texprimestyle');\n      var p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;\n      var superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + 1 / 4 * tex.x_height);\n    };\n    class_1.prototype.hasMovableLimits = function () {\n      var display = this.node.attributes.get('displaystyle');\n      var mo = this.baseChild.coreMO().node;\n      return !display && !!mo.attributes.get('movablelimits');\n    };\n    class_1.prototype.getOverKU = function (basebox, overbox) {\n      var accent = this.node.attributes.get('accent');\n      var tex = this.font.params;\n      var d = overbox.d * overbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentOver ? t : 0;\n      var T = this.isLineAbove ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    };\n    class_1.prototype.getUnderKV = function (basebox, underbox) {\n      var accent = this.node.attributes.get('accentunder');\n      var tex = this.font.params;\n      var h = underbox.h * underbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentUnder ? t : 0;\n      var T = this.isLineBelow ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    };\n    class_1.prototype.getDeltaW = function (boxes, delta) {\n      var e_2, _a, e_3, _b;\n      if (delta === void 0) {\n        delta = [0, 0, 0];\n      }\n      var align = this.node.attributes.get('align');\n      var widths = boxes.map(function (box) {\n        return box.w * box.rscale;\n      });\n      widths[0] -= this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0;\n      var w = Math.max.apply(Math, __spreadArray([], __read(widths), false));\n      var dw = [];\n      var m = 0;\n      try {\n        for (var _c = __values(widths.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var i = _d.value;\n          dw[i] = (align === 'center' ? (w - widths[i]) / 2 : align === 'right' ? w - widths[i] : 0) + delta[i];\n          if (dw[i] < m) {\n            m = -dw[i];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n      if (m) {\n        try {\n          for (var _e = __values(dw.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var i = _f.value;\n            dw[i] += m;\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n      [1, 2].map(function (i) {\n        return dw[i] += boxes[i] ? boxes[i].dx * boxes[0].scale : 0;\n      });\n      return dw;\n    };\n    class_1.prototype.getDelta = function (noskew) {\n      if (noskew === void 0) {\n        noskew = false;\n      }\n      var accent = this.node.attributes.get('accent');\n      var _a = this.baseCore.getOuterBBox(),\n        sk = _a.sk,\n        ic = _a.ic;\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    };\n    class_1.prototype.stretchChildren = function () {\n      var e_4, _a, e_5, _b, e_6, _c;\n      var stretchy = [];\n      try {\n        for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var child = _e.value;\n          if (child.canStretch(2)) {\n            stretchy.push(child);\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n      var count = stretchy.length;\n      var nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        var W = 0;\n        var all = count > 1 && count === nodeCount;\n        try {\n          for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            var noStretch = child.stretch.dir === 0;\n            if (all || noStretch) {\n              var _h = child.getOuterBBox(noStretch),\n                w = _h.w,\n                rscale = _h.rscale;\n              if (w * rscale > W) W = w * rscale;\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n        try {\n          for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {\n            var child = stretchy_1_1.value;\n            child.coreMO().getStretchedVariant([W / child.bbox.rscale]);\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    };\n    return class_1;\n  }(Base), _a.useIC = true, _a;\n}\nexports.CommonScriptbaseMixin = CommonScriptbaseMixin;","map":{"version":3,"names":["MmlNode_js_1","require","CommonScriptbaseMixin","Base","_a","_super","__extends","class_1","args","_i","arguments","length","_this","apply","__spreadArray","__read","baseScale","baseIc","baseRemoveIc","baseIsChar","baseHasAccentOver","baseHasAccentUnder","isLineAbove","isLineBelow","isMathAccent","core","baseCore","getBaseCore","setBaseAccentsFor","getBaseScale","getBaseIc","isCharBase","scriptChild","coreMO","node","getProperty","checkLineAccents","constructor","useIC","Object","defineProperty","prototype","get","childNodes","base","getSemanticBase","isKind","texClass","TEXCLASS","VCENTER","attributes","fence","getExplicit","getBaseFence","baseChild","id","_b","__values","_c","next","done","child","value","result","scale","bbox","getOuterBBox","rscale","parent","ic","getAdjustedIc","size","Array","from","getText","isLineAccent","mml","overChild","underChild","script","isToken","getBaseWidth","w","font","params","extra_ic","computeBBox","recompute","getOffset","x","y","append","combine","scriptspace","clean","setChildPWidths","baseCharZero","n","largeop","getV","sbox","tex","subscriptshift","length2em","sub1","Math","max","d","sub_drop","h","x_height","getU","attr","getList","prime","p","sup3","displaystyle","sup1","sup2","superscriptshift","sup_drop","hasMovableLimits","display","mo","getOverKU","basebox","overbox","accent","t","rule_thickness","separation_factor","delta","T","k","big_op_spacing1","big_op_spacing3","getUnderKV","underbox","big_op_spacing2","big_op_spacing4","getDeltaW","boxes","align","widths","map","box","dw","m","keys","_d","i","_e","_f","dx","getDelta","noskew","sk","skewIcFactor","stretchChildren","stretchy","canStretch","push","count","nodeCount","W","all","_g","noStretch","stretch","dir","_h","stretchy_1","stretchy_1_1","getStretchedVariant","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/output/common/Wrappers/scriptbase.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the a base mixin for CommonMsubsup, CommonMunderover\n *                and their relatives.  (Since munderover can become msubsup\n *                when movablelimits is set, munderover needs to be able to\n *                do the same thing as msubsup in some cases.)\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport {CommonMo} from './mo.js';\nimport {CommonMunderover} from './munderover.js';\nimport {TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMo} from '../../../core/MmlTree/MmlNodes/mo.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {DIRECTION} from '../FontData.js';\n\n/*****************************************************************/\n/**\n * The CommonScriptbase interface\n *\n * @template W  The child-node Wrapper class\n */\nexport interface CommonScriptbase<W extends AnyWrapper> extends AnyWrapper {\n\n  /**\n   * The core mi or mo of the base (or the base itself if there isn't one)\n   */\n  readonly baseCore: W;\n\n  /**\n   * The base element's wrapper\n   */\n  readonly baseChild: W;\n\n  /**\n   * The relative scaling of the base compared to the munderover/msubsup\n   */\n  readonly baseScale: number;\n\n  /**\n   * The italic correction of the base (if any)\n   */\n  readonly baseIc: number;\n\n  /**\n   * True if base italic correction should be removed (msub and msubsup or mathaccents)\n   */\n  readonly baseRemoveIc: boolean;\n\n  /**\n   * True if the base is a single character\n   */\n  readonly baseIsChar: boolean;\n\n  /**\n   * True if the base has an accent under or over\n   */\n  readonly baseHasAccentOver: boolean;\n  readonly baseHasAccentUnder: boolean;\n\n  /**\n   * True if this is an overline or underline\n   */\n  readonly isLineAbove: boolean;\n  readonly isLineBelow: boolean;\n\n  /**\n   * True if this is an msup with script that is a math accent\n   */\n  readonly isMathAccent: boolean;\n\n  /**\n   * The script element's wrapper (overridden in subclasses)\n   */\n  readonly scriptChild: W;\n\n  /***************************************************************************/\n  /*\n   *  Methods for information about the core element for the base\n   */\n\n  /**\n   * @return {W}    The wrapper for the base core mi or mo (or whatever)\n   */\n  getBaseCore(): W;\n\n  /**\n   * @return {W}    The base fence item or null\n   */\n  getSemanticBase(): W;\n\n  /**\n   * Recursively retrieves an element for a given fencepointer.\n   *\n   * @param {W} fence The potential fence.\n   * @param {string} id The fencepointer id.\n   * @return {W} The original fence the scripts belong to.\n   */\n  getBaseFence(fence: W, id: string): W;\n\n  /**\n   * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n   */\n  getBaseScale(): number;\n\n  /**\n   * The base's italic correction (properly scaled)\n   */\n  getBaseIc(): number;\n\n  /**\n   * An adjusted italic correction (for slightly better results)\n   */\n  getAdjustedIc(): number;\n\n  /**\n   * @return {boolean}  True if the base is an mi, mn, or mo (not a largeop) consisting of\n   *                    a single unstretched character\n   */\n  isCharBase(): boolean;\n\n  /**\n   * Determine if the under- and overscripts are under- or overlines.\n   */\n  checkLineAccents(): void;\n\n  /**\n   * @param {W} script   The script node to check for being a line\n   */\n  isLineAccent(script: W): boolean;\n\n  /***************************************************************************/\n  /*\n   *  Methods for sub-sup nodes\n   */\n\n  /**\n   * @return {number}    The base child's width without the base italic correction (if not needed)\n   */\n  getBaseWidth(): number;\n\n  /**\n   * Get the shift for the script (implemented in subclasses)\n   *\n   * @return {number[]}   The horizontal and vertical offsets for the script\n   */\n  getOffset(): number[];\n\n  /**\n   * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n   * @return {number}     Either n or 0\n   */\n  baseCharZero(n: number): number;\n\n  /**\n   * Get the shift for a subscript (TeXBook Appendix G 18ab)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getV(): number;\n\n  /**\n   * Get the shift for a superscript (TeXBook Appendix G 18acd)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getU(): number;\n\n  /***************************************************************************/\n  /*\n   *  Methods for under-over nodes\n   */\n\n  /**\n   * @return {boolean}  True if the base has movablelimits (needed by munderover)\n   */\n  hasMovableLimits(): boolean;\n\n  /**\n   * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox  The bounding box of the base\n   * @param {BBox} overbox  The bounding box of the overscript\n   * @return {number[]}     The separation between their boxes, and the offset of the overscript\n   */\n  getOverKU(basebox: BBox, overbox: BBox): number[];\n\n  /**\n   * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox   The bounding box of the base\n   * @param {BBox} underbox  The bounding box of the underscript\n   * @return {number[]}      The separation between their boxes, and the offset of the underscript\n   */\n  getUnderKV(basebox: BBox, underbox: BBox): number[];\n\n  /**\n   * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n   * @param {number[]=} delta  The initial x offsets of the boxes\n   * @return {number[]}        The actual offsets needed to center the boxes in the stack\n   */\n  getDeltaW(boxes: BBox[], delta?: number[]): number[];\n\n  /**\n   * @param {boolean=} noskew   Whether to ignore the skew amount\n   * @return {number}           The offset for under and over\n   */\n  getDelta(noskew?: boolean): number;\n\n  /**\n   * Handle horizontal stretching of children to match greatest width\n   *  of all children\n   */\n  stretchChildren(): void;\n\n}\n\nexport interface CommonScriptbaseClass extends AnyWrapperClass {\n  /**\n   * Set to true for munderover/munder/mover/msup (Appendix G 13)\n   */\n  useIC: boolean;\n}\n\n/**\n * Shorthand for the CommonScriptbase constructor\n *\n * @template W  The child-node Wrapper class\n */\nexport type ScriptbaseConstructor<W extends AnyWrapper> = Constructor<CommonScriptbase<W>>;\n\n/*****************************************************************/\n/**\n * A base class for msup/msub/msubsup and munder/mover/munderover\n * wrapper mixin implementations\n *\n * @template W  The child-node Wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonScriptbaseMixin<\n  W extends AnyWrapper,\n  T extends WrapperConstructor\n>(Base: T): ScriptbaseConstructor<W> & T {\n\n  return class extends Base {\n\n    /**\n     * Set to false for msubsup/msub (Appendix G 13)\n     */\n    public static useIC: boolean = true;\n\n    /**\n     * The core mi or mo of the base (or the base itself if there isn't one)\n     */\n    public baseCore: W;\n\n    /**\n     * The base element's wrapper\n     */\n    public baseScale: number = 1;\n\n    /**\n     * The relative scaling of the base compared to the munderover/msubsup\n     */\n    public baseIc: number = 0;\n\n    /**\n     * True if base italic correction should be removed (msub and msubsup or mathaccents)\n     */\n    public baseRemoveIc: boolean = false;\n\n    /**\n     * True if the base is a single character\n     */\n    public baseIsChar: boolean = false;\n\n    /**\n     * True if the base has an accent under or over\n     */\n    public baseHasAccentOver: boolean = null;\n    public baseHasAccentUnder: boolean = null;\n\n    /**\n     * True if this is an overline or underline\n     */\n    public isLineAbove: boolean = false;\n    public isLineBelow: boolean = false;\n\n    /**\n     * True if this is an msup with script that is a math accent\n     */\n    public isMathAccent: boolean = false;\n\n    /**\n     * @return {W}  The base element's wrapper\n     */\n    public get baseChild(): W {\n      return this.childNodes[(this.node as MmlMsubsup).base];\n    }\n\n    /**\n     * @return {W}  The script element's wrapper (overridden in subclasses)\n     */\n    public get scriptChild(): W {\n      return this.childNodes[1];\n    }\n\n    /**\n     * @override\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      //\n      //  Find the base core\n      //\n      const core = this.baseCore = this.getBaseCore();\n      if (!core) return;\n      //\n      // Get information about the base element\n      //\n      this.setBaseAccentsFor(core);\n      this.baseScale = this.getBaseScale();\n      this.baseIc = this.getBaseIc();\n      this.baseIsChar = this.isCharBase();\n      //\n      //  Determine if we are setting a mathaccent\n      //\n      this.isMathAccent = this.baseIsChar &&\n        (this.scriptChild && !!this.scriptChild.coreMO().node.getProperty('mathaccent')) as boolean;\n      //\n      // Check for overline/underline accents\n      //\n      this.checkLineAccents();\n      //\n      //  Check if the base is a mi or mo that needs italic correction removed\n      //\n      this.baseRemoveIc = !this.isLineAbove && !this.isLineBelow &&\n        (!(this.constructor as CommonScriptbaseClass).useIC || this.isMathAccent);\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for information about the core element for the base\n     */\n\n    /**\n     * @return {W}    The wrapper for the base core mi or mo (or whatever)\n     */\n    public getBaseCore(): W {\n      let core = this.getSemanticBase() || this.childNodes[0];\n      while (core &&\n             ((core.childNodes.length === 1 &&\n               (core.node.isKind('mrow') ||\n                (core.node.isKind('TeXAtom') && core.node.texClass !== TEXCLASS.VCENTER) ||\n                core.node.isKind('mstyle') || core.node.isKind('mpadded') ||\n                core.node.isKind('mphantom') || core.node.isKind('semantics'))) ||\n              (core.node.isKind('munderover') && core.isMathAccent)))  {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    }\n\n    /**\n     * @param {W} core   The element to check for accents\n     */\n    public setBaseAccentsFor(core: W) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    }\n\n    /**\n     * @return {W}    The base fence item or null\n     */\n    public getSemanticBase(): W {\n      let fence = this.node.attributes.getExplicit('data-semantic-fencepointer') as string;\n      return this.getBaseFence(this.baseChild, fence);\n    }\n\n    /**\n     * Recursively retrieves an element for a given fencepointer.\n     *\n     * @param {W} fence The potential fence.\n     * @param {string} id The fencepointer id.\n     * @return {W} The original fence the scripts belong to.\n     */\n    public getBaseFence(fence: W, id: string): W {\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      for (const child of fence.childNodes) {\n        const result = this.getBaseFence(child, id);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n     */\n    public getBaseScale(): number {\n      let child = this.baseCore as any;\n      let scale = 1;\n      while (child && child !== this) {\n        const bbox = child.getOuterBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    }\n\n    /**\n     * The base's italic correction (properly scaled)\n     */\n    public getBaseIc(): number {\n      return this.baseCore.getOuterBBox().ic * this.baseScale;\n    }\n\n    /**\n     * An adjusted italic correction (for slightly better results)\n     */\n    public getAdjustedIc(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    }\n\n    /**\n     * @return {boolean}  True if the base is an mi, mn, or mo consisting of a single character\n     */\n    public isCharBase(): boolean {\n      let base = this.baseCore;\n      return (((base.node.isKind('mo') && (base as any).size === null) ||\n               base.node.isKind('mi') || base.node.isKind('mn')) &&\n              base.bbox.rscale === 1 && Array.from(base.getText()).length === 1);\n    }\n\n    /**\n     * Determine if the under- and overscripts are under- or overlines.\n     */\n    public checkLineAccents() {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        const mml = this as unknown as CommonMunderover<W>;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    }\n\n    /**\n     * @param {W} script   The script node to check for being a line\n     * @return {boolean}   True if the script is U+2015\n     */\n    public isLineAccent(script: W): boolean {\n      const node = script.coreMO().node;\n      return (node.isToken && (node as MmlMo).getText() === '\\u2015');\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for sub-sup nodes\n     */\n\n    /**\n     * @return {number}    The base child's width without the base italic correction (if not needed)\n     */\n    public getBaseWidth(): number {\n      const bbox = this.baseChild.getOuterBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    }\n\n    /**\n     * This gives the common bbox for msub and msup.  It is overridden\n     * for all the others (msubsup, munder, mover, munderover).\n     *\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      const w = this.getBaseWidth();\n      const [x, y] = this.getOffset();\n      bbox.append(this.baseChild.getOuterBBox());\n      bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * Get the shift for the script (implemented in subclasses)\n     *\n     * @return {[number, number]}   The horizontal and vertical offsets for the script\n     */\n    public getOffset(): [number, number] {\n      return [0, 0];\n    }\n\n    /**\n     * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n     * @return {number}     Either n or 0\n     */\n    public baseCharZero(n: number): number {\n      const largeop = !!this.baseCore.node.attributes.get('largeop');\n      const scale = this.baseScale;\n      return (this.baseIsChar && !largeop && scale === 1 ? 0 : n);\n    }\n\n    /**\n     * Get the shift for a subscript (TeXBook Appendix G 18ab)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getV(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      const sbox = this.scriptChild.getOuterBBox();\n      const tex = this.font.params;\n      const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(\n        this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale),\n        subscriptshift,\n        sbox.h * sbox.rscale - (4 / 5) * tex.x_height\n      );\n    }\n\n    /**\n     * Get the shift for a superscript (TeXBook Appendix G 18acd)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getU(): number {\n      const bbox = this.baseCore.getOuterBBox();\n      const sbox = this.scriptChild.getOuterBBox();\n      const tex = this.font.params;\n      const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      const prime = this.node.getProperty('texprimestyle');\n      const p = prime ? tex.sup3 : (attr.displaystyle ? tex.sup1 : tex.sup2);\n      const superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(\n        this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale),\n        superscriptshift,\n        sbox.d * sbox.rscale + (1 / 4) * tex.x_height\n      );\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for under-over nodes\n     */\n\n    /**\n     * @return {boolean}  True if the base has movablelimits (needed by munderover)\n     */\n    public hasMovableLimits(): boolean {\n      const display = this.node.attributes.get('displaystyle');\n      const mo = this.baseChild.coreMO().node;\n      return (!display && !!mo.attributes.get('movablelimits'));\n    }\n\n    /**\n     * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox  The bounding box of the base\n     * @param {BBox} overbox  The bounding box of the overscript\n     * @return {[number, number]}     The separation between their boxes, and the offset of the overscript\n     */\n    public getOverKU(basebox: BBox, overbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accent') as boolean;\n      const tex = this.font.params;\n      const d = overbox.d * overbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentOver ? t : 0);\n      const T = (this.isLineAbove ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    }\n\n    /**\n     * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox   The bounding box of the base\n     * @param {BBox} underbox  The bounding box of the underscript\n     * @return {[number, number]}      The separation between their boxes, and the offset of the underscript\n     */\n    public getUnderKV(basebox: BBox, underbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accentunder') as boolean;\n      const tex = this.font.params;\n      const h = underbox.h * underbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentUnder ? t : 0);\n      const T = (this.isLineBelow ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    }\n\n    /**\n     * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n     * @param {number[]=} delta  The initial x offsets of the boxes\n     * @return {number[]}        The actual offsets needed to center the boxes in the stack\n     */\n    public getDeltaW(boxes: BBox[], delta: number[] = [0, 0, 0]): number[] {\n      const align = this.node.attributes.get('align');\n      const widths = boxes.map(box => box.w * box.rscale);\n      widths[0] -= (this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0);\n      const w = Math.max(...widths);\n      const dw = [] as number[];\n      let m = 0;\n      for (const i of widths.keys()) {\n        dw[i] = (align === 'center' ? (w - widths[i]) / 2 :\n                 align === 'right' ? w - widths[i] : 0) + delta[i];\n        if (dw[i] < m) {\n          m = -dw[i];\n        }\n      }\n      if (m) {\n        for (const i of dw.keys()) {\n          dw[i] += m;\n        }\n      }\n      [1, 2].map(i => dw[i] += (boxes[i] ? boxes[i].dx * boxes[0].scale : 0));\n      return dw;\n    }\n\n    /**\n     * @param {boolean=} noskew   Whether to ignore the skew amount\n     * @return {number}           The offset for under and over\n     */\n    public getDelta(noskew: boolean = false): number {\n      const accent = this.node.attributes.get('accent');\n      const {sk, ic} = this.baseCore.getOuterBBox();\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    }\n\n    /**\n     * Handle horizontal stretching of children to match greatest width\n     *  of all children\n     */\n    public stretchChildren() {\n      let stretchy: AnyWrapper[] = [];\n      //\n      //  Locate and count the stretchy children\n      //\n      for (const child of this.childNodes) {\n        if (child.canStretch(DIRECTION.Horizontal)) {\n          stretchy.push(child);\n        }\n      }\n      let count = stretchy.length;\n      let nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        let W = 0;\n        //\n        //  If all the children are stretchy, find the largest one,\n        //  otherwise, find the width of the non-stretchy children.\n        //\n        let all = (count > 1 && count === nodeCount);\n        for (const child of this.childNodes) {\n          const noStretch = (child.stretch.dir === DIRECTION.None);\n          if (all || noStretch) {\n            const {w, rscale} = child.getOuterBBox(noStretch);\n            if (w * rscale > W) W = w * rscale;\n          }\n        }\n        //\n        //  Stretch the stretchable children\n        //\n        for (const child of stretchy) {\n          (child.coreMO() as CommonMo).getStretchedVariant([W / child.bbox.rscale]);\n        }\n      }\n    }\n\n  };\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}