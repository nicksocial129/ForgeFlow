{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MathtoolsTagFormat = void 0;\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar Tags_js_1 = require(\"../Tags.js\");\nvar tagID = 0;\nfunction MathtoolsTagFormat(config, jax) {\n  var tags = jax.parseOptions.options.tags;\n  if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {\n    Tags_js_1.TagsFactory.add(tags, config.tags[tags]);\n  }\n  var TagClass = Tags_js_1.TagsFactory.create(jax.parseOptions.options.tags).constructor;\n  var TagFormat = function (_super) {\n    __extends(TagFormat, _super);\n    function TagFormat() {\n      var e_1, _a;\n      var _this = _super.call(this) || this;\n      _this.mtFormats = new Map();\n      _this.mtCurrent = null;\n      var forms = jax.parseOptions.options.mathtools.tagforms;\n      try {\n        for (var _b = __values(Object.keys(forms)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var form = _c.value;\n          if (!Array.isArray(forms[form]) || forms[form].length !== 3) {\n            throw new TexError_js_1.default('InvalidTagFormDef', 'The tag form definition for \"%1\" should be an array fo three strings', form);\n          }\n          _this.mtFormats.set(form, forms[form]);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return _this;\n    }\n    TagFormat.prototype.formatTag = function (tag) {\n      if (this.mtCurrent) {\n        var _a = __read(this.mtCurrent, 3),\n          left = _a[0],\n          right = _a[1],\n          format = _a[2];\n        return format ? \"\".concat(left).concat(format, \"{\").concat(tag, \"}\").concat(right) : \"\".concat(left).concat(tag).concat(right);\n      }\n      return _super.prototype.formatTag.call(this, tag);\n    };\n    return TagFormat;\n  }(TagClass);\n  tagID++;\n  var tagName = 'MathtoolsTags-' + tagID;\n  Tags_js_1.TagsFactory.add(tagName, TagFormat);\n  jax.parseOptions.options.tags = tagName;\n}\nexports.MathtoolsTagFormat = MathtoolsTagFormat;","map":{"version":3,"names":["TexError_js_1","__importDefault","require","Tags_js_1","tagID","MathtoolsTagFormat","config","jax","tags","parseOptions","options","hasOwnProperty","TagsFactory","add","TagClass","create","constructor","TagFormat","_super","__extends","_this","call","mtFormats","Map","mtCurrent","forms","mathtools","tagforms","_b","__values","Object","keys","_c","next","done","form","value","Array","isArray","length","default","set","prototype","formatTag","tag","_a","__read","left","right","format","concat","tagName","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/mathtools/MathtoolsTags.ts"],"sourcesContent":["/*************************************************************\n *  Copyright (c) 2021-2022 MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview    Tags implementation for the mathtools package.\n *\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\nimport TexError from '../TexError.js';\nimport {ParserConfiguration} from '../Configuration.js';\nimport {TeX} from '../../tex.js';\nimport {AbstractTags, TagsFactory} from '../Tags.js';\n\n\n/**\n * The type for the Mathtools tags (including their data).\n */\nexport type MathtoolsTags = AbstractTags & {\n  mtFormats: Map<string, [string, string, string]>;  // name -> [left, right, format]\n  mtCurrent: [string, string, string];               // [left, right, format]\n};\n\n/**\n * The ID number for the current tag class\n */\nlet tagID = 0;\n\n/**\n * Creates and registers a subclass of the currently configured tag class\n * that handles the formats created by the \\newtagform macro.\n */\nexport function MathtoolsTagFormat(config: ParserConfiguration, jax: TeX<any, any, any>) {\n  /**\n   * If the tag format is being added by one of the other extensions,\n   *   as is done for the 'ams' tags, make sure it is defined so we can create it.\n   */\n  const tags = jax.parseOptions.options.tags;\n  if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {\n    TagsFactory.add(tags, config.tags[tags]);\n  }\n\n  /**\n   * The original tag class to be extended (none, ams, or all)\n   */\n  const TagClass = TagsFactory.create(jax.parseOptions.options.tags).constructor as typeof AbstractTags;\n\n  /**\n   * A Tags object that uses \\newtagform to define the formatting\n   */\n  class TagFormat extends TagClass {\n\n    /**\n     * The defined tag formats\n     */\n    public mtFormats: Map<string, [string, string, string]> = new Map();\n\n    /**\n     * The format currently in use ([left, right, format]), or null for using the default\n     */\n    public mtCurrent: [string, string, string] = null;\n\n    /**\n     * @override\n     * @constructor\n     */\n    constructor() {\n      super();\n      const forms = jax.parseOptions.options.mathtools.tagforms;\n      for (const form of Object.keys(forms)) {\n        if (!Array.isArray(forms[form]) || forms[form].length !== 3) {\n          throw new TexError('InvalidTagFormDef',\n                             'The tag form definition for \"%1\" should be an array fo three strings', form);\n        }\n        this.mtFormats.set(form, forms[form]);\n      }\n    }\n\n    /**\n     * @override\n     */\n    public formatTag(tag: string) {\n      if (this.mtCurrent) {\n        const [left, right, format] = this.mtCurrent;\n        return (format ? `${left}${format}{${tag}}${right}` : `${left}${tag}${right}`);\n      }\n      return super.formatTag(tag);\n    }\n  }\n\n  //\n  //  Get a unique name for the tag class (since it is tied to the input jax)\n  //  Note:  These never get freed, so they will accumulate if you create many\n  //  TeX input jax instances with this extension.\n  //\n  tagID++;\n  const tagName = 'MathtoolsTags-' + tagID;\n  //\n  // Register the tag class\n  //\n  TagsFactory.add(tagName, TagFormat);\n  jax.parseOptions.options.tags = tagName;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}