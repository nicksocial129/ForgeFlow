{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MathtoolsMethods = void 0;\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar AmsMethods_js_1 = require(\"../ams/AmsMethods.js\");\nvar BaseMethods_js_1 = __importDefault(require(\"../base/BaseMethods.js\"));\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nvar lengths_js_1 = require(\"../../../util/lengths.js\");\nvar Options_js_1 = require(\"../../../util/Options.js\");\nvar NewcommandUtil_js_1 = __importDefault(require(\"../newcommand/NewcommandUtil.js\"));\nvar NewcommandMethods_js_1 = __importDefault(require(\"../newcommand/NewcommandMethods.js\"));\nvar MathtoolsUtil_js_1 = require(\"./MathtoolsUtil.js\");\nexports.MathtoolsMethods = {\n  MtMatrix: function (parser, begin, open, close) {\n    var align = parser.GetBrackets(\"\\\\begin{\".concat(begin.getName(), \"}\"), 'c');\n    return exports.MathtoolsMethods.Array(parser, begin, open, close, align);\n  },\n  MtSmallMatrix: function (parser, begin, open, close, align) {\n    if (!align) {\n      align = parser.GetBrackets(\"\\\\begin{\".concat(begin.getName(), \"}\"), parser.options.mathtools['smallmatrix-align']);\n    }\n    return exports.MathtoolsMethods.Array(parser, begin, open, close, align, ParseUtil_js_1.default.Em(1 / 3), '.2em', 'S', 1);\n  },\n  MtMultlined: function (parser, begin) {\n    var _a;\n    var name = \"\\\\begin{\".concat(begin.getName(), \"}\");\n    var pos = parser.GetBrackets(name, parser.options.mathtools['multlined-pos'] || 'c');\n    var width = pos ? parser.GetBrackets(name, '') : '';\n    if (pos && !pos.match(/^[cbt]$/)) {\n      _a = __read([pos, width], 2), width = _a[0], pos = _a[1];\n    }\n    parser.Push(begin);\n    var item = parser.itemFactory.create('multlined', parser, begin);\n    item.arraydef = {\n      displaystyle: true,\n      rowspacing: '.5em',\n      width: width || 'auto',\n      columnwidth: '100%'\n    };\n    return ParseUtil_js_1.default.setArrayAlign(item, pos || 'c');\n  },\n  HandleShove: function (parser, name, shove) {\n    var top = parser.stack.Top();\n    if (top.kind !== 'multline' && top.kind !== 'multlined') {\n      throw new TexError_js_1.default('CommandInMultlined', '%1 can only appear within the multline or multlined environments', name);\n    }\n    if (top.Size()) {\n      throw new TexError_js_1.default('CommandAtTheBeginingOfLine', '%1 must come at the beginning of the line', name);\n    }\n    top.setProperty('shove', shove);\n    var shift = parser.GetBrackets(name);\n    var mml = parser.ParseArg(name);\n    if (shift) {\n      var mrow = parser.create('node', 'mrow', []);\n      var mspace = parser.create('node', 'mspace', [], {\n        width: shift\n      });\n      if (shove === 'left') {\n        mrow.appendChild(mspace);\n        mrow.appendChild(mml);\n      } else {\n        mrow.appendChild(mml);\n        mrow.appendChild(mspace);\n      }\n      mml = mrow;\n    }\n    parser.Push(mml);\n  },\n  SpreadLines: function (parser, begin) {\n    var e_1, _a;\n    if (parser.stack.env.closing === begin.getName()) {\n      delete parser.stack.env.closing;\n      var top_1 = parser.stack.Pop();\n      var mml = top_1.toMml();\n      var spread = top_1.getProperty('spread');\n      if (mml.isInferred) {\n        try {\n          for (var _b = __values(NodeUtil_js_1.default.getChildren(mml)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var child = _c.value;\n            MathtoolsUtil_js_1.MathtoolsUtil.spreadLines(child, spread);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else {\n        MathtoolsUtil_js_1.MathtoolsUtil.spreadLines(mml, spread);\n      }\n      parser.Push(mml);\n    } else {\n      var spread = parser.GetDimen(\"\\\\begin{\".concat(begin.getName(), \"}\"));\n      begin.setProperty('spread', spread);\n      parser.Push(begin);\n    }\n  },\n  Cases: function (parser, begin, open, close, style) {\n    var array = parser.itemFactory.create('array').setProperty('casesEnv', begin.getName());\n    array.arraydef = {\n      rowspacing: '.2em',\n      columnspacing: '1em',\n      columnalign: 'left'\n    };\n    if (style === 'D') {\n      array.arraydef.displaystyle = true;\n    }\n    array.setProperties({\n      open: open,\n      close: close\n    });\n    parser.Push(begin);\n    return array;\n  },\n  MathLap: function (parser, name, pos, cramped) {\n    var style = parser.GetBrackets(name, '').trim();\n    var mml = parser.create('node', 'mstyle', [parser.create('node', 'mpadded', [parser.ParseArg(name)], __assign({\n      width: 0\n    }, pos === 'r' ? {} : {\n      lspace: pos === 'l' ? '-1width' : '-.5width'\n    }))], {\n      'data-cramped': cramped\n    });\n    MathtoolsUtil_js_1.MathtoolsUtil.setDisplayLevel(mml, style);\n    parser.Push(parser.create('node', 'TeXAtom', [mml]));\n  },\n  Cramped: function (parser, name) {\n    var style = parser.GetBrackets(name, '').trim();\n    var arg = parser.ParseArg(name);\n    var mml = parser.create('node', 'mstyle', [arg], {\n      'data-cramped': true\n    });\n    MathtoolsUtil_js_1.MathtoolsUtil.setDisplayLevel(mml, style);\n    parser.Push(mml);\n  },\n  MtLap: function (parser, name, pos) {\n    var content = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), 0);\n    var mml = parser.create('node', 'mpadded', content, {\n      width: 0\n    });\n    if (pos !== 'r') {\n      NodeUtil_js_1.default.setAttribute(mml, 'lspace', pos === 'l' ? '-1width' : '-.5width');\n    }\n    parser.Push(mml);\n  },\n  MathMakeBox: function (parser, name) {\n    var width = parser.GetBrackets(name);\n    var pos = parser.GetBrackets(name, 'c');\n    var mml = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n    if (width) {\n      NodeUtil_js_1.default.setAttribute(mml, 'width', width);\n    }\n    var align = (0, Options_js_1.lookup)(pos, {\n      c: 'center',\n      r: 'right'\n    }, '');\n    if (align) {\n      NodeUtil_js_1.default.setAttribute(mml, 'data-align', align);\n    }\n    parser.Push(mml);\n  },\n  MathMBox: function (parser, name) {\n    parser.Push(parser.create('node', 'mrow', [parser.ParseArg(name)]));\n  },\n  UnderOverBracket: function (parser, name) {\n    var thickness = (0, lengths_js_1.length2em)(parser.GetBrackets(name, '.1em'), .1);\n    var height = parser.GetBrackets(name, '.2em');\n    var arg = parser.GetArgument(name);\n    var _a = __read(name.charAt(1) === 'o' ? ['over', 'accent', 'bottom'] : ['under', 'accentunder', 'top'], 3),\n      pos = _a[0],\n      accent = _a[1],\n      border = _a[2];\n    var t = (0, lengths_js_1.em)(thickness);\n    var base = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n    var copy = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n    var script = parser.create('node', 'mpadded', [parser.create('node', 'mphantom', [copy])], {\n      style: \"border: \".concat(t, \" solid; border-\").concat(border, \": none\"),\n      height: height,\n      depth: 0\n    });\n    var node = ParseUtil_js_1.default.underOver(parser, base, script, pos, true);\n    var munderover = NodeUtil_js_1.default.getChildAt(NodeUtil_js_1.default.getChildAt(node, 0), 0);\n    NodeUtil_js_1.default.setAttribute(munderover, accent, true);\n    parser.Push(node);\n  },\n  Aboxed: function (parser, name) {\n    var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);\n    if (top.row.length % 2 === 1) {\n      top.row.push(parser.create('node', 'mtd', []));\n    }\n    var arg = parser.GetArgument(name);\n    var rest = parser.string.substr(parser.i);\n    parser.string = arg + '&&\\\\endAboxed';\n    parser.i = 0;\n    var left = parser.GetUpTo(name, '&');\n    var right = parser.GetUpTo(name, '&');\n    parser.GetUpTo(name, '\\\\endAboxed');\n    var tex = ParseUtil_js_1.default.substituteArgs(parser, [left, right], '\\\\rlap{\\\\boxed{#1{}#2}}\\\\kern.267em\\\\phantom{#1}&\\\\phantom{{}#2}\\\\kern.267em');\n    parser.string = tex + rest;\n    parser.i = 0;\n  },\n  ArrowBetweenLines: function (parser, name) {\n    var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);\n    if (top.Size() || top.row.length) {\n      throw new TexError_js_1.default('BetweenLines', '%1 must be on a row by itself', name);\n    }\n    var star = parser.GetStar();\n    var symbol = parser.GetBrackets(name, '\\\\Updownarrow');\n    if (star) {\n      top.EndEntry();\n      top.EndEntry();\n    }\n    var tex = star ? '\\\\quad' + symbol : symbol + '\\\\quad';\n    var mml = new TexParser_js_1.default(tex, parser.stack.env, parser.configuration).mml();\n    parser.Push(mml);\n    top.EndEntry();\n    top.EndRow();\n  },\n  VDotsWithin: function (parser, name) {\n    var top = parser.stack.Top();\n    var isFlush = top.getProperty('flushspaceabove') === top.table.length;\n    var arg = '\\\\mmlToken{mi}{}' + parser.GetArgument(name) + '\\\\mmlToken{mi}{}';\n    var base = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n    var mml = parser.create('node', 'mpadded', [parser.create('node', 'mpadded', [parser.create('node', 'mo', [parser.create('text', '\\u22EE')])], __assign({\n      width: 0,\n      lspace: '-.5width'\n    }, isFlush ? {\n      height: '-.6em',\n      voffset: '-.18em'\n    } : {})), parser.create('node', 'mphantom', [base])], {\n      lspace: '.5width'\n    });\n    parser.Push(mml);\n  },\n  ShortVDotsWithin: function (parser, _name) {\n    var top = parser.stack.Top();\n    var star = parser.GetStar();\n    exports.MathtoolsMethods.FlushSpaceAbove(parser, '\\\\MTFlushSpaceAbove');\n    !star && top.EndEntry();\n    exports.MathtoolsMethods.VDotsWithin(parser, '\\\\vdotswithin');\n    star && top.EndEntry();\n    exports.MathtoolsMethods.FlushSpaceBelow(parser, '\\\\MTFlushSpaceBelow');\n  },\n  FlushSpaceAbove: function (parser, name) {\n    var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);\n    top.setProperty('flushspaceabove', top.table.length);\n    top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustabove']);\n  },\n  FlushSpaceBelow: function (parser, name) {\n    var top = MathtoolsUtil_js_1.MathtoolsUtil.checkAlignment(parser, name);\n    top.Size() && top.EndEntry();\n    top.EndRow();\n    top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustbelow']);\n  },\n  PairedDelimiters: function (parser, name, open, close, body, n, pre, post) {\n    if (body === void 0) {\n      body = '#1';\n    }\n    if (n === void 0) {\n      n = 1;\n    }\n    if (pre === void 0) {\n      pre = '';\n    }\n    if (post === void 0) {\n      post = '';\n    }\n    var star = parser.GetStar();\n    var size = star ? '' : parser.GetBrackets(name);\n    var _a = __read(star ? ['\\\\left', '\\\\right'] : size ? [size + 'l', size + 'r'] : ['', ''], 2),\n      left = _a[0],\n      right = _a[1];\n    var delim = star ? '\\\\middle' : size || '';\n    if (n) {\n      var args = [];\n      for (var i = args.length; i < n; i++) {\n        args.push(parser.GetArgument(name));\n      }\n      pre = ParseUtil_js_1.default.substituteArgs(parser, args, pre);\n      body = ParseUtil_js_1.default.substituteArgs(parser, args, body);\n      post = ParseUtil_js_1.default.substituteArgs(parser, args, post);\n    }\n    body = body.replace(/\\\\delimsize/g, delim);\n    parser.string = [pre, left, open, body, right, close, post, parser.string.substr(parser.i)].reduce(function (s, part) {\n      return ParseUtil_js_1.default.addArgs(parser, s, part);\n    }, '');\n    parser.i = 0;\n    ParseUtil_js_1.default.checkMaxMacros(parser);\n  },\n  DeclarePairedDelimiter: function (parser, name) {\n    var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);\n    var open = parser.GetArgument(name);\n    var close = parser.GetArgument(name);\n    MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close]);\n  },\n  DeclarePairedDelimiterX: function (parser, name) {\n    var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);\n    var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);\n    var open = parser.GetArgument(name);\n    var close = parser.GetArgument(name);\n    var body = parser.GetArgument(name);\n    MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n]);\n  },\n  DeclarePairedDelimiterXPP: function (parser, name) {\n    var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);\n    var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);\n    var pre = parser.GetArgument(name);\n    var open = parser.GetArgument(name);\n    var close = parser.GetArgument(name);\n    var post = parser.GetArgument(name);\n    var body = parser.GetArgument(name);\n    MathtoolsUtil_js_1.MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n, pre, post]);\n  },\n  CenterColon: function (parser, _name, center, force, thin) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (thin === void 0) {\n      thin = false;\n    }\n    var options = parser.options.mathtools;\n    var mml = parser.create('token', 'mo', {}, ':');\n    if (center && (options['centercolon'] || force)) {\n      var dy = options['centercolon-offset'];\n      mml = parser.create('node', 'mpadded', [mml], __assign({\n        voffset: dy,\n        height: \"+\".concat(dy),\n        depth: \"-\".concat(dy)\n      }, thin ? {\n        width: options['thincolon-dw'],\n        lspace: options['thincolon-dx']\n      } : {}));\n    }\n    parser.Push(mml);\n  },\n  Relation: function (parser, _name, tex, unicode) {\n    var options = parser.options.mathtools;\n    if (options['use-unicode'] && unicode) {\n      parser.Push(parser.create('token', 'mo', {\n        texClass: MmlNode_js_1.TEXCLASS.REL\n      }, unicode));\n    } else {\n      tex = '\\\\mathrel{' + tex.replace(/:/g, '\\\\MTThinColon').replace(/-/g, '\\\\mathrel{-}') + '}';\n      parser.string = ParseUtil_js_1.default.addArgs(parser, tex, parser.string.substr(parser.i));\n      parser.i = 0;\n    }\n  },\n  NArrow: function (parser, _name, c, dy) {\n    parser.Push(parser.create('node', 'TeXAtom', [parser.create('token', 'mtext', {}, c), parser.create('node', 'mpadded', [parser.create('node', 'mpadded', [parser.create('node', 'menclose', [parser.create('node', 'mspace', [], {\n      height: '.2em',\n      depth: 0,\n      width: '.4em'\n    })], {\n      notation: 'updiagonalstrike',\n      'data-thickness': '.05em',\n      'data-padding': 0\n    })], {\n      width: 0,\n      lspace: '-.5width',\n      voffset: dy\n    }), parser.create('node', 'mphantom', [parser.create('token', 'mtext', {}, c)])], {\n      width: 0,\n      lspace: '-.5width'\n    })], {\n      texClass: MmlNode_js_1.TEXCLASS.REL\n    }));\n  },\n  SplitFrac: function (parser, name, display) {\n    var num = parser.ParseArg(name);\n    var den = parser.ParseArg(name);\n    parser.Push(parser.create('node', 'mstyle', [parser.create('node', 'mfrac', [parser.create('node', 'mstyle', [num, parser.create('token', 'mi'), parser.create('token', 'mspace', {\n      width: '1em'\n    })], {\n      scriptlevel: 0\n    }), parser.create('node', 'mstyle', [parser.create('token', 'mspace', {\n      width: '1em'\n    }), parser.create('token', 'mi'), den], {\n      scriptlevel: 0\n    })], {\n      linethickness: 0,\n      numalign: 'left',\n      denomalign: 'right'\n    })], {\n      displaystyle: display,\n      scriptlevel: 0\n    }));\n  },\n  XMathStrut: function (parser, name) {\n    var dd = parser.GetBrackets(name);\n    var dh = parser.GetArgument(name);\n    dh = MathtoolsUtil_js_1.MathtoolsUtil.plusOrMinus(name, dh);\n    dd = MathtoolsUtil_js_1.MathtoolsUtil.plusOrMinus(name, dd || dh);\n    parser.Push(parser.create('node', 'TeXAtom', [parser.create('node', 'mpadded', [parser.create('node', 'mphantom', [parser.create('token', 'mo', {\n      stretchy: false\n    }, '(')])], {\n      width: 0,\n      height: dh + 'height',\n      depth: dd + 'depth'\n    })], {\n      texClass: MmlNode_js_1.TEXCLASS.ORD\n    }));\n  },\n  Prescript: function (parser, name) {\n    var sup = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'sup');\n    var sub = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'sub');\n    var base = MathtoolsUtil_js_1.MathtoolsUtil.getScript(parser, name, 'arg');\n    if (NodeUtil_js_1.default.isType(sup, 'none') && NodeUtil_js_1.default.isType(sub, 'none')) {\n      parser.Push(base);\n      return;\n    }\n    var mml = parser.create('node', 'mmultiscripts', [base]);\n    NodeUtil_js_1.default.getChildren(mml).push(null, null);\n    NodeUtil_js_1.default.appendChildren(mml, [parser.create('node', 'mprescripts'), sub, sup]);\n    mml.setProperty('fixPrescript', true);\n    parser.Push(mml);\n  },\n  NewTagForm: function (parser, name, renew) {\n    if (renew === void 0) {\n      renew = false;\n    }\n    var tags = parser.tags;\n    if (!('mtFormats' in tags)) {\n      throw new TexError_js_1.default('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);\n    }\n    var id = parser.GetArgument(name).trim();\n    if (!id) {\n      throw new TexError_js_1.default('InvalidTagFormID', 'Tag form name can\\'t be empty');\n    }\n    var format = parser.GetBrackets(name, '');\n    var left = parser.GetArgument(name);\n    var right = parser.GetArgument(name);\n    if (!renew && tags.mtFormats.has(id)) {\n      throw new TexError_js_1.default('DuplicateTagForm', 'Duplicate tag form: %1', id);\n    }\n    tags.mtFormats.set(id, [left, right, format]);\n  },\n  UseTagForm: function (parser, name) {\n    var tags = parser.tags;\n    if (!('mtFormats' in tags)) {\n      throw new TexError_js_1.default('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);\n    }\n    var id = parser.GetArgument(name).trim();\n    if (!id) {\n      tags.mtCurrent = null;\n      return;\n    }\n    if (!tags.mtFormats.has(id)) {\n      throw new TexError_js_1.default('UndefinedTagForm', 'Undefined tag form: %1', id);\n    }\n    tags.mtCurrent = tags.mtFormats.get(id);\n  },\n  SetOptions: function (parser, name) {\n    var e_2, _a;\n    var options = parser.options.mathtools;\n    if (!options['allow-mathtoolsset']) {\n      throw new TexError_js_1.default('ForbiddenMathtoolsSet', '%1 is disabled', name);\n    }\n    var allowed = {};\n    Object.keys(options).forEach(function (id) {\n      if (id !== 'pariedDelimiters' && id !== 'tagforms' && id !== 'allow-mathtoolsset') {\n        allowed[id] = 1;\n      }\n    });\n    var args = parser.GetArgument(name);\n    var keys = ParseUtil_js_1.default.keyvalOptions(args, allowed, true);\n    try {\n      for (var _b = __values(Object.keys(keys)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var id = _c.value;\n        options[id] = keys[id];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  },\n  Array: BaseMethods_js_1.default.Array,\n  Macro: BaseMethods_js_1.default.Macro,\n  xArrow: AmsMethods_js_1.AmsMethods.xArrow,\n  HandleRef: AmsMethods_js_1.AmsMethods.HandleRef,\n  AmsEqnArray: AmsMethods_js_1.AmsMethods.AmsEqnArray,\n  MacroWithTemplate: NewcommandMethods_js_1.default.MacroWithTemplate\n};","map":{"version":3,"names":["ParseUtil_js_1","__importDefault","require","AmsMethods_js_1","BaseMethods_js_1","TexParser_js_1","TexError_js_1","NodeUtil_js_1","MmlNode_js_1","lengths_js_1","Options_js_1","NewcommandUtil_js_1","NewcommandMethods_js_1","MathtoolsUtil_js_1","exports","MathtoolsMethods","MtMatrix","parser","begin","open","close","align","GetBrackets","concat","getName","Array","MtSmallMatrix","options","mathtools","default","Em","MtMultlined","name","pos","width","match","_a","__read","Push","item","itemFactory","create","arraydef","displaystyle","rowspacing","columnwidth","setArrayAlign","HandleShove","shove","top","stack","Top","kind","Size","setProperty","shift","mml","ParseArg","mrow","mspace","appendChild","SpreadLines","env","closing","top_1","Pop","toMml","spread","getProperty","isInferred","_b","__values","getChildren","_c","next","done","child","value","MathtoolsUtil","spreadLines","GetDimen","Cases","style","array","columnspacing","columnalign","setProperties","MathLap","cramped","trim","__assign","lspace","setDisplayLevel","Cramped","arg","MtLap","content","internalMath","GetArgument","setAttribute","MathMakeBox","lookup","c","r","MathMBox","UnderOverBracket","thickness","length2em","height","charAt","accent","border","t","em","base","configuration","copy","script","depth","node","underOver","munderover","getChildAt","Aboxed","checkAlignment","row","length","push","rest","string","substr","i","left","GetUpTo","right","tex","substituteArgs","ArrowBetweenLines","star","GetStar","symbol","EndEntry","EndRow","VDotsWithin","isFlush","table","voffset","ShortVDotsWithin","_name","FlushSpaceAbove","FlushSpaceBelow","addRowSpacing","PairedDelimiters","body","n","pre","post","size","delim","args","replace","reduce","s","part","addArgs","checkMaxMacros","DeclarePairedDelimiter","cs","GetCsNameArgument","addPairedDelims","DeclarePairedDelimiterX","GetArgCount","DeclarePairedDelimiterXPP","CenterColon","center","force","thin","dy","Relation","unicode","texClass","TEXCLASS","REL","NArrow","notation","SplitFrac","display","num","den","scriptlevel","linethickness","numalign","denomalign","XMathStrut","dd","dh","plusOrMinus","stretchy","ORD","Prescript","sup","getScript","sub","isType","appendChildren","NewTagForm","renew","tags","id","format","mtFormats","has","set","UseTagForm","mtCurrent","get","SetOptions","allowed","Object","keys","forEach","keyvalOptions","Macro","xArrow","AmsMethods","HandleRef","AmsEqnArray","MacroWithTemplate"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/mathtools/MathtoolsMethods.ts"],"sourcesContent":["/*************************************************************\n *  Copyright (c) 2020-2022 MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview    Macro and environment implementations for the mathtools package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\n\nimport {ArrayItem, EqnArrayItem} from '../base/BaseItems.js';\nimport {StackItem} from '../StackItem.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {ParseMethod, ParseResult} from '../Types.js';\nimport {AmsMethods} from '../ams/AmsMethods.js';\nimport BaseMethods from '../base/BaseMethods.js';\nimport TexParser from '../TexParser.js';\nimport TexError from '../TexError.js';\nimport NodeUtil from '../NodeUtil.js';\nimport {TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {length2em, em} from '../../../util/lengths.js';\nimport {lookup} from '../../../util/Options.js';\nimport NewcommandUtil from '../newcommand/NewcommandUtil.js';\nimport NewcommandMethods from '../newcommand/NewcommandMethods.js';\n\nimport {MathtoolsTags} from './MathtoolsTags.js';\nimport {MathtoolsUtil} from './MathtoolsUtil.js';\n\n/**\n * The implementations for the macros and environments for the mathtools package.\n */\nexport const MathtoolsMethods: Record<string, ParseMethod> = {\n\n  /**\n   * Handle a mathtools matrix environment, with optional alignment.\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {StackItem} begin    The BeginItem for the environment.\n   * @param {string} open        The open delimiter for the matrix.\n   * @param {string} close       The close delimiter for the matrix.\n   * @return {ParserResult}      The ArrayItem for the matrix.\n   */\n  MtMatrix(parser: TexParser, begin: StackItem, open: string, close: string): ParseResult {\n    const align = parser.GetBrackets(`\\\\begin{${begin.getName()}}`, 'c');\n    return MathtoolsMethods.Array(parser, begin, open, close, align);\n  },\n\n  /**\n   * Create a smallmatrix with given delimiters, and with optional alignment (and settable default)\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {StackItem} begin    The BeginItem for the environment.\n   * @param {string} open        The open delimiter for the matrix.\n   * @param {string} close       The close delimiter for the matrix.\n   * @param {string} align       The (optional) alignment.  If not given, use a bracket argument for it.\n   * @return {ParseResult}       The ArrayItem for the matrix.\n   */\n  MtSmallMatrix(parser: TexParser, begin: StackItem, open: string, close: string, align?: string): ParseResult {\n    if (!align) {\n      align = parser.GetBrackets(`\\\\begin{${begin.getName()}}`, parser.options.mathtools['smallmatrix-align']);\n    }\n    return MathtoolsMethods.Array(\n      parser, begin, open, close, align, ParseUtil.Em(1 / 3), '.2em', 'S', 1\n    );\n  },\n\n  /**\n   * Create the multlined StackItem.\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {StackItem} begin    The BeginItem for the environment.\n   * @return {ParseResult}       The MultlinedItem.\n   */\n  MtMultlined(parser: TexParser, begin: StackItem): ParseResult {\n    const name = `\\\\begin{${begin.getName()}}`;\n    let pos = parser.GetBrackets(name, parser.options.mathtools['multlined-pos'] || 'c');\n    let width = pos ? parser.GetBrackets(name, '') : '';\n    if (pos && !pos.match(/^[cbt]$/)) {\n      [width, pos] = [pos, width];\n    }\n    parser.Push(begin);\n    const item = parser.itemFactory.create('multlined', parser, begin) as ArrayItem;\n    item.arraydef = {\n      displaystyle: true,\n      rowspacing: '.5em',\n      width: width || 'auto',\n      columnwidth: '100%',\n    };\n    return ParseUtil.setArrayAlign(item as ArrayItem, pos || 'c');\n  },\n\n  /**\n   * Replacement for the AMS HandleShove that includes optional spacing values\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {string} name        The name of the calling macro.\n   * @param {string} shove       Which way to shove the result.\n   */\n  HandleShove(parser: TexParser, name: string, shove: string) {\n    let top = parser.stack.Top();\n    if (top.kind !== 'multline' && top.kind !== 'multlined') {\n      throw new TexError(\n        'CommandInMultlined',\n        '%1 can only appear within the multline or multlined environments',\n        name);\n    }\n    if (top.Size()) {\n      throw new TexError(\n        'CommandAtTheBeginingOfLine',\n        '%1 must come at the beginning of the line',\n        name);\n    }\n    top.setProperty('shove', shove);\n    let shift = parser.GetBrackets(name);\n    let mml = parser.ParseArg(name);\n    if (shift) {\n      let mrow = parser.create('node', 'mrow', []);\n      let mspace = parser.create('node', 'mspace', [], {width: shift});\n      if (shove === 'left') {\n        mrow.appendChild(mspace);\n        mrow.appendChild(mml);\n      } else {\n        mrow.appendChild(mml);\n        mrow.appendChild(mspace);\n      }\n      mml = mrow;\n    }\n    parser.Push(mml);\n  },\n\n  /**\n   * Handle the spreadlines environment.\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {StackItem} begin    The BeginItem for the environment.\n   */\n  SpreadLines(parser: TexParser, begin: StackItem) {\n    if (parser.stack.env.closing === begin.getName()) {\n      //\n      //  When the environment ends, look through the contents and\n      //  adjust the spacing in any tables, then push the results.\n      //\n      delete parser.stack.env.closing;\n      const top = parser.stack.Pop();\n      const mml = top.toMml();\n      const spread = top.getProperty('spread') as string;\n      if (mml.isInferred) {\n        for (const child of NodeUtil.getChildren(mml)) {\n          MathtoolsUtil.spreadLines(child, spread);\n        }\n      } else {\n        MathtoolsUtil.spreadLines(mml, spread);\n      }\n      parser.Push(mml);\n    } else {\n      //\n      //  Read the spread dimension and save it, then begin the environment.\n      //\n      const spread = parser.GetDimen(`\\\\begin{${begin.getName()}}`);\n      begin.setProperty('spread', spread);\n      parser.Push(begin);\n    }\n  },\n\n  /**\n   * Implements the various cases environments.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {StackItem} begin    The BeginItem for the environment.\n   * @param {string} open        The open delimiter for the matrix.\n   * @param {string} close       The close delimiter for the matrix.\n   * @param {string} style       The style (D, T, S, SS) for the contents of the array\n   * @return {ArrayItem}         The ArrayItem for the environment\n   */\n  Cases(parser: TexParser, begin: StackItem, open: string, close: string, style: string): ArrayItem {\n    const array = parser.itemFactory.create('array').setProperty('casesEnv', begin.getName()) as ArrayItem;\n    array.arraydef = {\n      rowspacing: '.2em',\n      columnspacing: '1em',\n      columnalign: 'left'\n    };\n    if (style === 'D') {\n      array.arraydef.displaystyle = true;\n    }\n    array.setProperties({open, close});\n    parser.Push(begin);\n    return array;\n  },\n\n  /**\n   * Handle \\mathrlap, \\mathllap, \\mathclap, and their cramped versions.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {string} pos         The position (l, c, r) of the lapped content\n   * @param {boolean} cramped    True if the style should be cramped\n   */\n  MathLap(parser: TexParser, name: string, pos: string, cramped: boolean) {\n    const style = parser.GetBrackets(name, '').trim();\n    let mml = parser.create('node', 'mstyle', [\n      parser.create('node', 'mpadded', [parser.ParseArg(name)], {\n        width: 0, ...(pos === 'r' ? {} : {lspace: (pos === 'l' ? '-1width' : '-.5width')})\n      })\n    ], {'data-cramped': cramped});\n    MathtoolsUtil.setDisplayLevel(mml, style);\n    parser.Push(parser.create('node', 'TeXAtom', [mml]));\n  },\n\n  /**\n   * Implements \\cramped.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  Cramped(parser: TexParser, name: string) {\n    const style = parser.GetBrackets(name, '').trim();\n    const arg = parser.ParseArg(name);\n    const mml = parser.create('node', 'mstyle', [arg], {'data-cramped': true});\n    MathtoolsUtil.setDisplayLevel(mml, style);\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\clap (and could do \\llap and \\rlap, where the contents are text mode).\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {string} pos         The position (l, c, r) of the lapped content\n   */\n  MtLap(parser: TexParser, name: string, pos: string) {\n    const content = ParseUtil.internalMath(parser, parser.GetArgument(name), 0);\n    let mml = parser.create('node', 'mpadded', content, {width: 0});\n    if (pos !== 'r') {\n      NodeUtil.setAttribute(mml, 'lspace', pos === 'l' ? '-1width' : '-.5width');\n    }\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\mathmakebox.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  MathMakeBox(parser: TexParser, name: string) {\n    const width = parser.GetBrackets(name);\n    const pos = parser.GetBrackets(name, 'c');\n    const mml = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n    if (width) {\n      NodeUtil.setAttribute(mml, 'width', width);\n    }\n    const align = lookup(pos, {c: 'center', r: 'right'}, '');\n    if (align) {\n      NodeUtil.setAttribute(mml, 'data-align', align);\n    }\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\mathmbox.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  MathMBox(parser: TexParser, name: string) {\n    parser.Push(parser.create('node', 'mrow', [parser.ParseArg(name)]));\n  },\n\n  /**\n   * Implements \\underbacket and \\overbracket.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  UnderOverBracket(parser: TexParser, name: string) {\n    const thickness = length2em(parser.GetBrackets(name, '.1em'), .1);\n    const height = parser.GetBrackets(name, '.2em');\n    const arg = parser.GetArgument(name);\n    const [pos, accent, border] = (\n      name.charAt(1) === 'o' ?\n        ['over', 'accent', 'bottom'] :\n        ['under', 'accentunder', 'top']\n    );\n    const t = em(thickness);\n    const base = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n    const copy = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n    const script = parser.create('node', 'mpadded', [\n      parser.create('node', 'mphantom', [copy])\n    ], {\n      style: `border: ${t} solid; border-${border}: none`,\n      height: height,\n      depth: 0\n    });\n    const node = ParseUtil.underOver(parser, base, script, pos, true);\n    const munderover = NodeUtil.getChildAt(NodeUtil.getChildAt(node, 0), 0);  // TeXAtom.inferredMrow child 0\n    NodeUtil.setAttribute(munderover, accent, true);\n    parser.Push(node);\n  },\n\n  /**\n   * Implements \\Aboxed.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  Aboxed(parser: TexParser, name: string) {\n    //\n    //  Check that the top item is an alignment, and that we are on an even number of cells\n    //  (othewise add one to make it even).\n    //\n    const top = MathtoolsUtil.checkAlignment(parser, name);\n    if (top.row.length % 2 === 1) {\n      top.row.push(parser.create('node', 'mtd', []));\n    }\n    //\n    //  Get the argument and the rest of the TeX string.\n    //\n    const arg = parser.GetArgument(name);\n    const rest = parser.string.substr(parser.i);\n    //\n    //  Put the argument back, followed by \"&&\", and a marker that we look for below.\n    //\n    parser.string = arg + '&&\\\\endAboxed';\n    parser.i = 0;\n    //\n    //  Get the two parts separated by ampersands, and ignore the rest.\n    //\n    const left = parser.GetUpTo(name, '&');\n    const right = parser.GetUpTo(name, '&');\n    parser.GetUpTo(name, '\\\\endAboxed');\n    //\n    //  Insert the TeX needed for the boxed content\n    //\n    const tex = ParseUtil.substituteArgs(\n      parser, [left, right], '\\\\rlap{\\\\boxed{#1{}#2}}\\\\kern.267em\\\\phantom{#1}&\\\\phantom{{}#2}\\\\kern.267em'\n    );\n    parser.string = tex + rest;\n    parser.i = 0;\n  },\n\n  /**\n   * Implements \\ArrowBetweenLines.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  ArrowBetweenLines(parser: TexParser, name: string) {\n    const top = MathtoolsUtil.checkAlignment(parser, name);\n    if (top.Size() || top.row.length) {\n      throw new TexError('BetweenLines', '%1 must be on a row by itself', name);\n    }\n    const star = parser.GetStar();\n    const symbol = parser.GetBrackets(name, '\\\\Updownarrow');\n    if (star) {\n      top.EndEntry();\n      top.EndEntry();\n    }\n    const tex = (star ? '\\\\quad' + symbol : symbol + '\\\\quad');\n    const mml = new TexParser(tex, parser.stack.env, parser.configuration).mml();\n    parser.Push(mml);\n    top.EndEntry();\n    top.EndRow();\n  },\n\n  /**\n   * Implements \\vdotswithin.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  VDotsWithin(parser: TexParser, name: string) {\n    const top = parser.stack.Top() as EqnArrayItem;\n    const isFlush = (top.getProperty('flushspaceabove') === top.table.length);\n    const arg = '\\\\mmlToken{mi}{}' + parser.GetArgument(name) + '\\\\mmlToken{mi}{}';\n    const base = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n    let mml = parser.create('node', 'mpadded', [\n      parser.create('node', 'mpadded', [\n        parser.create('node', 'mo', [\n          parser.create('text', '\\u22EE')\n        ])\n      ], {\n        width: 0,\n        lspace: '-.5width', ...(isFlush ? {height: '-.6em', voffset: '-.18em'} : {})\n      }),\n      parser.create('node', 'mphantom', [base])\n    ], {\n      lspace: '.5width'\n    });\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\shortvdotswithin.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  ShortVDotsWithin(parser: TexParser, _name: string) {\n    const top = parser.stack.Top() as EqnArrayItem;\n    const star = parser.GetStar();\n    MathtoolsMethods.FlushSpaceAbove(parser, '\\\\MTFlushSpaceAbove');\n    !star && top.EndEntry();\n    MathtoolsMethods.VDotsWithin(parser, '\\\\vdotswithin');\n    star && top.EndEntry();\n    MathtoolsMethods.FlushSpaceBelow(parser, '\\\\MTFlushSpaceBelow');\n  },\n\n  /**\n   * Implements \\MTFlushSpaceAbove.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  FlushSpaceAbove(parser: TexParser, name: string) {\n    const top = MathtoolsUtil.checkAlignment(parser, name);\n    top.setProperty('flushspaceabove', top.table.length);  // marker so \\vdotswithin can shorten its height\n    top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustabove']);\n  },\n\n  /**\n   * Implements \\MTFlushSpaceBelow.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  FlushSpaceBelow(parser: TexParser, name: string) {\n    const top = MathtoolsUtil.checkAlignment(parser, name);\n    top.Size() && top.EndEntry();\n    top.EndRow();\n    top.addRowSpacing('-' + parser.options.mathtools['shortvdotsadjustbelow']);\n  },\n\n  /**\n   * Implements a paired delimiter (e.g., from \\DeclarePairedDelimiter).\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {string} open        The open delimiter.\n   * @param {string} close       The close delimiter.\n   * @param {string?} body       The body betweeen the delimiters.\n   * @param {number?} n          The number of arguments to use for the body.\n   * @param {string?} pre        The TeX to go before the open delimiter.\n   * @param {string?} post       The TeX to go after the close delimiter.\n   */\n  PairedDelimiters(parser: TexParser, name: string,\n                   open: string, close: string,\n                   body: string = '#1', n: number = 1,\n                   pre: string = '',  post: string = '') {\n    const star = parser.GetStar();\n    const size = (star ? '' : parser.GetBrackets(name));\n    const [left, right] = (star ? ['\\\\left', '\\\\right'] : size ? [size + 'l' , size + 'r'] : ['', '']);\n    const delim = (star ? '\\\\middle' : size || '');\n    if (n) {\n      const args: string[] = [];\n      for (let i = args.length; i < n; i++) {\n        args.push(parser.GetArgument(name));\n      }\n      pre  = ParseUtil.substituteArgs(parser, args, pre);\n      body = ParseUtil.substituteArgs(parser, args, body);\n      post = ParseUtil.substituteArgs(parser, args, post);\n    }\n    body = body.replace(/\\\\delimsize/g, delim);\n    parser.string = [pre, left, open, body, right, close, post, parser.string.substr(parser.i)]\n      .reduce((s, part) => ParseUtil.addArgs(parser, s, part), '');\n    parser.i = 0;\n    ParseUtil.checkMaxMacros(parser);\n  },\n\n  /**\n   * Implements \\DeclarePairedDelimiter.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  DeclarePairedDelimiter(parser: TexParser, name: string) {\n    const cs = NewcommandUtil.GetCsNameArgument(parser, name);\n    const open = parser.GetArgument(name);\n    const close = parser.GetArgument(name);\n    MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close]);\n  },\n\n  /**\n   * Implements \\DeclarePairedDelimiterX.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  DeclarePairedDelimiterX(parser: TexParser, name: string) {\n    const cs = NewcommandUtil.GetCsNameArgument(parser, name);\n    const n = NewcommandUtil.GetArgCount(parser, name);\n    const open = parser.GetArgument(name);\n    const close = parser.GetArgument(name);\n    const body = parser.GetArgument(name);\n    MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n]);\n  },\n\n  /**\n   * Implements \\DeclarePairedDelimiterXPP.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  DeclarePairedDelimiterXPP(parser: TexParser, name: string) {\n    const cs = NewcommandUtil.GetCsNameArgument(parser, name);\n    const n = NewcommandUtil.GetArgCount(parser, name);\n    const pre = parser.GetArgument(name);\n    const open = parser.GetArgument(name);\n    const close = parser.GetArgument(name);\n    const post = parser.GetArgument(name);\n    const body = parser.GetArgument(name);\n    MathtoolsUtil.addPairedDelims(parser.configuration, cs, [open, close, body, n, pre, post]);\n  },\n\n  /**\n   * Implements \\centeredcolon, \\ordinarycolon, \\MTThinColon.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {boolean} center     True if colon should be centered\n   * @param {boolean} force      True menas always center (don't use centercolon option).\n   * @param {boolean} thin       True if this is a thin color (for \\coloneqq, etc).\n   */\n  CenterColon(parser: TexParser, _name: string, center: boolean, force: boolean = false, thin: boolean = false) {\n    const options = parser.options.mathtools;\n    let mml = parser.create('token', 'mo', {}, ':');\n    if (center && (options['centercolon'] || force)) {\n      const dy = options['centercolon-offset'];\n      mml = parser.create('node', 'mpadded', [mml], {\n        voffset: dy, height: `+${dy}`, depth: `-${dy}`,\n          ...(thin ? {width: options['thincolon-dw'], lspace: options['thincolon-dx']} : {})\n      });\n    }\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\coloneqq and related macros.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {string} tex         The tex string to use (if not using unicode versions or if there isn't one).\n   * @param {string} unicode     The unicode character (if there is one).\n   */\n  Relation(parser: TexParser, _name: string, tex: string, unicode?: string) {\n    const options = parser.options.mathtools;\n    if (options['use-unicode'] && unicode) {\n      parser.Push(parser.create('token', 'mo', {texClass: TEXCLASS.REL}, unicode));\n    } else {\n      tex = '\\\\mathrel{' + tex.replace(/:/g, '\\\\MTThinColon').replace(/-/g, '\\\\mathrel{-}') + '}';\n      parser.string = ParseUtil.addArgs(parser, tex, parser.string.substr(parser.i));\n      parser.i = 0;\n    }\n  },\n\n  /**\n   * Implements \\ndownarrow and \\nuparrow via a terrible hack (visual only, no chance of this working with SRE).\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {string} c           The base arrow for the slashed version\n   * @param {string} dy          A vertical offset for the slash\n   */\n  NArrow(parser: TexParser, _name: string, c: string, dy: string) {\n    parser.Push(\n      parser.create('node', 'TeXAtom', [\n        parser.create('token', 'mtext', {}, c),\n        parser.create('node', 'mpadded', [\n          parser.create('node', 'mpadded', [\n            parser.create('node', 'menclose', [\n              parser.create('node', 'mspace', [], {height: '.2em', depth: 0, width: '.4em'})\n            ], {notation: 'updiagonalstrike', 'data-thickness': '.05em', 'data-padding': 0})\n          ], {width: 0, lspace: '-.5width', voffset: dy}),\n          parser.create('node', 'mphantom', [\n            parser.create('token', 'mtext', {}, c)\n          ])\n        ], {width: 0, lspace: '-.5width'})\n      ], {texClass: TEXCLASS.REL})\n    );\n  },\n\n  /**\n   * Implements \\splitfrac and \\splitdfrac.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {boolean} display    True if \\splitdfrac.\n   */\n  SplitFrac(parser: TexParser, name: string, display: boolean) {\n    const num = parser.ParseArg(name);\n    const den = parser.ParseArg(name);\n    parser.Push(\n      parser.create('node', 'mstyle', [\n        parser.create('node', 'mfrac', [\n          parser.create('node', 'mstyle', [\n            num,\n            parser.create('token', 'mi'),\n            parser.create('token', 'mspace', {width: '1em'}) // no parameter for this in mathtools.  Should we add one?\n          ], {scriptlevel: 0}),\n          parser.create('node', 'mstyle', [\n            parser.create('token', 'mspace', {width: '1em'}),\n            parser.create('token', 'mi'),\n            den\n          ], {scriptlevel: 0})\n        ], {linethickness: 0, numalign: 'left', denomalign: 'right'})\n      ], {displaystyle: display, scriptlevel: 0})\n    );\n  },\n\n  /**\n   * Implements \\xmathstrut.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  XMathStrut(parser: TexParser, name: string) {\n    let dd = parser.GetBrackets(name);\n    let dh = parser.GetArgument(name);\n    dh = MathtoolsUtil.plusOrMinus(name, dh);\n    dd = MathtoolsUtil.plusOrMinus(name, dd || dh);\n    parser.Push(\n      parser.create('node', 'TeXAtom', [\n        parser.create('node', 'mpadded', [\n          parser.create('node', 'mphantom', [\n            parser.create('token', 'mo', {stretchy: false}, '(')\n          ])\n        ], {width: 0, height: dh + 'height', depth: dd + 'depth'})\n      ], {texClass: TEXCLASS.ORD})\n    );\n  },\n\n  /**\n   * Implements \\prescript.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  Prescript(parser: TexParser, name: string) {\n    const sup = MathtoolsUtil.getScript(parser, name, 'sup');\n    const sub = MathtoolsUtil.getScript(parser, name, 'sub');\n    const base = MathtoolsUtil.getScript(parser, name, 'arg');\n    if (NodeUtil.isType(sup, 'none') && NodeUtil.isType(sub, 'none')) {\n      parser.Push(base);\n      return;\n    }\n    const mml = parser.create('node', 'mmultiscripts', [base]);\n    NodeUtil.getChildren(mml).push(null, null);\n    NodeUtil.appendChildren(mml, [parser.create('node', 'mprescripts'), sub, sup]);\n    mml.setProperty('fixPrescript', true);\n    parser.Push(mml);\n  },\n\n  /**\n   * Implements \\newtagform and \\renewtagform.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   * @param {boolean=} renew     True if \\renewtagform.\n   */\n  NewTagForm(parser: TexParser, name: string, renew: boolean = false) {\n    const tags = parser.tags as MathtoolsTags;\n    if (!('mtFormats' in tags)) {\n      throw new TexError('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);\n    }\n    const id = parser.GetArgument(name).trim();\n    if (!id) {\n      throw new TexError('InvalidTagFormID', 'Tag form name can\\'t be empty');\n    }\n    const format = parser.GetBrackets(name, '');\n    const left = parser.GetArgument(name);\n    const right = parser.GetArgument(name);\n    if (!renew && tags.mtFormats.has(id)) {\n      throw new TexError('DuplicateTagForm', 'Duplicate tag form: %1', id);\n    }\n    tags.mtFormats.set(id, [left, right, format]);\n  },\n\n  /**\n   * Implements \\usetagform.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  UseTagForm(parser: TexParser, name: string) {\n    const tags = parser.tags as MathtoolsTags;\n    if (!('mtFormats' in tags)) {\n      throw new TexError('TagsNotMT', '%1 can only be used with ams or mathtools tags', name);\n    }\n    const id = parser.GetArgument(name).trim();\n    if (!id) {\n      tags.mtCurrent = null;\n      return;\n    }\n    if (!tags.mtFormats.has(id)) {\n      throw new TexError('UndefinedTagForm', 'Undefined tag form: %1', id);\n    }\n    tags.mtCurrent = tags.mtFormats.get(id);\n  },\n\n  /**\n   * Implements \\mathtoolsset.\n   *\n   * @param {TexParser} parser   The calling parser.\n   * @param {string} name        The macro name.\n   */\n  SetOptions(parser: TexParser, name: string) {\n    const options = parser.options.mathtools;\n    if (!options['allow-mathtoolsset']) {\n      throw new TexError('ForbiddenMathtoolsSet', '%1 is disabled', name);\n    }\n    const allowed = {} as {[id: string]: number};\n    Object.keys(options).forEach(id => {\n      if (id !== 'pariedDelimiters' && id !== 'tagforms' && id !== 'allow-mathtoolsset') {\n        allowed[id] = 1;\n      }\n    });\n    const args = parser.GetArgument(name);\n    const keys = ParseUtil.keyvalOptions(args, allowed, true);\n    for (const id of Object.keys(keys)) {\n      options[id] = keys[id];\n    }\n  },\n\n  /**\n   * Use the Base or AMS methods for these\n   */\n  Array:  BaseMethods.Array,\n  Macro:  BaseMethods.Macro,\n  xArrow:      AmsMethods.xArrow,\n  HandleRef:   AmsMethods.HandleRef,\n  AmsEqnArray: AmsMethods.AmsEqnArray,\n  MacroWithTemplate: NewcommandMethods.MacroWithTemplate,\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}