{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseItem = exports.MmlStack = void 0;\nvar TexError_js_1 = __importDefault(require(\"./TexError.js\"));\nvar MmlStack = function () {\n  function MmlStack(_nodes) {\n    this._nodes = _nodes;\n  }\n  Object.defineProperty(MmlStack.prototype, \"nodes\", {\n    get: function () {\n      return this._nodes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MmlStack.prototype.Push = function () {\n    var _a;\n    var nodes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nodes[_i] = arguments[_i];\n    }\n    (_a = this._nodes).push.apply(_a, __spreadArray([], __read(nodes), false));\n  };\n  MmlStack.prototype.Pop = function () {\n    return this._nodes.pop();\n  };\n  Object.defineProperty(MmlStack.prototype, \"First\", {\n    get: function () {\n      return this._nodes[this.Size() - 1];\n    },\n    set: function (node) {\n      this._nodes[this.Size() - 1] = node;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MmlStack.prototype, \"Last\", {\n    get: function () {\n      return this._nodes[0];\n    },\n    set: function (node) {\n      this._nodes[0] = node;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MmlStack.prototype.Peek = function (n) {\n    if (n == null) {\n      n = 1;\n    }\n    return this._nodes.slice(this.Size() - n);\n  };\n  MmlStack.prototype.Size = function () {\n    return this._nodes.length;\n  };\n  MmlStack.prototype.Clear = function () {\n    this._nodes = [];\n  };\n  MmlStack.prototype.toMml = function (inferred, forceRow) {\n    if (inferred === void 0) {\n      inferred = true;\n    }\n    if (this._nodes.length === 1 && !forceRow) {\n      return this.First;\n    }\n    return this.create('node', inferred ? 'inferredMrow' : 'mrow', this._nodes, {});\n  };\n  MmlStack.prototype.create = function (kind) {\n    var _a;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    return (_a = this.factory.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest), false));\n  };\n  return MmlStack;\n}();\nexports.MmlStack = MmlStack;\nvar BaseItem = function (_super) {\n  __extends(BaseItem, _super);\n  function BaseItem(factory) {\n    var nodes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      nodes[_i - 1] = arguments[_i];\n    }\n    var _this = _super.call(this, nodes) || this;\n    _this.factory = factory;\n    _this.global = {};\n    _this._properties = {};\n    if (_this.isOpen) {\n      _this._env = {};\n    }\n    return _this;\n  }\n  Object.defineProperty(BaseItem.prototype, \"kind\", {\n    get: function () {\n      return 'base';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"env\", {\n    get: function () {\n      return this._env;\n    },\n    set: function (value) {\n      this._env = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"copyEnv\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BaseItem.prototype.getProperty = function (key) {\n    return this._properties[key];\n  };\n  BaseItem.prototype.setProperty = function (key, value) {\n    this._properties[key] = value;\n    return this;\n  };\n  Object.defineProperty(BaseItem.prototype, \"isOpen\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"isClose\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseItem.prototype, \"isFinal\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BaseItem.prototype.isKind = function (kind) {\n    return kind === this.kind;\n  };\n  BaseItem.prototype.checkItem = function (item) {\n    if (item.isKind('over') && this.isOpen) {\n      item.setProperty('num', this.toMml(false));\n      this.Clear();\n    }\n    if (item.isKind('cell') && this.isOpen) {\n      if (item.getProperty('linebreak')) {\n        return BaseItem.fail;\n      }\n      throw new TexError_js_1.default('Misplaced', 'Misplaced %1', item.getName());\n    }\n    if (item.isClose && this.getErrors(item.kind)) {\n      var _a = __read(this.getErrors(item.kind), 2),\n        id = _a[0],\n        message = _a[1];\n      throw new TexError_js_1.default(id, message, item.getName());\n    }\n    if (!item.isFinal) {\n      return BaseItem.success;\n    }\n    this.Push(item.First);\n    return BaseItem.fail;\n  };\n  BaseItem.prototype.clearEnv = function () {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.keys(this.env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var id = _c.value;\n        delete this.env[id];\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  BaseItem.prototype.setProperties = function (def) {\n    Object.assign(this._properties, def);\n    return this;\n  };\n  BaseItem.prototype.getName = function () {\n    return this.getProperty('name');\n  };\n  BaseItem.prototype.toString = function () {\n    return this.kind + '[' + this.nodes.join('; ') + ']';\n  };\n  BaseItem.prototype.getErrors = function (kind) {\n    var CLASS = this.constructor;\n    return (CLASS.errors || {})[kind] || BaseItem.errors[kind];\n  };\n  BaseItem.fail = [null, false];\n  BaseItem.success = [null, true];\n  BaseItem.errors = {\n    end: ['MissingBeginExtraEnd', 'Missing \\\\begin{%1} or extra \\\\end{%1}'],\n    close: ['ExtraCloseMissingOpen', 'Extra close brace or missing open brace'],\n    right: ['MissingLeftExtraRight', 'Missing \\\\left or extra \\\\right'],\n    middle: ['ExtraMiddle', 'Extra \\\\middle']\n  };\n  return BaseItem;\n}(MmlStack);\nexports.BaseItem = BaseItem;","map":{"version":3,"names":["TexError_js_1","__importDefault","require","MmlStack","_nodes","Object","defineProperty","prototype","get","Push","nodes","_i","arguments","length","_a","push","apply","__spreadArray","__read","Pop","pop","Size","set","node","Peek","n","slice","Clear","toMml","inferred","forceRow","First","create","kind","rest","factory","configuration","nodeFactory","exports","BaseItem","_super","__extends","_this","call","global","_properties","isOpen","_env","value","getProperty","key","setProperty","isKind","checkItem","item","fail","default","getName","isClose","getErrors","id","message","isFinal","success","clearEnv","_b","__values","keys","env","_c","next","done","setProperties","def","assign","toString","join","CLASS","constructor","errors","end","close","right","middle"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/StackItem.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Stack items hold information on the TexParser stack.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {FactoryNodeClass} from '../../core/Tree/Factory.js';\nimport TexError from './TexError.js';\nimport StackItemFactory from './StackItemFactory.js';\n\n// Union types for abbreviation.\nexport type EnvProp = string | number | boolean;\n\nexport type EnvList = {[key: string]: EnvProp};\n\n// This is the type for all fields that used to be set with With.\nexport type Prop = string | number | boolean | MmlNode | PropList;\n\nexport type PropList = {[key: string]: Prop};\n\nexport type CheckType = [(MmlNode | StackItem)[], boolean];\n\n\nexport interface NodeStack {\n\n  /**\n   * Get or set the topmost element on the node stack without removing it.\n   * @return {MmlNode} The topmost node on the stack.\n   */\n  First: MmlNode;\n\n  /**\n   * Get or set the last element on the node stack without removing it.\n   * @return {MmlNode} The last node on the stack.\n   */\n  Last: MmlNode;\n\n  /**\n   * @return {MmlNode} The topmost node on the item's node stack.\n   */\n  Pop(): MmlNode | void;\n\n  /**\n   * Pushes new nodes onto the items node stack.\n   * @param {MmlNode[]} ...nodes A list of nodes.\n   */\n  Push(...nodes: MmlNode[]): void;\n\n  /**\n   * Get the top n elements on the node stack without removing them.\n   * @param {number=} n Number of elements that should be returned.\n   * @return {MmlNode[]} List of nodes on top of stack.\n   */\n  Peek(n?: number): MmlNode[];\n\n  /**\n   * @return {number} The size of the stack.\n   */\n  Size(): number;\n\n  /**\n   * Clears the stack.\n   */\n  Clear(): void;\n\n  /**\n   * Returns nodes on the stack item's node stack as an Mml node. I.e., in case\n   * the item contains more than one node, it creates an mrow.\n   * @param {boolean=} inferred If set the mrow will be an inferred mrow.\n   * @param {boolean=} forceRow If set an mrow will be created, regardless of\n   *     how many nodes the item contains.\n   * @return {MmlNode} The topmost Mml node.\n   */\n  toMml(inferred?: boolean, forceRow?: boolean): MmlNode;\n\n}\n\n\nexport abstract class MmlStack implements NodeStack {\n\n  /**\n   * @constructor\n   * @extends {NodeStack}\n   * @param {MmlNode[]} nodes An initial list of nodes to put on the stack.\n   */\n  constructor(private _nodes: MmlNode[]) { }\n\n  /**\n   * @return {MmlNode[]} The nodes on the stack.\n   */\n  protected get nodes(): MmlNode[] {\n    return this._nodes;\n  }\n\n  /**\n   * @override\n   */\n  public Push(...nodes: MmlNode[]) {\n    this._nodes.push(...nodes);\n  }\n\n\n  /**\n   * @override\n   */\n  public Pop(): MmlNode {\n    return this._nodes.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public get First(): MmlNode {\n    return this._nodes[this.Size() - 1];\n  }\n\n\n  /**\n   * @override\n   */\n  public set First(node: MmlNode) {\n    this._nodes[this.Size() - 1] = node;\n  }\n\n\n  /**\n   * @override\n   */\n  public get Last(): MmlNode {\n    return this._nodes[0];\n  }\n\n\n  /**\n   * @override\n   */\n  public set Last(node: MmlNode) {\n    this._nodes[0] = node;\n  }\n\n\n  /**\n   * @override\n   */\n  public Peek(n?: number): MmlNode[] {\n    if (n == null) {\n      n = 1;\n    }\n    return this._nodes.slice(this.Size() - n);\n  }\n\n\n  /**\n   * @override\n   */\n  public Size(): number {\n    return this._nodes.length;\n  }\n\n\n  /**\n   * @override\n   */\n  public Clear(): void {\n    this._nodes = [];\n  }\n\n\n  protected abstract get factory(): StackItemFactory;\n\n  /**\n   * @override\n   */\n  public toMml(inferred: boolean = true, forceRow?: boolean) {\n    if (this._nodes.length === 1 && !forceRow) {\n      return this.First;\n    }\n    // @test Two Identifiers\n    return this.create(\n      'node', inferred ? 'inferredMrow' : 'mrow', this._nodes, {});\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory on this stack.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.factory.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n}\n\nexport interface StackItem extends NodeStack {\n\n\n  /**\n   * Type of stack item.\n   * @type {string}\n   */\n  kind: string;\n\n  /**\n   * Is this a closing item, e.g., end.\n   * @type {boolean}\n   */\n  isClose: boolean;\n\n  /**\n   * Is this an opening item, e.g., begin.\n   * @type {boolean}\n   */\n  isOpen: boolean;\n\n  /**\n   * Is this a finalising item, i.e., one that only collects nodes.\n   * @type {boolean}\n   */\n  isFinal: boolean;\n\n  /**\n   * Global properties of the parser.\n   * @type {EnvList}\n   */\n   global: EnvList;\n\n  /**\n   * Local properties of the stack item.\n   * @type {EnvList}\n   */\n   env: EnvList;\n\n  /**\n   * Copy local properties when pushed to stack?\n   * @type {boolean}\n   */\n   copyEnv: boolean;\n\n  /**\n   * Tests if item is of the given type.\n   * @param {string} kind The type.\n   * @return {boolean} True if item is of that type.\n   */\n  isKind(kind: string): boolean;\n\n  /**\n   * Get a property of the item.\n   * @param {string} key Property name.\n   * @return {Prop} Property value if it exists.\n   */\n  getProperty(key: string): Prop;\n\n  /**\n   * Set a property.\n   * @param {string} key Property name.\n   * @param {Prop} value Property value.\n   * @return {StackItem} The item for pipelining.\n   */\n  setProperty(key: string, value: Prop): StackItem;\n\n  /**\n   * Sets a list of properties.\n   * @param {PropList} def The properties to set.\n   * @return {StackItem} Returns the stack item object for pipelining.\n   */\n  setProperties(def: PropList): StackItem;\n\n  /**\n   * Convenience method for returning the string property \"name\".\n   * @return {string} The value for the name property.\n   */\n  getName(): string;\n\n  /**\n   * TeX parsing in MathJax is essentially implemented via a nested stack\n   * automaton. That is the tex parser works on a stack, and each item on the\n   * stack can have a data stack of its own. Data on the stack is either a stack\n   * item or a node.\n   *\n   * The checkItem method effectively implements the recursive checking of\n   * input data from the parser against data recursively given on the stack.\n   *\n   * I.e., new input is parsed resulting in a new item. When pushed on the stack\n   * it is checked against the top most item on the stack. This either leads to\n   * the item being pushed onto the stack or combined with the top most\n   * element(s), pushing a new item, which is recursively checked, unless an\n   * error is thrown.\n   *\n   * A simple example: If \\\\end{foo} is parsed, an endItem is created, pushed on\n   * the stack. Nodes on the stack are collapsed into content of the 'foo'\n   * environment, until a beginItem for 'foo' is found.  If a beginItem is not\n   * for 'foo' or does not exist an error is thrown.\n   *\n   * @param {StackItem} item The pushed item.\n   * @return {CheckType} True/false or an item or node.\n   */\n  checkItem(item: StackItem): CheckType;\n\n}\n\nexport interface StackItemClass extends FactoryNodeClass<StackItem> {\n  // new (factory: StackItemFactory, ...args: any[]): StackItem;\n}\n\n\n/**\n * Abstract basic item class that implements most of the stack item\n * functionality. In particular, it contains the base method for checkItem.\n */\nexport abstract class BaseItem extends MmlStack implements StackItem {\n\n  /**\n   * The fail value.\n   * @type {CheckType}\n   */\n  protected static fail: CheckType = [null, false];\n\n  /**\n   * The success value.\n   * @type {CheckType}\n   */\n  protected static success: CheckType = [null, true];\n\n  /**\n   * A list of basic errors.\n   * @type {{[key: string]: string[]}}\n   */\n  protected static errors: {[key: string]: string[]} = {\n    // @test ExtraOpenMissingClose\n    end: ['MissingBeginExtraEnd', 'Missing \\\\begin{%1} or extra \\\\end{%1}'],\n    // @test ExtraCloseMissingOpen\n    close: ['ExtraCloseMissingOpen', 'Extra close brace or missing open brace'],\n    // @test MissingLeftExtraRight\n    right: ['MissingLeftExtraRight', 'Missing \\\\left or extra \\\\right'],\n    middle: ['ExtraMiddle', 'Extra \\\\middle']\n  };\n\n\n  /**\n   * @override\n   */\n  public global: EnvList = {};\n\n  private _env: EnvList;\n\n  private _properties: PropList = {};\n\n\n  /**\n   * @constructor\n   * @extends {MmlStack}\n   */\n  constructor(protected factory: StackItemFactory, ...nodes: MmlNode[]) {\n    super(nodes);\n    if (this.isOpen) {\n      this._env = {};\n    }\n  }\n\n  /**\n   * @return {string} The type of the stack item.\n   */\n    public get kind(): string {\n    return 'base';\n  }\n\n  /**\n   * @return {EnvList} Get the private environment\n   */\n  public get env(): EnvList {\n    return this._env;\n  }\n\n  /**\n   * Set the private environment\n   * @param {EnvList} value New private environemt.\n   */\n  public set env(value: EnvList) {\n    this._env = value;\n  }\n\n  /**\n   * Default is to copy local environment when pushed on stack\n   */\n  public get copyEnv() {\n    return true;\n  }\n\n  /**\n   * @override\n   */\n  public getProperty(key: string): Prop {\n    return this._properties[key];\n  }\n\n  /**\n   * @override\n   */\n  public setProperty(key: string, value: Prop) {\n    this._properties[key] = value;\n    return this;\n  }\n\n\n  /**\n   * @return {boolean} True if item is an opening entity, i.e., it expects a\n   *     closing counterpart on the stack later.\n   */\n  get isOpen(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean} True if item is an closing entity, i.e., it needs an\n   *     opening counterpart already on the stack.\n   */\n  get isClose(): boolean {\n    return false;\n  }\n\n\n  /**\n   * @return {boolean} True if item is final, i.e., it contains one or multiple\n   *      finished parsed nodes.\n   */\n  get isFinal(): boolean {\n    return false;\n  }\n\n\n  /**\n   * @override\n   */\n  public isKind(kind: string) {\n    return kind === this.kind;\n  }\n\n\n  /**\n   * @override\n   */\n  public checkItem(item: StackItem): CheckType {\n    if (item.isKind('over') && this.isOpen) {\n      item.setProperty('num', this.toMml(false));\n      this.Clear();\n    }\n    if (item.isKind('cell') && this.isOpen) {\n      if (item.getProperty('linebreak')) {\n        return BaseItem.fail;\n      }\n      // @test Ampersand-error\n      throw new TexError('Misplaced', 'Misplaced %1', item.getName());\n    }\n    if (item.isClose && this.getErrors(item.kind)) {\n      // @test ExtraOpenMissingClose, ExtraCloseMissingOpen,\n      //       MissingLeftExtraRight, MissingBeginExtraEnd\n      const [id, message] = this.getErrors(item.kind);\n      throw new TexError(id, message, item.getName());\n    }\n    if (!item.isFinal) {\n      return BaseItem.success;\n    }\n    this.Push(item.First);\n    return BaseItem.fail;\n  }\n\n\n  /**\n   * Clears the item's environment.\n   */\n  public clearEnv() {\n    for (const id of Object.keys(this.env)) {\n      delete this.env[id];\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public setProperties(def: PropList) {\n    Object.assign(this._properties, def);\n    return this;\n  }\n\n\n  /**\n   * @override\n   */\n  public getName() {\n    return this.getProperty('name') as string;\n  }\n\n\n  /**\n   * @override\n   */\n  public toString() {\n    return this.kind + '[' + this.nodes.join('; ') + ']';\n  }\n\n\n  /**\n   * Get error messages for a particular types of stack items. This reads error\n   * messages from the static errors object, which can be extended in\n   * subclasses.\n   * @param {string} kind The stack item type.\n   * @return {string[]} The list of arguments for the TeXError.\n   */\n  public getErrors(kind: string): string[] {\n    const CLASS = (this.constructor as typeof BaseItem);\n    return (CLASS.errors || {})[kind] || BaseItem.errors[kind];\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}