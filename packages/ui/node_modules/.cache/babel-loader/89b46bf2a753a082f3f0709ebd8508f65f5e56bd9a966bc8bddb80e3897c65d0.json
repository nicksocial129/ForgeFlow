{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Arrow = exports.DiagonalArrow = exports.DiagonalStrike = exports.Border2 = exports.Border = exports.RenderLine = exports.lineOffset = exports.lineData = exports.computeLineData = void 0;\nvar Notation = __importStar(require(\"../common/Notation.js\"));\n__exportStar(require(\"../common/Notation.js\"), exports);\nexports.computeLineData = {\n  top: function (h, _d, w, t) {\n    return [0, h - t, w, h - t];\n  },\n  right: function (h, d, w, t) {\n    return [w - t, -d, w - t, h];\n  },\n  bottom: function (_h, d, w, t) {\n    return [0, t - d, w, t - d];\n  },\n  left: function (h, d, _w, t) {\n    return [t, -d, t, h];\n  },\n  vertical: function (h, d, w, _t) {\n    return [w / 2, h, w / 2, -d];\n  },\n  horizontal: function (h, d, w, _t) {\n    return [0, (h - d) / 2, w, (h - d) / 2];\n  },\n  up: function (h, d, w, t) {\n    return [t, t - d, w - t, h - t];\n  },\n  down: function (h, d, w, t) {\n    return [t, h - t, w - t, t - d];\n  }\n};\nvar lineData = function (node, kind, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n  var _a = node.getBBox(),\n    h = _a.h,\n    d = _a.d,\n    w = _a.w;\n  var t = node.thickness / 2;\n  return (0, exports.lineOffset)(exports.computeLineData[kind](h, d, w, t), node, offset);\n};\nexports.lineData = lineData;\nvar lineOffset = function (data, node, offset) {\n  if (offset) {\n    var d = node.getOffset(offset);\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n  return data;\n};\nexports.lineOffset = lineOffset;\nvar RenderLine = function (line, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n  return function (node, _child) {\n    var L = node.line((0, exports.lineData)(node, line, offset));\n    node.adaptor.append(node.element, L);\n  };\n};\nexports.RenderLine = RenderLine;\nvar Border = function (side) {\n  return Notation.CommonBorder(function (node, _child) {\n    node.adaptor.append(node.element, node.line((0, exports.lineData)(node, side)));\n  })(side);\n};\nexports.Border = Border;\nvar Border2 = function (name, side1, side2) {\n  return Notation.CommonBorder2(function (node, _child) {\n    node.adaptor.append(node.element, node.line((0, exports.lineData)(node, side1)));\n    node.adaptor.append(node.element, node.line((0, exports.lineData)(node, side2)));\n  })(name, side1, side2);\n};\nexports.Border2 = Border2;\nvar DiagonalStrike = function (name) {\n  return Notation.CommonDiagonalStrike(function (_cname) {\n    return function (node, _child) {\n      node.adaptor.append(node.element, node.line((0, exports.lineData)(node, name)));\n    };\n  })(name);\n};\nexports.DiagonalStrike = DiagonalStrike;\nvar DiagonalArrow = function (name) {\n  return Notation.CommonDiagonalArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\nexports.DiagonalArrow = DiagonalArrow;\nvar Arrow = function (name) {\n  return Notation.CommonArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\nexports.Arrow = Arrow;","map":{"version":3,"names":["Notation","__importStar","require","__exportStar","exports","computeLineData","top","h","_d","w","t","right","d","bottom","_h","left","_w","vertical","_t","horizontal","up","down","lineData","node","kind","offset","_a","getBBox","thickness","lineOffset","data","getOffset","RenderLine","line","_child","L","adaptor","append","element","Border","side","CommonBorder","Border2","name","side1","side2","CommonBorder2","DiagonalStrike","CommonDiagonalStrike","_cname","DiagonalArrow","CommonDiagonalArrow","arrow","Arrow","CommonArrow"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/output/svg/Notation.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements utilities for notations for menclose elements\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {SVGmenclose} from './Wrappers/menclose.js';\nimport * as Notation from '../common/Notation.js';\nexport * from '../common/Notation.js';\n\n/*******************************************************************/\n\n/**\n * Shorthand for SVGmenclose\n */\nexport type Menclose = SVGmenclose<any, any, any>;\n\n\n/*\n * Shorthands for common types\n */\nexport type RENDERER<N, T, D> = Notation.Renderer<SVGmenclose<N, T, D>, N>;\nexport type DEFPAIR<N, T, D> = Notation.DefPair<SVGmenclose<N, T, D>, N>;\n\n/**\n * The kinds of lines that can be drawn\n */\nexport type LineName = Notation.Side | ('vertical' | 'horizontal' | 'up' | 'down');\n\n/**\n * [x1,y1, x2,y2] endpoints for a line\n */\nexport type LineData = [number, number, number, number];\n\n/**\n * Functions for computing the line data for each type of line\n */\nexport const computeLineData = {\n  top: (h, _d, w, t) => [0, h - t, w, h - t],\n  right: (h, d, w, t) => [w - t, -d, w - t, h],\n  bottom: (_h, d, w, t) => [0, t - d, w, t - d],\n  left: (h, d, _w, t) => [t, -d, t, h],\n  vertical: (h, d, w, _t) => [w / 2, h, w / 2, -d],\n  horizontal: (h, d, w, _t) => [0, (h - d) / 2, w, (h - d) / 2],\n  up: (h, d, w, t) => [t, t - d, w - t, h - t],\n  down: (h, d, w, t) => [t, h - t, w - t, t - d]\n} as {[kind: string]: (h: number, d: number, w: number, t: number) => LineData};\n\n/**\n * The data for a given line as two endpoints: [x1, y1, x2, y1]\n *\n * @param {Menclose} node   The node whose line is to be drawn\n * @param {LineName} kind   The type of line to draw for the node\n * @param {string} offset   The offset direction, if any\n * @return {LineData}       The coordinates of the two endpoints\n */\nexport const lineData = function(node: Menclose, kind: LineName, offset: string = ''): LineData {\n  const {h, d, w} = node.getBBox();\n  const t = node.thickness / 2;\n  return lineOffset(computeLineData[kind](h, d, w, t), node, offset);\n};\n\n/**\n * Recenter the line data for vertical and horizontal lines\n *\n * @param {LineData} data   The line endpoints to adjust\n * @param {Menclose} node   The menclose node\n * @param {string} offset   The direction to offset\n */\nexport const lineOffset = function(data: LineData, node: Menclose, offset: string): LineData {\n  if (offset) {\n    const d = node.getOffset(offset);\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n  return data;\n};\n\n\n/*******************************************************************/\n\n/**\n * @param {LineName} line  The name of the line to create\n * @return {RENDERER}      The renderer function for the given line\n */\nexport const RenderLine = function<N, T, D>(line: LineName, offset: string = ''): RENDERER<N, T, D> {\n  return ((node, _child) => {\n    const L = node.line(lineData(node, line, offset));\n    node.adaptor.append(node.element, L);\n  });\n};\n\n/*******************************************************************/\n\n/**\n * @param {Notation.Side} side   The kind of line (side, diagonal, etc.)\n * @return {DEFPAIR}      The notation definition for the notation having a line on the given side\n */\nexport const Border = function<N, T, D>(side: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side)));\n  })(side);\n};\n\n\n/**\n * @param {string} name    The name of the notation to define\n * @param {Notation.Side} side1   The first side to get a border\n * @param {Notation.Side} side2   The second side to get a border\n * @return {DEFPAIR}       The notation definition for the notation having lines on two sides\n */\nexport const Border2 = function<N, T, D>(name: string, side1: Notation.Side, side2: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder2<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side1)));\n    node.adaptor.append(node.element, node.line(lineData(node, side2)));\n  })(name, side1, side2);\n};\n\n/*******************************************************************/\n\n/**\n * @param {LineName} name  The name of the diagonal strike to define\n * @return {DEFPAIR}       The notation definition for the diagonal strike\n */\nexport const DiagonalStrike = function<N, T, D>(name: LineName): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalStrike<SVGmenclose<N, T, D>, N>((_cname: string) => (node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, name)));\n  })(name);\n};\n\n/*******************************************************************/\n\n/**\n * @param {string} name   The name of the diagonal arrow to define\n * @return {DEFPAIR}      The notation definition for the diagonal arrow\n */\nexport const DiagonalArrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/**\n * @param {string} name   The name of the horizontal or vertical arrow to define\n * @return {DEFPAIR}      The notation definition for the arrow\n */\nexport const Arrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/*******************************************************************/\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,IAAAA,QAAA,GAAAC,YAAA,CAAAC,OAAA;AACAC,YAAA,CAAAD,OAAA,2BAAAE,OAAA;AA6BaA,OAAA,CAAAC,eAAe,GAAG;EAC7BC,GAAG,EAAE,SAAAA,CAACC,CAAC,EAAEC,EAAE,EAAEC,CAAC,EAAEC,CAAC;IAAK,QAAC,CAAC,EAAEH,CAAC,GAAGG,CAAC,EAAED,CAAC,EAAEF,CAAC,GAAGG,CAAC,CAAC;EAApB,CAAoB;EAC1CC,KAAK,EAAE,SAAAA,CAACJ,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAEC,CAAC;IAAK,QAACD,CAAC,GAAGC,CAAC,EAAE,CAACE,CAAC,EAAEH,CAAC,GAAGC,CAAC,EAAEH,CAAC,CAAC;EAArB,CAAqB;EAC5CM,MAAM,EAAE,SAAAA,CAACC,EAAE,EAAEF,CAAC,EAAEH,CAAC,EAAEC,CAAC;IAAK,QAAC,CAAC,EAAEA,CAAC,GAAGE,CAAC,EAAEH,CAAC,EAAEC,CAAC,GAAGE,CAAC,CAAC;EAApB,CAAoB;EAC7CG,IAAI,EAAE,SAAAA,CAACR,CAAC,EAAEK,CAAC,EAAEI,EAAE,EAAEN,CAAC;IAAK,QAACA,CAAC,EAAE,CAACE,CAAC,EAAEF,CAAC,EAAEH,CAAC,CAAC;EAAb,CAAa;EACpCU,QAAQ,EAAE,SAAAA,CAACV,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAES,EAAE;IAAK,QAACT,CAAC,GAAG,CAAC,EAAEF,CAAC,EAAEE,CAAC,GAAG,CAAC,EAAE,CAACG,CAAC,CAAC;EAArB,CAAqB;EAChDO,UAAU,EAAE,SAAAA,CAACZ,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAES,EAAE;IAAK,QAAC,CAAC,EAAE,CAACX,CAAC,GAAGK,CAAC,IAAI,CAAC,EAAEH,CAAC,EAAE,CAACF,CAAC,GAAGK,CAAC,IAAI,CAAC,CAAC;EAAhC,CAAgC;EAC7DQ,EAAE,EAAE,SAAAA,CAACb,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAEC,CAAC;IAAK,QAACA,CAAC,EAAEA,CAAC,GAAGE,CAAC,EAAEH,CAAC,GAAGC,CAAC,EAAEH,CAAC,GAAGG,CAAC,CAAC;EAAxB,CAAwB;EAC5CW,IAAI,EAAE,SAAAA,CAACd,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAEC,CAAC;IAAK,QAACA,CAAC,EAAEH,CAAC,GAAGG,CAAC,EAAED,CAAC,GAAGC,CAAC,EAAEA,CAAC,GAAGE,CAAC,CAAC;EAAxB;CACuD;AAUxE,IAAMU,QAAQ,GAAG,SAAAA,CAASC,IAAc,EAAEC,IAAc,EAAEC,MAAmB;EAAnB,IAAAA,MAAA;IAAAA,MAAA,KAAmB;EAAA;EAC5E,IAAAC,EAAA,GAAYH,IAAI,CAACI,OAAO,EAAE;IAAzBpB,CAAC,GAAAmB,EAAA,CAAAnB,CAAA;IAAEK,CAAC,GAAAc,EAAA,CAAAd,CAAA;IAAEH,CAAC,GAAAiB,EAAA,CAAAjB,CAAkB;EAChC,IAAMC,CAAC,GAAGa,IAAI,CAACK,SAAS,GAAG,CAAC;EAC5B,OAAO,IAAAxB,OAAA,CAAAyB,UAAU,EAACzB,OAAA,CAAAC,eAAe,CAACmB,IAAI,CAAC,CAACjB,CAAC,EAAEK,CAAC,EAAEH,CAAC,EAAEC,CAAC,CAAC,EAAEa,IAAI,EAAEE,MAAM,CAAC;AACpE,CAAC;AAJYrB,OAAA,CAAAkB,QAAQ,GAAAA,QAAA;AAad,IAAMO,UAAU,GAAG,SAAAA,CAASC,IAAc,EAAEP,IAAc,EAAEE,MAAc;EAC/E,IAAIA,MAAM,EAAE;IACV,IAAMb,CAAC,GAAGW,IAAI,CAACQ,SAAS,CAACN,MAAM,CAAC;IAChC,IAAIb,CAAC,EAAE;MACL,IAAIa,MAAM,KAAK,GAAG,EAAE;QAClBK,IAAI,CAAC,CAAC,CAAC,IAAIlB,CAAC;QACZkB,IAAI,CAAC,CAAC,CAAC,IAAIlB,CAAC;OACb,MAAM;QACLkB,IAAI,CAAC,CAAC,CAAC,IAAIlB,CAAC;QACZkB,IAAI,CAAC,CAAC,CAAC,IAAIlB,CAAC;;;;EAIlB,OAAOkB,IAAI;AACb,CAAC;AAdY1B,OAAA,CAAAyB,UAAU,GAAAA,UAAA;AAuBhB,IAAMG,UAAU,GAAG,SAAAA,CAAkBC,IAAc,EAAER,MAAmB;EAAnB,IAAAA,MAAA;IAAAA,MAAA,KAAmB;EAAA;EAC7E,OAAQ,UAACF,IAAI,EAAEW,MAAM;IACnB,IAAMC,CAAC,GAAGZ,IAAI,CAACU,IAAI,CAAC,IAAA7B,OAAA,CAAAkB,QAAQ,EAACC,IAAI,EAAEU,IAAI,EAAER,MAAM,CAAC,CAAC;IACjDF,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEH,CAAC,CAAC;EACtC,CAAC;AACH,CAAC;AALY/B,OAAA,CAAA4B,UAAU,GAAAA,UAAA;AAahB,IAAMO,MAAM,GAAG,SAAAA,CAAkBC,IAAmB;EACzD,OAAOxC,QAAQ,CAACyC,YAAY,CAA0B,UAAClB,IAAI,EAAEW,MAAM;IACjEX,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEf,IAAI,CAACU,IAAI,CAAC,IAAA7B,OAAA,CAAAkB,QAAQ,EAACC,IAAI,EAAEiB,IAAI,CAAC,CAAC,CAAC;EACpE,CAAC,CAAC,CAACA,IAAI,CAAC;AACV,CAAC;AAJYpC,OAAA,CAAAmC,MAAM,GAAAA,MAAA;AAaZ,IAAMG,OAAO,GAAG,SAAAA,CAAkBC,IAAY,EAAEC,KAAoB,EAAEC,KAAoB;EAC/F,OAAO7C,QAAQ,CAAC8C,aAAa,CAA0B,UAACvB,IAAI,EAAEW,MAAM;IAClEX,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEf,IAAI,CAACU,IAAI,CAAC,IAAA7B,OAAA,CAAAkB,QAAQ,EAACC,IAAI,EAAEqB,KAAK,CAAC,CAAC,CAAC;IACnErB,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEf,IAAI,CAACU,IAAI,CAAC,IAAA7B,OAAA,CAAAkB,QAAQ,EAACC,IAAI,EAAEsB,KAAK,CAAC,CAAC,CAAC;EACrE,CAAC,CAAC,CAACF,IAAI,EAAEC,KAAK,EAAEC,KAAK,CAAC;AACxB,CAAC;AALYzC,OAAA,CAAAsC,OAAO,GAAAA,OAAA;AAab,IAAMK,cAAc,GAAG,SAAAA,CAAkBJ,IAAc;EAC5D,OAAO3C,QAAQ,CAACgD,oBAAoB,CAA0B,UAACC,MAAc;IAAK,iBAAC1B,IAAI,EAAEW,MAAM;MAC7FX,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEf,IAAI,CAACU,IAAI,CAAC,IAAA7B,OAAA,CAAAkB,QAAQ,EAACC,IAAI,EAAEoB,IAAI,CAAC,CAAC,CAAC;IACpE,CAAC;EAFiF,CAEjF,CAAC,CAACA,IAAI,CAAC;AACV,CAAC;AAJYvC,OAAA,CAAA2C,cAAc,GAAAA,cAAA;AAYpB,IAAMG,aAAa,GAAG,SAAAA,CAAkBP,IAAY;EACzD,OAAO3C,QAAQ,CAACmD,mBAAmB,CAA0B,UAAC5B,IAAI,EAAE6B,KAAK;IACvE7B,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEc,KAAK,CAAC;EAC1C,CAAC,CAAC,CAACT,IAAI,CAAC;AACV,CAAC;AAJYvC,OAAA,CAAA8C,aAAa,GAAAA,aAAA;AAUnB,IAAMG,KAAK,GAAG,SAAAA,CAAkBV,IAAY;EACjD,OAAO3C,QAAQ,CAACsD,WAAW,CAA0B,UAAC/B,IAAI,EAAE6B,KAAK;IAC/D7B,IAAI,CAACa,OAAO,CAACC,MAAM,CAACd,IAAI,CAACe,OAAO,EAAEc,KAAK,CAAC;EAC1C,CAAC,CAAC,CAACT,IAAI,CAAC;AACV,CAAC;AAJYvC,OAAA,CAAAiD,KAAK,GAAAA,KAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}