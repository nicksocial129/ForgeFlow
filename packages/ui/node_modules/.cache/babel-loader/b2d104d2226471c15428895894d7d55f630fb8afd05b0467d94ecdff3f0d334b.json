{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TagFormatConfiguration = exports.tagformatConfig = void 0;\nvar Configuration_js_1 = require(\"../Configuration.js\");\nvar Tags_js_1 = require(\"../Tags.js\");\nvar tagID = 0;\nfunction tagformatConfig(config, jax) {\n  var tags = jax.parseOptions.options.tags;\n  if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {\n    Tags_js_1.TagsFactory.add(tags, config.tags[tags]);\n  }\n  var TagClass = Tags_js_1.TagsFactory.create(jax.parseOptions.options.tags).constructor;\n  var TagFormat = function (_super) {\n    __extends(TagFormat, _super);\n    function TagFormat() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TagFormat.prototype.formatNumber = function (n) {\n      return jax.parseOptions.options.tagformat.number(n);\n    };\n    TagFormat.prototype.formatTag = function (tag) {\n      return jax.parseOptions.options.tagformat.tag(tag);\n    };\n    TagFormat.prototype.formatId = function (id) {\n      return jax.parseOptions.options.tagformat.id(id);\n    };\n    TagFormat.prototype.formatUrl = function (id, base) {\n      return jax.parseOptions.options.tagformat.url(id, base);\n    };\n    return TagFormat;\n  }(TagClass);\n  tagID++;\n  var tagName = 'configTags-' + tagID;\n  Tags_js_1.TagsFactory.add(tagName, TagFormat);\n  jax.parseOptions.options.tags = tagName;\n}\nexports.tagformatConfig = tagformatConfig;\nexports.TagFormatConfiguration = Configuration_js_1.Configuration.create('tagformat', {\n  config: [tagformatConfig, 10],\n  options: {\n    tagformat: {\n      number: function (n) {\n        return n.toString();\n      },\n      tag: function (tag) {\n        return '(' + tag + ')';\n      },\n      id: function (id) {\n        return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n      },\n      url: function (id, base) {\n        return base + '#' + encodeURIComponent(id);\n      }\n    }\n  }\n});","map":{"version":3,"names":["Configuration_js_1","require","Tags_js_1","tagID","tagformatConfig","config","jax","tags","parseOptions","options","hasOwnProperty","TagsFactory","add","TagClass","create","constructor","TagFormat","_super","__extends","prototype","formatNumber","n","tagformat","number","formatTag","tag","formatId","id","formatUrl","base","url","tagName","exports","TagFormatConfiguration","Configuration","toString","replace","encodeURIComponent"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/tagformat/TagFormatConfiguration.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2019-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview    Configuration file for the tagformat package.\n *\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\nimport {Configuration, ParserConfiguration} from '../Configuration.js';\nimport {TeX} from '../../tex.js';\nimport {AbstractTags, TagsFactory} from '../Tags.js';\n\n/**\n * Number used to make tag class unique (each TeX input has to have its own because\n *  it needs access to the parse options)\n */\nlet tagID = 0;\n\n/**\n * Configure a class to use for the tag handler that uses the input jax's options\n *   to control the formatting of the tags\n * @param {Configuration} config   The configuration for the input jax\n * @param {TeX} jax                The TeX input jax\n */\nexport function tagformatConfig(config: ParserConfiguration, jax: TeX<any, any, any>) {\n\n  /**\n   * If the tag format is being added by one of the other extensions,\n   *   as is done for the 'ams' tags, make sure it is defined so we can create it.\n   */\n  const tags = jax.parseOptions.options.tags;\n  if (tags !== 'base' && config.tags.hasOwnProperty(tags)) {\n    TagsFactory.add(tags, config.tags[tags]);\n  }\n\n  /**\n   * The original tag class to be extended (none, ams, or all)\n   */\n  const TagClass = TagsFactory.create(jax.parseOptions.options.tags).constructor as typeof AbstractTags;\n\n  /**\n   * A Tags object that uses the input jax options to perform the formatting\n   *\n   * Note:  We have to make a new class for each input jax since the format\n   * methods don't have access to the input jax, and hence to its options.\n   * If they did, we would use a common configTags class instead.\n   */\n  class TagFormat extends TagClass {\n\n    /**\n     * @override\n     */\n    public formatNumber(n: number) {\n      return jax.parseOptions.options.tagformat.number(n);\n    }\n\n    /**\n     * @override\n     */\n    public formatTag(tag: string) {\n      return jax.parseOptions.options.tagformat.tag(tag);\n    }\n\n    /**\n     * @override\n     */\n    public formatId(id: string) {\n      return jax.parseOptions.options.tagformat.id(id);\n    }\n\n    /**\n     * @override\n     */\n    public formatUrl(id: string, base: string) {\n      return jax.parseOptions.options.tagformat.url(id, base);\n    }\n  }\n\n  //\n  //  Get a unique name for the tag class (since it is tied to the input jax)\n  //  Note:  These never get freed, so they will accumulate if you create many\n  //  TeX input jax instances with this extension.\n  //\n  tagID++;\n  const tagName = 'configTags-' + tagID;\n  //\n  // Register the tag class\n  //\n  TagsFactory.add(tagName, TagFormat);\n  jax.parseOptions.options.tags = tagName;\n}\n\n/**\n * The configuration object for configTags\n */\nexport const TagFormatConfiguration = Configuration.create(\n  'tagformat', {\n    config: [tagformatConfig, 10],\n    options: {\n      tagformat: {\n        number: (n: number) => n.toString(),\n        tag:    (tag: string) => '(' + tag + ')',\n        id:     (id: string) => 'mjx-eqn:' + id.replace(/\\s/g, '_'),\n        url:    (id: string, base: string) => base + '#' + encodeURIComponent(id),\n      }\n    }\n  }\n);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,IAAAA,kBAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AAMA,IAAIE,KAAK,GAAG,CAAC;AAQb,SAAgBC,eAAeA,CAACC,MAA2B,EAAEC,GAAuB;EAMlF,IAAMC,IAAI,GAAGD,GAAG,CAACE,YAAY,CAACC,OAAO,CAACF,IAAI;EAC1C,IAAIA,IAAI,KAAK,MAAM,IAAIF,MAAM,CAACE,IAAI,CAACG,cAAc,CAACH,IAAI,CAAC,EAAE;IACvDL,SAAA,CAAAS,WAAW,CAACC,GAAG,CAACL,IAAI,EAAEF,MAAM,CAACE,IAAI,CAACA,IAAI,CAAC,CAAC;;EAM1C,IAAMM,QAAQ,GAAGX,SAAA,CAAAS,WAAW,CAACG,MAAM,CAACR,GAAG,CAACE,YAAY,CAACC,OAAO,CAACF,IAAI,CAAC,CAACQ,WAAkC;EASrG,IAAAC,SAAA,aAAAC,MAAA;IAAwBC,SAAA,CAAAF,SAAA,EAAAC,MAAA;IAAxB,SAAAD,UAAA;;IA6BA;IAxBSA,SAAA,CAAAG,SAAA,CAAAC,YAAY,GAAnB,UAAoBC,CAAS;MAC3B,OAAOf,GAAG,CAACE,YAAY,CAACC,OAAO,CAACa,SAAS,CAACC,MAAM,CAACF,CAAC,CAAC;IACrD,CAAC;IAKML,SAAA,CAAAG,SAAA,CAAAK,SAAS,GAAhB,UAAiBC,GAAW;MAC1B,OAAOnB,GAAG,CAACE,YAAY,CAACC,OAAO,CAACa,SAAS,CAACG,GAAG,CAACA,GAAG,CAAC;IACpD,CAAC;IAKMT,SAAA,CAAAG,SAAA,CAAAO,QAAQ,GAAf,UAAgBC,EAAU;MACxB,OAAOrB,GAAG,CAACE,YAAY,CAACC,OAAO,CAACa,SAAS,CAACK,EAAE,CAACA,EAAE,CAAC;IAClD,CAAC;IAKMX,SAAA,CAAAG,SAAA,CAAAS,SAAS,GAAhB,UAAiBD,EAAU,EAAEE,IAAY;MACvC,OAAOvB,GAAG,CAACE,YAAY,CAACC,OAAO,CAACa,SAAS,CAACQ,GAAG,CAACH,EAAE,EAAEE,IAAI,CAAC;IACzD,CAAC;IACH,OAAAb,SAAC;EAAD,CAAC,CA7BuBH,QAAQ;EAoChCV,KAAK,EAAE;EACP,IAAM4B,OAAO,GAAG,aAAa,GAAG5B,KAAK;EAIrCD,SAAA,CAAAS,WAAW,CAACC,GAAG,CAACmB,OAAO,EAAEf,SAAS,CAAC;EACnCV,GAAG,CAACE,YAAY,CAACC,OAAO,CAACF,IAAI,GAAGwB,OAAO;AACzC;AAlEAC,OAAA,CAAA5B,eAAA,GAAAA,eAAA;AAuEa4B,OAAA,CAAAC,sBAAsB,GAAGjC,kBAAA,CAAAkC,aAAa,CAACpB,MAAM,CACxD,WAAW,EAAE;EACXT,MAAM,EAAE,CAACD,eAAe,EAAE,EAAE,CAAC;EAC7BK,OAAO,EAAE;IACPa,SAAS,EAAE;MACTC,MAAM,EAAE,SAAAA,CAACF,CAAS;QAAK,OAAAA,CAAC,CAACc,QAAQ,EAAE;MAAZ,CAAY;MACnCV,GAAG,EAAK,SAAAA,CAACA,GAAW;QAAK,UAAG,GAAGA,GAAG,GAAG,GAAG;MAAf,CAAe;MACxCE,EAAE,EAAM,SAAAA,CAACA,EAAU;QAAK,iBAAU,GAAGA,EAAE,CAACS,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;MAAnC,CAAmC;MAC3DN,GAAG,EAAK,SAAAA,CAACH,EAAU,EAAEE,IAAY;QAAK,OAAAA,IAAI,GAAG,GAAG,GAAGQ,kBAAkB,CAACV,EAAE,CAAC;MAAnC;;;CAG3C,CACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}