{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmpheqUtil = void 0;\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nexports.EmpheqUtil = {\n  environment: function (parser, env, func, args) {\n    var name = args[0];\n    var item = parser.itemFactory.create(name + '-begin').setProperties({\n      name: env,\n      end: name\n    });\n    parser.Push(func.apply(void 0, __spreadArray([parser, item], __read(args.slice(1)), false)));\n  },\n  splitOptions: function (text, allowed) {\n    if (allowed === void 0) {\n      allowed = null;\n    }\n    return ParseUtil_js_1.default.keyvalOptions(text, allowed, true);\n  },\n  columnCount: function (table) {\n    var e_1, _a;\n    var m = 0;\n    try {\n      for (var _b = __values(table.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var row = _c.value;\n        var n = row.childNodes.length - (row.isKind('mlabeledtr') ? 1 : 0);\n        if (n > m) m = n;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return m;\n  },\n  cellBlock: function (tex, table, parser, env) {\n    var e_2, _a;\n    var mpadded = parser.create('node', 'mpadded', [], {\n      height: 0,\n      depth: 0,\n      voffset: '-1height'\n    });\n    var result = new TexParser_js_1.default(tex, parser.stack.env, parser.configuration);\n    var mml = result.mml();\n    if (env && result.configuration.tags.label) {\n      result.configuration.tags.currentTag.env = env;\n      result.configuration.tags.getTag(true);\n    }\n    try {\n      for (var _b = __values(mml.isInferred ? mml.childNodes : [mml]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        mpadded.appendChild(child);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    mpadded.appendChild(parser.create('node', 'mphantom', [parser.create('node', 'mpadded', [table], {\n      width: 0\n    })]));\n    return mpadded;\n  },\n  topRowTable: function (original, parser) {\n    var table = ParseUtil_js_1.default.copyNode(original, parser);\n    table.setChildren(table.childNodes.slice(0, 1));\n    table.attributes.set('align', 'baseline 1');\n    return original.factory.create('mphantom', {}, [parser.create('node', 'mpadded', [table], {\n      width: 0\n    })]);\n  },\n  rowspanCell: function (mtd, tex, table, parser, env) {\n    mtd.appendChild(parser.create('node', 'mpadded', [this.cellBlock(tex, ParseUtil_js_1.default.copyNode(table, parser), parser, env), this.topRowTable(table, parser)], {\n      height: 0,\n      depth: 0,\n      voffset: 'height'\n    }));\n  },\n  left: function (table, original, left, parser, env) {\n    var e_3, _a;\n    if (env === void 0) {\n      env = '';\n    }\n    table.attributes.set('columnalign', 'right ' + (table.attributes.get('columnalign') || ''));\n    table.attributes.set('columnspacing', '0em ' + (table.attributes.get('columnspacing') || ''));\n    var mtd;\n    try {\n      for (var _b = __values(table.childNodes.slice(0).reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var row = _c.value;\n        mtd = parser.create('node', 'mtd');\n        row.childNodes.unshift(mtd);\n        mtd.parent = row;\n        if (row.isKind('mlabeledtr')) {\n          row.childNodes[0] = row.childNodes[1];\n          row.childNodes[1] = mtd;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    this.rowspanCell(mtd, left, original, parser, env);\n  },\n  right: function (table, original, right, parser, env) {\n    if (env === void 0) {\n      env = '';\n    }\n    if (table.childNodes.length === 0) {\n      table.appendChild(parser.create('node', 'mtr'));\n    }\n    var m = exports.EmpheqUtil.columnCount(table);\n    var row = table.childNodes[0];\n    while (row.childNodes.length < m) row.appendChild(parser.create('node', 'mtd'));\n    var mtd = row.appendChild(parser.create('node', 'mtd'));\n    exports.EmpheqUtil.rowspanCell(mtd, right, original, parser, env);\n    table.attributes.set('columnalign', (table.attributes.get('columnalign') || '').split(/ /).slice(0, m).join(' ') + ' left');\n    table.attributes.set('columnspacing', (table.attributes.get('columnspacing') || '').split(/ /).slice(0, m - 1).join(' ') + ' 0em');\n  },\n  adjustTable: function (empheq, parser) {\n    var left = empheq.getProperty('left');\n    var right = empheq.getProperty('right');\n    if (left || right) {\n      var table = empheq.Last;\n      var original = ParseUtil_js_1.default.copyNode(table, parser);\n      if (left) this.left(table, original, left, parser);\n      if (right) this.right(table, original, right, parser);\n    }\n  },\n  allowEnv: {\n    equation: true,\n    align: true,\n    gather: true,\n    flalign: true,\n    alignat: true,\n    multline: true\n  },\n  checkEnv: function (env) {\n    return this.allowEnv.hasOwnProperty(env.replace(/\\*$/, '')) || false;\n  }\n};","map":{"version":3,"names":["ParseUtil_js_1","__importDefault","require","TexParser_js_1","exports","EmpheqUtil","environment","parser","env","func","args","name","item","itemFactory","create","setProperties","end","Push","apply","__spreadArray","__read","slice","splitOptions","text","allowed","default","keyvalOptions","columnCount","table","m","_b","__values","childNodes","_c","next","done","row","value","n","length","isKind","cellBlock","tex","mpadded","height","depth","voffset","result","stack","configuration","mml","tags","label","currentTag","getTag","isInferred","child","appendChild","width","topRowTable","original","copyNode","setChildren","attributes","set","factory","rowspanCell","mtd","left","get","reverse","unshift","parent","right","split","join","adjustTable","empheq","getProperty","Last","allowEnv","equation","align","gather","flalign","alignat","multline","checkEnv","hasOwnProperty","replace"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/empheq/EmpheqUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2021-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Utilities file for the empheq package.\n *\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\n\nimport ParseUtil from '../ParseUtil.js';\nimport TexParser from '../TexParser.js';\nimport {EnvList} from '../StackItem.js';\nimport {AbstractTags} from '../Tags.js';\nimport {MmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMtable} from '../../../core/MmlTree/MmlNodes/mtable.js';\nimport {MmlMtd} from '../../../core/MmlTree/MmlNodes/mtd.js';\nimport {EmpheqBeginItem} from './EmpheqConfiguration.js';\n\nexport const EmpheqUtil = {\n\n  /**\n   * Create the needed envinronment and process it by the give function.\n   *\n   * @param {TexParser} parser   The active tex parser.\n   * @param {string} env         The environment to create.\n   * @param {Function} func      A function to process the environment.\n   * @param {any[]} args         The arguments for func.\n   */\n  environment(parser: TexParser, env: string, func: Function, args: any[]) {\n    const name = args[0];\n    const item = parser.itemFactory.create(name + '-begin').setProperties({name: env, end: name});\n    parser.Push(func(parser, item, ...args.slice(1)));\n  },\n\n  /**\n   * Parse an options string.\n   *\n   * @param {string} text                   The string to parse.\n   * @param {{[key:string]:number} allowed  Object containing options to allow\n   * @return {EnvList}                      The parsed keys\n   */\n  splitOptions(text: string, allowed: {[key: string]: number} = null): EnvList {\n    return ParseUtil.keyvalOptions(text, allowed, true);\n  },\n\n  /**\n   * Find the number of columns in the table.\n   *\n   * @param {MmlMtable} table   The table whose columns to count.\n   * @return {number}           The number of columns in the table.\n   */\n  columnCount(table: MmlMtable): number {\n    let m = 0;\n    for (const row of table.childNodes) {\n      const n = row.childNodes.length - (row.isKind('mlabeledtr') ? 1 : 0);\n      if (n > m) m = n;\n    }\n    return m;\n  },\n\n  /**\n   * Create an mpadded element with no height and depth, but whose\n   *   content is the given TeX code with a phantom that is the height and\n   *   depth of the given table.\n   *\n   * @param {string} tex        The TeX code to put in the box.\n   * @param {MmlTable} table    The table used to size the box.\n   * @param {TexParser} parser  The active tex parser.\n   * @param {string} env        The name of the current environment.\n   * @return {MmlNode}          The mpadded element.\n   */\n  cellBlock(tex: string, table: MmlMtable, parser: TexParser, env: string): MmlNode {\n    const mpadded = parser.create('node', 'mpadded', [], {height: 0, depth: 0, voffset: '-1height'});\n    const result = new TexParser(tex, parser.stack.env, parser.configuration);\n    const mml = result.mml();\n    if (env && result.configuration.tags.label) {\n      (result.configuration.tags.currentTag as any).env = env;\n      (result.configuration.tags as AbstractTags).getTag(true);\n    }\n    for (const child of (mml.isInferred ? mml.childNodes : [mml])) {\n      mpadded.appendChild(child);\n    }\n    mpadded.appendChild(parser.create('node', 'mphantom', [\n      parser.create('node', 'mpadded', [table], {width: 0})\n    ]));\n    return mpadded;\n  },\n\n  /**\n   * Make a copy of the table with only the first row and create a phantom element\n   *   that has its height and depth.\n   *\n   * @param {MmlMtable} original   The original table.\n   * @param {TexParser} parser     The active tex parser.\n   * @return {MmlNode}             The resulting mphantom element.\n   */\n  topRowTable(original: MmlMtable, parser: TexParser): MmlNode {\n    const table = ParseUtil.copyNode(original, parser);\n    table.setChildren(table.childNodes.slice(0, 1));\n    table.attributes.set('align', 'baseline 1');\n    return original.factory.create('mphantom', {}, [parser.create('node', 'mpadded', [table],  {width: 0})]);\n  },\n\n  /**\n   * Add an mpadded element that has zero height and depth but whose content is\n   *   the cell block for the given TeX code followed by a struct the size of the top row.\n   *\n   * @param {MmlMtd} mtd         The mtd to add content to.\n   * @param {string} tex         The TeX string to put into the cell.\n   * @param {MmlMtable} table    The reference table used for its various heights.\n   * @param {TexParser} parser   The active tex parser.\n   * @param {srting} env         The current environment.\n   */\n  rowspanCell(mtd: MmlMtd, tex: string, table: MmlMtable, parser: TexParser, env: string) {\n    mtd.appendChild(\n      parser.create('node', 'mpadded', [\n        this.cellBlock(tex, ParseUtil.copyNode(table, parser), parser, env),\n        this.topRowTable(table, parser)\n      ], {height: 0, depth: 0, voffset: 'height'})\n    );\n  },\n\n  /**\n   * Add something on the left of the original table.\n   *\n   * @param {MmlMtable} table     The table to modify.\n   * @param {MmlMtable} original  The original table.\n   * @param {string} left         The TeX code to add to the left.\n   * @param {TexParser} parser    The active tex parser.\n   * @param {string} env          The current environment.\n   */\n  left(table: MmlMtable, original: MmlMtable, left: string, parser: TexParser, env: string = '') {\n    table.attributes.set('columnalign', 'right ' + (table.attributes.get('columnalign') || ''));\n    table.attributes.set('columnspacing', '0em ' + (table.attributes.get('columnspacing') || ''));\n    let mtd;\n    for (const row of table.childNodes.slice(0).reverse()) {\n      mtd = parser.create('node', 'mtd');\n      row.childNodes.unshift(mtd);\n      mtd.parent = row;\n      if (row.isKind('mlabeledtr')) {\n        row.childNodes[0] = row.childNodes[1];\n        row.childNodes[1] = mtd;\n      }\n    }\n    this.rowspanCell(mtd, left, original, parser, env);\n  },\n\n  /**\n   * Add something on the right of the original table.\n   *\n   * @param {MmlMtable} table     The table to modify.\n   * @param {MmlMtable} original  The original table.\n   * @param {string} right        The TeX code to add to the right.\n   * @param {TexParser} parser    The active tex parser.\n   * @param {string} env          The current environment.\n   */\n  right(table: MmlMtable, original: MmlMtable, right: string, parser: TexParser, env: string = '') {\n    if (table.childNodes.length === 0) {\n      table.appendChild(parser.create('node', 'mtr'));\n    }\n    const m = EmpheqUtil.columnCount(table);\n    const row = table.childNodes[0];\n    while (row.childNodes.length < m) row.appendChild(parser.create('node', 'mtd'));\n    const mtd = row.appendChild(parser.create('node', 'mtd')) as MmlMtd;\n    EmpheqUtil.rowspanCell(mtd, right, original, parser, env);\n    table.attributes.set(\n      'columnalign',\n      (table.attributes.get('columnalign') as string || '').split(/ /).slice(0, m).join(' ') + ' left'\n    );\n    table.attributes.set(\n      'columnspacing',\n      (table.attributes.get('columnspacing') as string || '').split(/ /).slice(0, m - 1).join(' ') + ' 0em'\n    );\n  },\n\n  /**\n   * Add the left- and right-hand material to the table.\n   */\n  adjustTable(empheq: EmpheqBeginItem, parser: TexParser) {\n    const left = empheq.getProperty('left');\n    const right = empheq.getProperty('right');\n    if (left || right) {\n      const table = empheq.Last;\n      const original = ParseUtil.copyNode(table, parser);\n      if (left) this.left(table, original, left, parser);\n      if (right) this.right(table, original, right, parser);\n    }\n  },\n\n  /**\n   * The environments allowed to be used in the empheq environment.\n   */\n  allowEnv: {\n    equation: true,\n    align: true,\n    gather: true,\n    flalign: true,\n    alignat: true,\n    multline: true\n  },\n\n  /**\n   * Checks to see if the given environment is one of the allowed ones.\n   *\n   * @param {string} env   The environment to check.\n   * @return {boolean}     True if the environment is allowed.\n   */\n  checkEnv(env: string): boolean {\n    return this.allowEnv.hasOwnProperty(env.replace(/\\*$/, '')) || false;\n  }\n\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAAA,cAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,IAAAC,cAAA,GAAAF,eAAA,CAAAC,OAAA;AAQaE,OAAA,CAAAC,UAAU,GAAG;EAUxBC,WAAW,EAAX,SAAAA,CAAYC,MAAiB,EAAEC,GAAW,EAAEC,IAAc,EAAEC,IAAW;IACrE,IAAMC,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC;IACpB,IAAME,IAAI,GAAGL,MAAM,CAACM,WAAW,CAACC,MAAM,CAACH,IAAI,GAAG,QAAQ,CAAC,CAACI,aAAa,CAAC;MAACJ,IAAI,EAAEH,GAAG;MAAEQ,GAAG,EAAEL;IAAI,CAAC,CAAC;IAC7FJ,MAAM,CAACU,IAAI,CAACR,IAAI,CAAAS,KAAA,SAAAC,aAAA,EAACZ,MAAM,EAAEK,IAAI,GAAAQ,MAAA,CAAKV,IAAI,CAACW,KAAK,CAAC,CAAC,CAAC,WAAE;EACnD,CAAC;EASDC,YAAY,EAAZ,SAAAA,CAAaC,IAAY,EAAEC,OAAuC;IAAvC,IAAAA,OAAA;MAAAA,OAAA,OAAuC;IAAA;IAChE,OAAOxB,cAAA,CAAAyB,OAAS,CAACC,aAAa,CAACH,IAAI,EAAEC,OAAO,EAAE,IAAI,CAAC;EACrD,CAAC;EAQDG,WAAW,EAAX,SAAAA,CAAYC,KAAgB;;IAC1B,IAAIC,CAAC,GAAG,CAAC;;MACT,KAAkB,IAAAC,EAAA,GAAAC,QAAA,CAAAH,KAAK,CAACI,UAAU,GAAAC,EAAA,GAAAH,EAAA,CAAAI,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAH,EAAA,CAAAI,IAAA,IAAE;QAA/B,IAAME,GAAG,GAAAH,EAAA,CAAAI,KAAA;QACZ,IAAMC,CAAC,GAAGF,GAAG,CAACJ,UAAU,CAACO,MAAM,IAAIH,GAAG,CAACI,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACpE,IAAIF,CAAC,GAAGT,CAAC,EAAEA,CAAC,GAAGS,CAAC;;;;;;;;;;;;;IAElB,OAAOT,CAAC;EACV,CAAC;EAaDY,SAAS,EAAT,SAAAA,CAAUC,GAAW,EAAEd,KAAgB,EAAErB,MAAiB,EAAEC,GAAW;;IACrE,IAAMmC,OAAO,GAAGpC,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,EAAE;MAAC8B,MAAM,EAAE,CAAC;MAAEC,KAAK,EAAE,CAAC;MAAEC,OAAO,EAAE;IAAU,CAAC,CAAC;IAChG,IAAMC,MAAM,GAAG,IAAI5C,cAAA,CAAAsB,OAAS,CAACiB,GAAG,EAAEnC,MAAM,CAACyC,KAAK,CAACxC,GAAG,EAAED,MAAM,CAAC0C,aAAa,CAAC;IACzE,IAAMC,GAAG,GAAGH,MAAM,CAACG,GAAG,EAAE;IACxB,IAAI1C,GAAG,IAAIuC,MAAM,CAACE,aAAa,CAACE,IAAI,CAACC,KAAK,EAAE;MACzCL,MAAM,CAACE,aAAa,CAACE,IAAI,CAACE,UAAkB,CAAC7C,GAAG,GAAGA,GAAG;MACtDuC,MAAM,CAACE,aAAa,CAACE,IAAqB,CAACG,MAAM,CAAC,IAAI,CAAC;;;MAE1D,KAAoB,IAAAxB,EAAA,GAAAC,QAAA,CAACmB,GAAG,CAACK,UAAU,GAAGL,GAAG,CAAClB,UAAU,GAAG,CAACkB,GAAG,CAAE,GAAAjB,EAAA,GAAAH,EAAA,CAAAI,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAH,EAAA,CAAAI,IAAA,IAAE;QAA1D,IAAMsB,KAAK,GAAAvB,EAAA,CAAAI,KAAA;QACdM,OAAO,CAACc,WAAW,CAACD,KAAK,CAAC;;;;;;;;;;;;;IAE5Bb,OAAO,CAACc,WAAW,CAAClD,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,UAAU,EAAE,CACpDP,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,CAACc,KAAK,CAAC,EAAE;MAAC8B,KAAK,EAAE;IAAC,CAAC,CAAC,CACtD,CAAC,CAAC;IACH,OAAOf,OAAO;EAChB,CAAC;EAUDgB,WAAW,EAAX,SAAAA,CAAYC,QAAmB,EAAErD,MAAiB;IAChD,IAAMqB,KAAK,GAAG5B,cAAA,CAAAyB,OAAS,CAACoC,QAAQ,CAACD,QAAQ,EAAErD,MAAM,CAAC;IAClDqB,KAAK,CAACkC,WAAW,CAAClC,KAAK,CAACI,UAAU,CAACX,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/CO,KAAK,CAACmC,UAAU,CAACC,GAAG,CAAC,OAAO,EAAE,YAAY,CAAC;IAC3C,OAAOJ,QAAQ,CAACK,OAAO,CAACnD,MAAM,CAAC,UAAU,EAAE,EAAE,EAAE,CAACP,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,CAACc,KAAK,CAAC,EAAG;MAAC8B,KAAK,EAAE;IAAC,CAAC,CAAC,CAAC,CAAC;EAC1G,CAAC;EAYDQ,WAAW,EAAX,SAAAA,CAAYC,GAAW,EAAEzB,GAAW,EAAEd,KAAgB,EAAErB,MAAiB,EAAEC,GAAW;IACpF2D,GAAG,CAACV,WAAW,CACblD,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,CAC/B,IAAI,CAAC2B,SAAS,CAACC,GAAG,EAAE1C,cAAA,CAAAyB,OAAS,CAACoC,QAAQ,CAACjC,KAAK,EAAErB,MAAM,CAAC,EAAEA,MAAM,EAAEC,GAAG,CAAC,EACnE,IAAI,CAACmD,WAAW,CAAC/B,KAAK,EAAErB,MAAM,CAAC,CAChC,EAAE;MAACqC,MAAM,EAAE,CAAC;MAAEC,KAAK,EAAE,CAAC;MAAEC,OAAO,EAAE;IAAQ,CAAC,CAAC,CAC7C;EACH,CAAC;EAWDsB,IAAI,EAAJ,SAAAA,CAAKxC,KAAgB,EAAEgC,QAAmB,EAAEQ,IAAY,EAAE7D,MAAiB,EAAEC,GAAgB;;IAAhB,IAAAA,GAAA;MAAAA,GAAA,KAAgB;IAAA;IAC3FoB,KAAK,CAACmC,UAAU,CAACC,GAAG,CAAC,aAAa,EAAE,QAAQ,IAAIpC,KAAK,CAACmC,UAAU,CAACM,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3FzC,KAAK,CAACmC,UAAU,CAACC,GAAG,CAAC,eAAe,EAAE,MAAM,IAAIpC,KAAK,CAACmC,UAAU,CAACM,GAAG,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC;IAC7F,IAAIF,GAAG;;MACP,KAAkB,IAAArC,EAAA,GAAAC,QAAA,CAAAH,KAAK,CAACI,UAAU,CAACX,KAAK,CAAC,CAAC,CAAC,CAACiD,OAAO,EAAE,GAAArC,EAAA,GAAAH,EAAA,CAAAI,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAH,EAAA,CAAAI,IAAA,IAAE;QAAlD,IAAME,GAAG,GAAAH,EAAA,CAAAI,KAAA;QACZ8B,GAAG,GAAG5D,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC;QAClCsB,GAAG,CAACJ,UAAU,CAACuC,OAAO,CAACJ,GAAG,CAAC;QAC3BA,GAAG,CAACK,MAAM,GAAGpC,GAAG;QAChB,IAAIA,GAAG,CAACI,MAAM,CAAC,YAAY,CAAC,EAAE;UAC5BJ,GAAG,CAACJ,UAAU,CAAC,CAAC,CAAC,GAAGI,GAAG,CAACJ,UAAU,CAAC,CAAC,CAAC;UACrCI,GAAG,CAACJ,UAAU,CAAC,CAAC,CAAC,GAAGmC,GAAG;;;;;;;;;;;;;;IAG3B,IAAI,CAACD,WAAW,CAACC,GAAG,EAAEC,IAAI,EAAER,QAAQ,EAAErD,MAAM,EAAEC,GAAG,CAAC;EACpD,CAAC;EAWDiE,KAAK,EAAL,SAAAA,CAAM7C,KAAgB,EAAEgC,QAAmB,EAAEa,KAAa,EAAElE,MAAiB,EAAEC,GAAgB;IAAhB,IAAAA,GAAA;MAAAA,GAAA,KAAgB;IAAA;IAC7F,IAAIoB,KAAK,CAACI,UAAU,CAACO,MAAM,KAAK,CAAC,EAAE;MACjCX,KAAK,CAAC6B,WAAW,CAAClD,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;;IAEjD,IAAMe,CAAC,GAAGzB,OAAA,CAAAC,UAAU,CAACsB,WAAW,CAACC,KAAK,CAAC;IACvC,IAAMQ,GAAG,GAAGR,KAAK,CAACI,UAAU,CAAC,CAAC,CAAC;IAC/B,OAAOI,GAAG,CAACJ,UAAU,CAACO,MAAM,GAAGV,CAAC,EAAEO,GAAG,CAACqB,WAAW,CAAClD,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC/E,IAAMqD,GAAG,GAAG/B,GAAG,CAACqB,WAAW,CAAClD,MAAM,CAACO,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAW;IACnEV,OAAA,CAAAC,UAAU,CAAC6D,WAAW,CAACC,GAAG,EAAEM,KAAK,EAAEb,QAAQ,EAAErD,MAAM,EAAEC,GAAG,CAAC;IACzDoB,KAAK,CAACmC,UAAU,CAACC,GAAG,CAClB,aAAa,EACb,CAACpC,KAAK,CAACmC,UAAU,CAACM,GAAG,CAAC,aAAa,CAAW,IAAI,EAAE,EAAEK,KAAK,CAAC,GAAG,CAAC,CAACrD,KAAK,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC8C,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CACjG;IACD/C,KAAK,CAACmC,UAAU,CAACC,GAAG,CAClB,eAAe,EACf,CAACpC,KAAK,CAACmC,UAAU,CAACM,GAAG,CAAC,eAAe,CAAW,IAAI,EAAE,EAAEK,KAAK,CAAC,GAAG,CAAC,CAACrD,KAAK,CAAC,CAAC,EAAEQ,CAAC,GAAG,CAAC,CAAC,CAAC8C,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,CACtG;EACH,CAAC;EAKDC,WAAW,EAAX,SAAAA,CAAYC,MAAuB,EAAEtE,MAAiB;IACpD,IAAM6D,IAAI,GAAGS,MAAM,CAACC,WAAW,CAAC,MAAM,CAAC;IACvC,IAAML,KAAK,GAAGI,MAAM,CAACC,WAAW,CAAC,OAAO,CAAC;IACzC,IAAIV,IAAI,IAAIK,KAAK,EAAE;MACjB,IAAM7C,KAAK,GAAGiD,MAAM,CAACE,IAAI;MACzB,IAAMnB,QAAQ,GAAG5D,cAAA,CAAAyB,OAAS,CAACoC,QAAQ,CAACjC,KAAK,EAAErB,MAAM,CAAC;MAClD,IAAI6D,IAAI,EAAE,IAAI,CAACA,IAAI,CAACxC,KAAK,EAAEgC,QAAQ,EAAEQ,IAAI,EAAE7D,MAAM,CAAC;MAClD,IAAIkE,KAAK,EAAE,IAAI,CAACA,KAAK,CAAC7C,KAAK,EAAEgC,QAAQ,EAAEa,KAAK,EAAElE,MAAM,CAAC;;EAEzD,CAAC;EAKDyE,QAAQ,EAAE;IACRC,QAAQ,EAAE,IAAI;IACdC,KAAK,EAAE,IAAI;IACXC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,IAAI;IACbC,OAAO,EAAE,IAAI;IACbC,QAAQ,EAAE;GACX;EAQDC,QAAQ,EAAR,SAAAA,CAAS/E,GAAW;IAClB,OAAO,IAAI,CAACwE,QAAQ,CAACQ,cAAc,CAAChF,GAAG,CAACiF,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,IAAI,KAAK;EACtE;CAED"},"metadata":{},"sourceType":"script","externalDependencies":[]}