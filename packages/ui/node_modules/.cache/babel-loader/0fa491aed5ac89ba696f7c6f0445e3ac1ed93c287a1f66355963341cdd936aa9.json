{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BaseMethods_js_1 = __importDefault(require(\"../base/BaseMethods.js\"));\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar NodeUtil_js_1 = __importDefault(require(\"../NodeUtil.js\"));\nvar NodeFactory_js_1 = require(\"../NodeFactory.js\");\nvar PhysicsMethods = {};\nvar pairs = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  '|': '|'\n};\nvar biggs = /^(b|B)i(g{1,2})$/;\nPhysicsMethods.Quantity = function (parser, name, open, close, arg, named, variant) {\n  if (open === void 0) {\n    open = '(';\n  }\n  if (close === void 0) {\n    close = ')';\n  }\n  if (arg === void 0) {\n    arg = false;\n  }\n  if (named === void 0) {\n    named = '';\n  }\n  if (variant === void 0) {\n    variant = '';\n  }\n  var star = arg ? parser.GetStar() : false;\n  var next = parser.GetNext();\n  var position = parser.i;\n  var big = null;\n  if (next === '\\\\') {\n    parser.i++;\n    big = parser.GetCS();\n    if (!big.match(biggs)) {\n      var empty = parser.create('node', 'mrow');\n      parser.Push(ParseUtil_js_1.default.fenced(parser.configuration, open, empty, close));\n      parser.i = position;\n      return;\n    }\n    next = parser.GetNext();\n  }\n  var right = pairs[next];\n  if (arg && next !== '{') {\n    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (!right) {\n    var empty = parser.create('node', 'mrow');\n    parser.Push(ParseUtil_js_1.default.fenced(parser.configuration, open, empty, close));\n    parser.i = position;\n    return;\n  }\n  if (named) {\n    var mml = parser.create('token', 'mi', {\n      texClass: MmlNode_js_1.TEXCLASS.OP\n    }, named);\n    if (variant) {\n      NodeUtil_js_1.default.setAttribute(mml, 'mathvariant', variant);\n    }\n    parser.Push(parser.itemFactory.create('fn', mml));\n  }\n  if (next === '{') {\n    var argument = parser.GetArgument(name);\n    next = arg ? open : '\\\\{';\n    right = arg ? close : '\\\\}';\n    argument = star ? next + ' ' + argument + ' ' + right : big ? '\\\\' + big + 'l' + next + ' ' + argument + ' ' + '\\\\' + big + 'r' + right : '\\\\left' + next + ' ' + argument + ' ' + '\\\\right' + right;\n    parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());\n    return;\n  }\n  if (arg) {\n    next = open;\n    right = close;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open').setProperties({\n    open: next,\n    close: right,\n    big: big\n  }));\n};\nPhysicsMethods.Eval = function (parser, name) {\n  var star = parser.GetStar();\n  var next = parser.GetNext();\n  if (next === '{') {\n    var arg = parser.GetArgument(name);\n    var replace = '\\\\left. ' + (star ? '\\\\smash{' + arg + '}' : arg) + ' ' + '\\\\vphantom{\\\\int}\\\\right|';\n    parser.string = parser.string.slice(0, parser.i) + replace + parser.string.slice(parser.i);\n    return;\n  }\n  if (next === '(' || next === '[') {\n    parser.i++;\n    parser.Push(parser.itemFactory.create('auto open').setProperties({\n      open: next,\n      close: '|',\n      smash: star,\n      right: '\\\\vphantom{\\\\int}'\n    }));\n    return;\n  }\n  throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n};\nPhysicsMethods.Commutator = function (parser, name, open, close) {\n  if (open === void 0) {\n    open = '[';\n  }\n  if (close === void 0) {\n    close = ']';\n  }\n  var star = parser.GetStar();\n  var next = parser.GetNext();\n  var big = null;\n  if (next === '\\\\') {\n    parser.i++;\n    big = parser.GetCS();\n    if (!big.match(biggs)) {\n      throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n    }\n    next = parser.GetNext();\n  }\n  if (next !== '{') {\n    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  var arg1 = parser.GetArgument(name);\n  var arg2 = parser.GetArgument(name);\n  var argument = arg1 + ',' + arg2;\n  argument = star ? open + ' ' + argument + ' ' + close : big ? '\\\\' + big + 'l' + open + ' ' + argument + ' ' + '\\\\' + big + 'r' + close : '\\\\left' + open + ' ' + argument + ' ' + '\\\\right' + close;\n  parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());\n};\nvar latinCap = [0x41, 0x5A];\nvar latinSmall = [0x61, 0x7A];\nvar greekCap = [0x391, 0x3A9];\nvar greekSmall = [0x3B1, 0x3C9];\nvar digits = [0x30, 0x39];\nfunction inRange(value, range) {\n  return value >= range[0] && value <= range[1];\n}\nfunction createVectorToken(factory, kind, def, text) {\n  var parser = factory.configuration.parser;\n  var token = NodeFactory_js_1.NodeFactory.createToken(factory, kind, def, text);\n  var code = text.codePointAt(0);\n  if (text.length === 1 && !parser.stack.env.font && parser.stack.env.vectorFont && (inRange(code, latinCap) || inRange(code, latinSmall) || inRange(code, greekCap) || inRange(code, digits) || inRange(code, greekSmall) && parser.stack.env.vectorStar || NodeUtil_js_1.default.getAttribute(token, 'accent'))) {\n    NodeUtil_js_1.default.setAttribute(token, 'mathvariant', parser.stack.env.vectorFont);\n  }\n  return token;\n}\nPhysicsMethods.VectorBold = function (parser, name) {\n  var star = parser.GetStar();\n  var arg = parser.GetArgument(name);\n  var oldToken = parser.configuration.nodeFactory.get('token');\n  var oldFont = parser.stack.env.font;\n  delete parser.stack.env.font;\n  parser.configuration.nodeFactory.set('token', createVectorToken);\n  parser.stack.env.vectorFont = star ? 'bold-italic' : 'bold';\n  parser.stack.env.vectorStar = star;\n  var node = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n  if (oldFont) {\n    parser.stack.env.font = oldFont;\n  }\n  delete parser.stack.env.vectorFont;\n  delete parser.stack.env.vectorStar;\n  parser.configuration.nodeFactory.set('token', oldToken);\n  parser.Push(node);\n};\nPhysicsMethods.StarMacro = function (parser, name, argcount) {\n  var parts = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    parts[_i - 3] = arguments[_i];\n  }\n  var star = parser.GetStar();\n  var args = [];\n  if (argcount) {\n    for (var i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n  }\n  var macro = parts.join(star ? '*' : '');\n  macro = ParseUtil_js_1.default.substituteArgs(parser, args, macro);\n  parser.string = ParseUtil_js_1.default.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil_js_1.default.checkMaxMacros(parser);\n};\nvar vectorApplication = function (parser, kind, name, operator, fences) {\n  var op = new TexParser_js_1.default(operator, parser.stack.env, parser.configuration).mml();\n  parser.Push(parser.itemFactory.create(kind, op));\n  var left = parser.GetNext();\n  var right = pairs[left];\n  if (!right) {\n    return;\n  }\n  var lfence = '',\n    rfence = '',\n    arg = '';\n  var enlarge = fences.indexOf(left) !== -1;\n  if (left === '{') {\n    arg = parser.GetArgument(name);\n    lfence = enlarge ? '\\\\left\\\\{' : '';\n    rfence = enlarge ? '\\\\right\\\\}' : '';\n    var macro = lfence + ' ' + arg + ' ' + rfence;\n    parser.string = macro + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  if (!enlarge) {\n    return;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open').setProperties({\n    open: left,\n    close: right\n  }));\n};\nPhysicsMethods.OperatorApplication = function (parser, name, operator) {\n  var fences = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    fences[_i - 3] = arguments[_i];\n  }\n  vectorApplication(parser, 'fn', name, operator, fences);\n};\nPhysicsMethods.VectorOperator = function (parser, name, operator) {\n  var fences = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    fences[_i - 3] = arguments[_i];\n  }\n  vectorApplication(parser, 'mml', name, operator, fences);\n};\nPhysicsMethods.Expression = function (parser, name, opt, id) {\n  if (opt === void 0) {\n    opt = true;\n  }\n  if (id === void 0) {\n    id = '';\n  }\n  id = id || name.slice(1);\n  var exp = opt ? parser.GetBrackets(name) : null;\n  var mml = parser.create('token', 'mi', {\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  if (exp) {\n    var sup = new TexParser_js_1.default(exp, parser.stack.env, parser.configuration).mml();\n    mml = parser.create('node', 'msup', [mml, sup]);\n  }\n  parser.Push(parser.itemFactory.create('fn', mml));\n  if (parser.GetNext() !== '(') {\n    return;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open').setProperties({\n    open: '(',\n    close: ')'\n  }));\n};\nPhysicsMethods.Qqtext = function (parser, name, text) {\n  var star = parser.GetStar();\n  var arg = text ? text : parser.GetArgument(name);\n  var replace = (star ? '' : '\\\\quad') + '\\\\text{' + arg + '}\\\\quad ';\n  parser.string = parser.string.slice(0, parser.i) + replace + parser.string.slice(parser.i);\n};\nPhysicsMethods.Differential = function (parser, name, op) {\n  var optArg = parser.GetBrackets(name);\n  var power = optArg != null ? '^{' + optArg + '}' : ' ';\n  var parens = parser.GetNext() === '(';\n  var braces = parser.GetNext() === '{';\n  var macro = op + power;\n  if (!(parens || braces)) {\n    macro += parser.GetArgument(name, true) || '';\n    var mml = new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml();\n    parser.Push(mml);\n    return;\n  }\n  if (braces) {\n    macro += parser.GetArgument(name);\n    var mml = new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml();\n    parser.Push(parser.create('node', 'TeXAtom', [mml], {\n      texClass: MmlNode_js_1.TEXCLASS.OP\n    }));\n    return;\n  }\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open').setProperties({\n    open: '(',\n    close: ')'\n  }));\n};\nPhysicsMethods.Derivative = function (parser, name, argMax, op) {\n  var star = parser.GetStar();\n  var optArg = parser.GetBrackets(name);\n  var argCounter = 1;\n  var args = [];\n  args.push(parser.GetArgument(name));\n  while (parser.GetNext() === '{' && argCounter < argMax) {\n    args.push(parser.GetArgument(name));\n    argCounter++;\n  }\n  var ignore = false;\n  var power1 = ' ';\n  var power2 = ' ';\n  if (argMax > 2 && args.length > 2) {\n    power1 = '^{' + (args.length - 1) + '}';\n    ignore = true;\n  } else if (optArg != null) {\n    if (argMax > 2 && args.length > 1) {\n      ignore = true;\n    }\n    power1 = '^{' + optArg + '}';\n    power2 = power1;\n  }\n  var frac = star ? '\\\\flatfrac' : '\\\\frac';\n  var first = args.length > 1 ? args[0] : '';\n  var second = args.length > 1 ? args[1] : args[0];\n  var rest = '';\n  for (var i = 2, arg = void 0; arg = args[i]; i++) {\n    rest += op + ' ' + arg;\n  }\n  var macro = frac + '{' + op + power1 + first + '}' + '{' + op + ' ' + second + power2 + ' ' + rest + '}';\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n  if (parser.GetNext() === '(') {\n    parser.i++;\n    parser.Push(parser.itemFactory.create('auto open').setProperties({\n      open: '(',\n      close: ')',\n      ignore: ignore\n    }));\n  }\n};\nPhysicsMethods.Bra = function (parser, name) {\n  var starBra = parser.GetStar();\n  var bra = parser.GetArgument(name);\n  var ket = '';\n  var hasKet = false;\n  var starKet = false;\n  if (parser.GetNext() === '\\\\') {\n    var saveI = parser.i;\n    parser.i++;\n    var cs = parser.GetCS();\n    var symbol = parser.lookup('macro', cs);\n    if (symbol && symbol.symbol === 'ket') {\n      hasKet = true;\n      saveI = parser.i;\n      starKet = parser.GetStar();\n      if (parser.GetNext() === '{') {\n        ket = parser.GetArgument(cs, true);\n      } else {\n        parser.i = saveI;\n        starKet = false;\n      }\n    } else {\n      parser.i = saveI;\n    }\n  }\n  var macro = '';\n  if (hasKet) {\n    macro = starBra || starKet ? \"\\\\langle{\".concat(bra, \"}\\\\vert{\").concat(ket, \"}\\\\rangle\") : \"\\\\left\\\\langle{\".concat(bra, \"}\\\\middle\\\\vert{\").concat(ket, \"}\\\\right\\\\rangle\");\n  } else {\n    macro = starBra || starKet ? \"\\\\langle{\".concat(bra, \"}\\\\vert\") : \"\\\\left\\\\langle{\".concat(bra, \"}\\\\right\\\\vert{\").concat(ket, \"}\");\n  }\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.Ket = function (parser, name) {\n  var star = parser.GetStar();\n  var ket = parser.GetArgument(name);\n  var macro = star ? \"\\\\vert{\".concat(ket, \"}\\\\rangle\") : \"\\\\left\\\\vert{\".concat(ket, \"}\\\\right\\\\rangle\");\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.BraKet = function (parser, name) {\n  var star = parser.GetStar();\n  var bra = parser.GetArgument(name);\n  var ket = null;\n  if (parser.GetNext() === '{') {\n    ket = parser.GetArgument(name, true);\n  }\n  var macro = '';\n  if (ket == null) {\n    macro = star ? \"\\\\langle{\".concat(bra, \"}\\\\vert{\").concat(bra, \"}\\\\rangle\") : \"\\\\left\\\\langle{\".concat(bra, \"}\\\\middle\\\\vert{\").concat(bra, \"}\\\\right\\\\rangle\");\n  } else {\n    macro = star ? \"\\\\langle{\".concat(bra, \"}\\\\vert{\").concat(ket, \"}\\\\rangle\") : \"\\\\left\\\\langle{\".concat(bra, \"}\\\\middle\\\\vert{\").concat(ket, \"}\\\\right\\\\rangle\");\n  }\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.KetBra = function (parser, name) {\n  var star = parser.GetStar();\n  var ket = parser.GetArgument(name);\n  var bra = null;\n  if (parser.GetNext() === '{') {\n    bra = parser.GetArgument(name, true);\n  }\n  var macro = '';\n  if (bra == null) {\n    macro = star ? \"\\\\vert{\".concat(ket, \"}\\\\rangle\\\\!\\\\langle{\").concat(ket, \"}\\\\vert\") : \"\\\\left\\\\vert{\".concat(ket, \"}\\\\middle\\\\rangle\\\\!\\\\middle\\\\langle{\").concat(ket, \"}\\\\right\\\\vert\");\n  } else {\n    macro = star ? \"\\\\vert{\".concat(ket, \"}\\\\rangle\\\\!\\\\langle{\").concat(bra, \"}\\\\vert\") : \"\\\\left\\\\vert{\".concat(ket, \"}\\\\middle\\\\rangle\\\\!\\\\middle\\\\langle{\").concat(bra, \"}\\\\right\\\\vert\");\n  }\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nfunction outputBraket(_a, star1, star2) {\n  var _b = __read(_a, 3),\n    arg1 = _b[0],\n    arg2 = _b[1],\n    arg3 = _b[2];\n  return star1 && star2 ? \"\\\\left\\\\langle{\".concat(arg1, \"}\\\\middle\\\\vert{\").concat(arg2, \"}\\\\middle\\\\vert{\").concat(arg3, \"}\\\\right\\\\rangle\") : star1 ? \"\\\\langle{\".concat(arg1, \"}\\\\vert{\").concat(arg2, \"}\\\\vert{\").concat(arg3, \"}\\\\rangle\") : \"\\\\left\\\\langle{\".concat(arg1, \"}\\\\right\\\\vert{\").concat(arg2, \"}\\\\left\\\\vert{\").concat(arg3, \"}\\\\right\\\\rangle\");\n}\nPhysicsMethods.Expectation = function (parser, name) {\n  var star1 = parser.GetStar();\n  var star2 = star1 && parser.GetStar();\n  var arg1 = parser.GetArgument(name);\n  var arg2 = null;\n  if (parser.GetNext() === '{') {\n    arg2 = parser.GetArgument(name, true);\n  }\n  var macro = arg1 && arg2 ? outputBraket([arg2, arg1, arg2], star1, star2) : star1 ? \"\\\\langle {\".concat(arg1, \"} \\\\rangle\") : \"\\\\left\\\\langle {\".concat(arg1, \"} \\\\right\\\\rangle\");\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.MatrixElement = function (parser, name) {\n  var star1 = parser.GetStar();\n  var star2 = star1 && parser.GetStar();\n  var arg1 = parser.GetArgument(name);\n  var arg2 = parser.GetArgument(name);\n  var arg3 = parser.GetArgument(name);\n  var macro = outputBraket([arg1, arg2, arg3], star1, star2);\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.MatrixQuantity = function (parser, name, small) {\n  var star = parser.GetStar();\n  var next = parser.GetNext();\n  var array = small ? 'smallmatrix' : 'array';\n  var arg = '';\n  var open = '';\n  var close = '';\n  switch (next) {\n    case '{':\n      arg = parser.GetArgument(name);\n      break;\n    case '(':\n      parser.i++;\n      open = star ? '\\\\lgroup' : '(';\n      close = star ? '\\\\rgroup' : ')';\n      arg = parser.GetUpTo(name, ')');\n      break;\n    case '[':\n      parser.i++;\n      open = '[';\n      close = ']';\n      arg = parser.GetUpTo(name, ']');\n      break;\n    case '|':\n      parser.i++;\n      open = '|';\n      close = '|';\n      arg = parser.GetUpTo(name, '|');\n      break;\n    default:\n      open = '(';\n      close = ')';\n      break;\n  }\n  var macro = (open ? '\\\\left' : '') + open + '\\\\begin{' + array + '}{} ' + arg + '\\\\end{' + array + '}' + (open ? '\\\\right' : '') + close;\n  parser.Push(new TexParser_js_1.default(macro, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.IdentityMatrix = function (parser, name) {\n  var arg = parser.GetArgument(name);\n  var size = parseInt(arg, 10);\n  if (isNaN(size)) {\n    throw new TexError_js_1.default('InvalidNumber', 'Invalid number');\n  }\n  if (size <= 1) {\n    parser.string = '1' + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  var zeros = Array(size).fill('0');\n  var columns = [];\n  for (var i = 0; i < size; i++) {\n    var row = zeros.slice();\n    row[i] = '1';\n    columns.push(row.join(' & '));\n  }\n  parser.string = columns.join('\\\\\\\\ ') + parser.string.slice(parser.i);\n  parser.i = 0;\n};\nPhysicsMethods.XMatrix = function (parser, name) {\n  var star = parser.GetStar();\n  var arg1 = parser.GetArgument(name);\n  var arg2 = parser.GetArgument(name);\n  var arg3 = parser.GetArgument(name);\n  var n = parseInt(arg2, 10);\n  var m = parseInt(arg3, 10);\n  if (isNaN(n) || isNaN(m) || m.toString() !== arg3 || n.toString() !== arg2) {\n    throw new TexError_js_1.default('InvalidNumber', 'Invalid number');\n  }\n  n = n < 1 ? 1 : n;\n  m = m < 1 ? 1 : m;\n  if (!star) {\n    var row = Array(m).fill(arg1).join(' & ');\n    var matrix_1 = Array(n).fill(row).join('\\\\\\\\ ');\n    parser.string = matrix_1 + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  var matrix = '';\n  if (n === 1 && m === 1) {\n    matrix = arg1;\n  } else if (n === 1) {\n    var row = [];\n    for (var i = 1; i <= m; i++) {\n      row.push(\"\".concat(arg1, \"_{\").concat(i, \"}\"));\n    }\n    matrix = row.join(' & ');\n  } else if (m === 1) {\n    var row = [];\n    for (var i = 1; i <= n; i++) {\n      row.push(\"\".concat(arg1, \"_{\").concat(i, \"}\"));\n    }\n    matrix = row.join('\\\\\\\\ ');\n  } else {\n    var rows = [];\n    for (var i = 1; i <= n; i++) {\n      var row = [];\n      for (var j = 1; j <= m; j++) {\n        row.push(\"\".concat(arg1, \"_{{\").concat(i, \"}{\").concat(j, \"}}\"));\n      }\n      rows.push(row.join(' & '));\n    }\n    matrix = rows.join('\\\\\\\\ ');\n  }\n  parser.string = matrix + parser.string.slice(parser.i);\n  parser.i = 0;\n  return;\n};\nPhysicsMethods.PauliMatrix = function (parser, name) {\n  var arg = parser.GetArgument(name);\n  var matrix = arg.slice(1);\n  switch (arg[0]) {\n    case '0':\n      matrix += ' 1 & 0\\\\\\\\ 0 & 1';\n      break;\n    case '1':\n    case 'x':\n      matrix += ' 0 & 1\\\\\\\\ 1 & 0';\n      break;\n    case '2':\n    case 'y':\n      matrix += ' 0 & -i\\\\\\\\ i & 0';\n      break;\n    case '3':\n    case 'z':\n      matrix += ' 1 & 0\\\\\\\\ 0 & -1';\n      break;\n    default:\n  }\n  parser.string = matrix + parser.string.slice(parser.i);\n  parser.i = 0;\n};\nPhysicsMethods.DiagonalMatrix = function (parser, name, anti) {\n  if (parser.GetNext() !== '{') {\n    return;\n  }\n  var startI = parser.i;\n  parser.GetArgument(name);\n  var endI = parser.i;\n  parser.i = startI + 1;\n  var elements = [];\n  var element = '';\n  var currentI = parser.i;\n  while (currentI < endI) {\n    try {\n      element = parser.GetUpTo(name, ',');\n    } catch (e) {\n      parser.i = endI;\n      elements.push(parser.string.slice(currentI, endI - 1));\n      break;\n    }\n    if (parser.i >= endI) {\n      elements.push(parser.string.slice(currentI, endI));\n      break;\n    }\n    currentI = parser.i;\n    elements.push(element);\n  }\n  parser.string = makeDiagMatrix(elements, anti) + parser.string.slice(endI);\n  parser.i = 0;\n};\nfunction makeDiagMatrix(elements, anti) {\n  var length = elements.length;\n  var matrix = [];\n  for (var i = 0; i < length; i++) {\n    matrix.push(Array(anti ? length - i : i + 1).join('&') + '\\\\mqty{' + elements[i] + '}');\n  }\n  return matrix.join('\\\\\\\\ ');\n}\nPhysicsMethods.AutoClose = function (parser, fence, _texclass) {\n  var mo = parser.create('token', 'mo', {\n    stretchy: false\n  }, fence);\n  var item = parser.itemFactory.create('mml', mo).setProperties({\n    autoclose: fence\n  });\n  parser.Push(item);\n};\nPhysicsMethods.Vnabla = function (parser, _name) {\n  var argument = parser.options.physics.arrowdel ? '\\\\vec{\\\\gradientnabla}' : '{\\\\gradientnabla}';\n  return parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.DiffD = function (parser, _name) {\n  var argument = parser.options.physics.italicdiff ? 'd' : '{\\\\rm d}';\n  return parser.Push(new TexParser_js_1.default(argument, parser.stack.env, parser.configuration).mml());\n};\nPhysicsMethods.Macro = BaseMethods_js_1.default.Macro;\nPhysicsMethods.NamedFn = BaseMethods_js_1.default.NamedFn;\nPhysicsMethods.Array = BaseMethods_js_1.default.Array;\nexports.default = PhysicsMethods;","map":{"version":3,"names":["BaseMethods_js_1","__importDefault","require","TexParser_js_1","TexError_js_1","MmlNode_js_1","ParseUtil_js_1","NodeUtil_js_1","NodeFactory_js_1","PhysicsMethods","pairs","biggs","Quantity","parser","name","open","close","arg","named","variant","star","GetStar","next","GetNext","position","i","big","GetCS","match","empty","create","Push","default","fenced","configuration","right","currentCS","mml","texClass","TEXCLASS","OP","setAttribute","itemFactory","argument","GetArgument","stack","env","setProperties","Eval","replace","string","slice","smash","Commutator","arg1","arg2","latinCap","latinSmall","greekCap","greekSmall","digits","inRange","value","range","createVectorToken","factory","kind","def","text","token","NodeFactory","createToken","code","codePointAt","length","font","vectorFont","vectorStar","getAttribute","VectorBold","oldToken","nodeFactory","get","oldFont","set","node","StarMacro","argcount","parts","_i","arguments","args","push","macro","join","substituteArgs","addArgs","checkMaxMacros","vectorApplication","operator","fences","op","left","lfence","rfence","enlarge","indexOf","OperatorApplication","VectorOperator","Expression","opt","id","exp","GetBrackets","sup","Qqtext","Differential","optArg","power","parens","braces","Derivative","argMax","argCounter","ignore","power1","power2","frac","first","second","rest","Bra","starBra","bra","ket","hasKet","starKet","saveI","cs","symbol","lookup","concat","Ket","BraKet","KetBra","outputBraket","_a","star1","star2","_b","__read","arg3","Expectation","MatrixElement","MatrixQuantity","small","array","GetUpTo","IdentityMatrix","size","parseInt","isNaN","zeros","Array","fill","columns","row","XMatrix","n","m","toString","matrix_1","matrix","rows","j","PauliMatrix","DiagonalMatrix","anti","startI","endI","elements","element","currentI","e","makeDiagMatrix","AutoClose","fence","_texclass","mo","stretchy","item","autoclose","Vnabla","_name","options","physics","arrowdel","DiffD","italicdiff","Macro","NamedFn","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/physics/PhysicsMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Methods for TeX parsing of the physics package.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {ParseMethod} from '../Types.js';\nimport BaseMethods from '../base/BaseMethods.js';\nimport TexParser from '../TexParser.js';\nimport TexError from '../TexError.js';\nimport {TEXCLASS, MmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport ParseUtil from '../ParseUtil.js';\nimport NodeUtil from '../NodeUtil.js';\nimport {NodeFactory} from '../NodeFactory.js';\nimport {Macro} from '../Symbol.js';\n\n\nlet PhysicsMethods: Record<string, ParseMethod> = {};\n\n\n/***********************\n * Physics package section 2.1\n * Automatic bracing\n */\n\n/**\n * Pairs open and closed fences.\n * @type {{[fence: string]: string}}\n */\nconst pairs: {[fence: string]: string} = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  '|': '|',\n};\n\n\n/**\n * Regular expression for matching big fence arguments.\n * @type {RegExp}\n */\nconst biggs: RegExp = /^(b|B)i(g{1,2})$/;\n\n\n/**\n * Automatic sizing of fences, e.g., \\\\qty(x). Some with content.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string=} open Opening fence.\n * @param {string=} close Closing fence.\n * @param {boolean=} arg Fences contain an argument.\n * @param {string=} named Name operator.\n * @param {string=} variant A font for the mathvariant.\n */\nPhysicsMethods.Quantity = function(parser: TexParser, name: string,\n                                   open: string = '(', close: string = ')',\n                                   arg: boolean = false, named: string = '',\n                                   variant: string = '') {\n  let star = arg ? parser.GetStar() : false;\n  let next = parser.GetNext();\n  let position = parser.i;\n  let big = null;\n  if (next === '\\\\') {\n    parser.i++;\n    big = parser.GetCS();\n    if (!big.match(biggs)) {\n      // empty\n      let empty = parser.create('node', 'mrow');\n      parser.Push(ParseUtil.fenced(parser.configuration, open, empty, close));\n      parser.i = position;\n      return;\n    }\n    next = parser.GetNext();\n  }\n  let right = pairs[next];\n  if (arg && next !== '{') {\n    throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (!right) {\n    let empty = parser.create('node', 'mrow');\n    parser.Push(ParseUtil.fenced(parser.configuration, open, empty, close));\n    parser.i = position;\n    return;\n  }\n  // Get the fences\n  if (named) {\n    const mml = parser.create('token', 'mi', {texClass: TEXCLASS.OP}, named);\n    if (variant) {\n      NodeUtil.setAttribute(mml, 'mathvariant', variant);\n    }\n    parser.Push(parser.itemFactory.create('fn', mml));\n  }\n  if (next === '{') {\n    let argument = parser.GetArgument(name);\n    next = arg ? open : '\\\\{';\n    right = arg ? close : '\\\\}';\n    // TODO: Make all these fenced expressions.\n    argument = star ? next + ' ' + argument + ' ' + right :\n      (big ?\n       '\\\\' + big + 'l' + next + ' ' + argument + ' ' + '\\\\' + big + 'r' + right :\n       '\\\\left' + next + ' ' + argument + ' ' + '\\\\right' + right);\n    parser.Push(new TexParser(argument, parser.stack.env,\n                              parser.configuration).mml());\n    return;\n  }\n  if (arg) {\n    next = open;\n    right = close;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open')\n              .setProperties({open: next, close: right, big: big}));\n};\n\n\n/**\n * The evaluate macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.Eval = function(parser: TexParser, name: string) {\n  let star = parser.GetStar();\n  let next = parser.GetNext();\n  if (next === '{') {\n    let arg = parser.GetArgument(name);\n    let replace = '\\\\left. ' +\n      (star ? '\\\\smash{' + arg + '}' : arg) +\n      ' ' + '\\\\vphantom{\\\\int}\\\\right|';\n    parser.string = parser.string.slice(0, parser.i) + replace +\n      parser.string.slice(parser.i);\n    return;\n  }\n  if (next === '(' || next === '[') {\n    parser.i++;\n    parser.Push(parser.itemFactory.create('auto open')\n                .setProperties(\n                  {open: next, close: '|',\n                   smash: star, right: '\\\\vphantom{\\\\int}'}));\n    return;\n  }\n  throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n};\n\n\n/**\n * The anti/commutator and poisson macros.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string=} open Opening fence.\n * @param {string=} close Closing fence.\n */\nPhysicsMethods.Commutator = function(parser: TexParser, name: string,\n                                     open: string = '[', close: string = ']') {\n  let star = parser.GetStar();\n  let next = parser.GetNext();\n  let big = null;\n  if (next === '\\\\') {\n    parser.i++;\n    big = parser.GetCS();\n    if (!big.match(biggs)) {\n      // Actually a commutator error arg1 error.\n      throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n    }\n    next = parser.GetNext();\n  }\n  if (next !== '{') {\n    throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  let arg1 = parser.GetArgument(name);\n  let arg2 = parser.GetArgument(name);\n  let argument = arg1 + ',' + arg2;\n  argument = star ? open + ' ' + argument + ' ' + close :\n    (big ?\n     '\\\\' + big + 'l' + open + ' ' + argument + ' ' + '\\\\' + big + 'r' + close :\n     '\\\\left' + open + ' ' + argument + ' ' + '\\\\right' + close);\n  parser.Push(new TexParser(argument, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/***********************\n * Physics package section 2.2\n * Vector notation\n */\n\nlet latinCap: [number, number] = [0x41, 0x5A];\nlet latinSmall: [number, number] = [0x61, 0x7A];\nlet greekCap: [number, number] = [0x391, 0x3A9];\nlet greekSmall: [number, number] = [0x3B1, 0x3C9];\nlet digits: [number, number] = [0x30, 0x39];\n\n/**\n * Checks if a value is in a given numerical interval.\n * @param {number} value The value.\n * @param {[number, number]} range The closed interval.\n */\nfunction inRange(value: number, range: [number, number]) {\n  return (value >= range[0] && value <= range[1]);\n}\n\n\n/**\n * Method to create a token for the vector commands. It creates a vector token\n * with the specific vector font (e.g., bold) in case it is a Latin or capital\n * Greek character, accent or small Greek character if command is starred. This\n * is a replacement for the original token method in the node factory.\n * @param {NodeFactory} factory The current node factory.\n * @param {string} kind The type of token to create.\n * @param {any} def The attributes for the node.\n * @param {string} text The text contained in the token node.\n * @return {MmlNode} The newly create token node.\n */\nfunction createVectorToken(factory: NodeFactory, kind: string,\n                           def: any, text: string): MmlNode  {\n  let parser = factory.configuration.parser;\n  let token = NodeFactory.createToken(factory, kind, def, text);\n  let code: number = text.codePointAt(0);\n  if (text.length === 1 && !parser.stack.env.font &&\n      parser.stack.env.vectorFont &&\n      (inRange(code, latinCap) || inRange(code, latinSmall) ||\n       inRange(code, greekCap) || inRange(code, digits) ||\n       (inRange(code, greekSmall) && parser.stack.env.vectorStar) ||\n       NodeUtil.getAttribute(token, 'accent'))) {\n    NodeUtil.setAttribute(token, 'mathvariant', parser.stack.env.vectorFont);\n  }\n  return token;\n}\n\n\n/**\n * Bold vector notation.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.VectorBold = function(parser: TexParser, name: string) {\n  let star = parser.GetStar();\n  let arg = parser.GetArgument(name);\n  let oldToken = parser.configuration.nodeFactory.get('token');\n  let oldFont = parser.stack.env.font;\n  delete parser.stack.env.font;\n  parser.configuration.nodeFactory.set('token', createVectorToken);\n  parser.stack.env.vectorFont = star ? 'bold-italic' : 'bold';\n  parser.stack.env.vectorStar = star;\n  let node = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n  if (oldFont) {\n    parser.stack.env.font = oldFont;\n  }\n  delete parser.stack.env.vectorFont;\n  delete parser.stack.env.vectorStar;\n  parser.configuration.nodeFactory.set('token', oldToken);\n  parser.Push(node);\n};\n\n\n/**\n * Macros that can have an optional star which is propagated.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} argcount Number of arguments.\n * @param {string[]} ...parts List of parts from which to assemble the macro.\n *     If the original command is starred, a star will be injected at each part.\n */\nPhysicsMethods.StarMacro = function(parser: TexParser, name: string,\n                                argcount: number, ...parts: string[]) {\n  let star = parser.GetStar();\n  const args: string[] = [];\n  if (argcount) {\n    for (let i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n  }\n  let macro = parts.join(star ? '*' : '');\n  macro = ParseUtil.substituteArgs(parser, args, macro);\n  parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil.checkMaxMacros(parser);\n};\n\n\n/**\n * Computes the application of a vector operation.\n * @param {TexParser} parser The calling parser.\n * @param {string} kind The type of stack item to parse the operator into.\n * @param {string} name The macro name.\n * @param {string} operator The operator expression.\n * @param {string[]} ...fences List of opening fences that should be\n *     automatically sized and paired to its corresponding closing fence.\n */\nlet vectorApplication = function(\n  parser: TexParser, kind: string, name: string, operator: string,\n  fences: string[]) {\n  let op = new TexParser(operator, parser.stack.env,\n                         parser.configuration).mml();\n  parser.Push(parser.itemFactory.create(kind, op));\n  let left = parser.GetNext();\n  let right = pairs[left];\n  if (!right) {\n    return;\n  }\n  let lfence = '', rfence = '', arg = '';\n  let enlarge = fences.indexOf(left) !== -1;\n  if (left === '{') {\n    arg = parser.GetArgument(name);\n    lfence = enlarge ? '\\\\left\\\\{' : '';\n    rfence = enlarge ? '\\\\right\\\\}' : '';\n    let macro = lfence + ' ' + arg + ' ' + rfence;\n    parser.string = macro + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  if (!enlarge) {\n    return;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open')\n              .setProperties({open: left, close: right}));\n};\n\n\n/**\n * An operator that needs to be parsed (e.g., a Greek letter or nabla) and\n * applied to a possibly fenced expression. By default automatic fences are\n * parentheses and brakets, with braces being ignored.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} operator The operator expression.\n * @param {string[]} ...fences List of opening fences that should be\n *     automatically sized and paired to its corresponding closing fence.\n */\nPhysicsMethods.OperatorApplication = function(\n  parser: TexParser, name: string, operator: string,\n  ...fences: string[]) {\n  vectorApplication(parser, 'fn', name, operator, fences);\n};\n\n/**\n * A vector operator that needs to be parsed (e.g., a Greek letter or nabla with\n * a crossproduct) and connected to a possibly fenced expression. By default\n * automatic fences are parentheses and brakets.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} operator The operator expression.\n * @param {string[]} ...fences List of opening fences that should be\n *     automatically sized and paired to its corresponding closing fence.\n */\nPhysicsMethods.VectorOperator = function(\n  parser: TexParser, name: string, operator: string,\n  ...fences: string[]) {\n  vectorApplication(parser, 'mml', name, operator, fences);\n};\n\n\n/***********************\n * Physics package section 2.3\n * Operators\n */\n\n/**\n * Operator expression with automatic fences and optional exponent.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean=} opt Set to false if no optional exponent is allowed.\n * @param {string=} id The name of the function if different from name.\n */\nPhysicsMethods.Expression = function(parser: TexParser, name: string,\n                                     opt: boolean = true, id: string = '') {\n  id = id || name.slice(1);\n  const exp = opt ? parser.GetBrackets(name) : null;\n  let mml = parser.create('token', 'mi', {texClass: TEXCLASS.OP}, id);\n  if (exp) {\n    const sup = new TexParser(exp,\n                              parser.stack.env, parser.configuration).mml();\n    mml = parser.create('node', 'msup', [mml, sup]);\n  }\n  parser.Push(parser.itemFactory.create('fn', mml));\n  if (parser.GetNext() !== '(') {\n    return;\n  }\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open')\n              .setProperties({open: '(', close: ')'}));\n};\n\n\n/***********************\n * Physics package section 2.4\n * Quick quad text\n */\n\n/**\n * Quad text macros.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} text The text that is to be padded with quad spaces.\n */\nPhysicsMethods.Qqtext = function(parser: TexParser, name: string,\n                                 text: string) {\n  let star = parser.GetStar();\n  let arg = text ? text : parser.GetArgument(name);\n  let replace = (star ? '' : '\\\\quad') + '\\\\text{' + arg + '}\\\\quad ';\n  parser.string = parser.string.slice(0, parser.i) + replace +\n    parser.string.slice(parser.i);\n};\n\n\n/***********************\n * Physics package section 2.5\n * Derivatives\n */\n\n/**\n * The differential and variation macros.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} op The operator. It will be parsed.\n */\nPhysicsMethods.Differential = function(parser: TexParser, name: string,\n                                       op: string) {\n  const optArg = parser.GetBrackets(name);\n  const power = optArg != null ? '^{' + optArg + '}' : ' ';\n  const parens = parser.GetNext() === '(';\n  const braces = parser.GetNext() === '{';\n  let macro = op + power;\n  if (!(parens || braces)) {\n    macro += parser.GetArgument(name, true) || '';\n    let mml = new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml();\n    parser.Push(mml);\n    return;\n  }\n  if (braces) {\n    macro += parser.GetArgument(name);\n    const mml = new TexParser(macro, parser.stack.env,\n                              parser.configuration).mml();\n    parser.Push(parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP}));\n    return;\n  }\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n  parser.i++;\n  parser.Push(parser.itemFactory.create('auto open')\n              .setProperties({open: '(', close: ')'}));\n};\n\n\n/**\n * The derivative macro. Its behaviour depends on the number of arguments\n * provided. In case of\n * 1 argument: will be part of the denominator.\n * 2 arguments: argument one is numerator, argument two is denominator.\n * 3+ arguments: arguments above 2 will be part of the denominator and the\n *   exponent of the enumerator will depend on the number of denominator\n *   arguments. In particular, the optional exponent argument will be ignored!\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} argMax The maximum number of arguments for the macro.\n * @param {string} op The derivative operator.\n */\nPhysicsMethods.Derivative = function(parser: TexParser, name: string,\n                                     argMax: number, op: string) {\n  const star = parser.GetStar();\n  const optArg = parser.GetBrackets(name);\n  let argCounter = 1;\n  const args = [];\n  args.push(parser.GetArgument(name));\n  while (parser.GetNext() === '{' && argCounter < argMax) {\n    args.push(parser.GetArgument(name));\n    argCounter++;\n  }\n  let ignore = false;\n  let power1 = ' ';\n  let power2 = ' ';\n  if (argMax > 2 && args.length > 2) {\n    power1 = '^{' + (args.length - 1) + '}';\n    ignore = true;\n  } else if (optArg != null) {\n    if (argMax > 2 && args.length > 1) {\n      ignore = true;\n    }\n    power1 = '^{' + optArg + '}';\n    power2 = power1;\n  }\n  const frac = star ? '\\\\flatfrac' : '\\\\frac';\n  const first = args.length > 1 ? args[0] : '';\n  const second = args.length > 1 ? args[1] : args[0];\n  let rest = '';\n  for (let i = 2, arg; arg = args[i]; i++) {\n    rest += op + ' ' + arg;\n  }\n  const macro = frac + '{' + op + power1 + first + '}' +\n    '{' + op + ' ' + second + power2 + ' ' + rest + '}';\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n  if (parser.GetNext() === '(') {\n    parser.i++;\n    parser.Push(parser.itemFactory.create('auto open')\n                .setProperties({open: '(', close: ')', ignore: ignore}));\n  }\n};\n\n\n/***********************\n * Physics package section 2.6\n * Dirac bra-ket notation\n */\n\n/**\n * The bra macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.Bra = function(parser: TexParser, name: string) {\n  let starBra = parser.GetStar();\n  let bra = parser.GetArgument(name);\n  let ket = '';\n  let hasKet = false;\n  let starKet = false;\n  if (parser.GetNext() === '\\\\') {\n    let saveI = parser.i;\n    parser.i++;\n    // This ensures that bra-ket also works if \\let bound versions of \\ket.\n    let cs = parser.GetCS();\n    let symbol = parser.lookup('macro', cs) as Macro;\n    if (symbol && symbol.symbol === 'ket') {\n      hasKet = true;\n      saveI = parser.i;\n      starKet = parser.GetStar();\n      if (parser.GetNext() === '{') {\n        ket = parser.GetArgument(cs, true);\n      } else {\n        parser.i = saveI;\n        starKet = false;\n      }\n    } else {\n      parser.i = saveI;\n    }\n  }\n  let macro = '';\n  if (hasKet) {\n    macro = (starBra || starKet) ?\n    `\\\\langle{${bra}}\\\\vert{${ket}}\\\\rangle` :\n      `\\\\left\\\\langle{${bra}}\\\\middle\\\\vert{${ket}}\\\\right\\\\rangle`;\n  } else {\n    macro = (starBra || starKet) ?\n    `\\\\langle{${bra}}\\\\vert` : `\\\\left\\\\langle{${bra}}\\\\right\\\\vert{${ket}}`;\n  }\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * The ket macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.Ket = function(parser: TexParser, name: string) {\n  let star = parser.GetStar();\n  let ket = parser.GetArgument(name);\n  let macro = star ? `\\\\vert{${ket}}\\\\rangle` :\n    `\\\\left\\\\vert{${ket}}\\\\right\\\\rangle`;\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * The braket macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.BraKet = function(parser: TexParser, name: string) {\n  let star = parser.GetStar();\n  let bra = parser.GetArgument(name);\n  let ket = null;\n  if (parser.GetNext() === '{') {\n    ket = parser.GetArgument(name, true);\n  }\n  let macro = '';\n  if (ket == null) {\n    macro = star ?\n      `\\\\langle{${bra}}\\\\vert{${bra}}\\\\rangle` :\n      `\\\\left\\\\langle{${bra}}\\\\middle\\\\vert{${bra}}\\\\right\\\\rangle`;\n  } else {\n    macro = star ?\n      `\\\\langle{${bra}}\\\\vert{${ket}}\\\\rangle` :\n      `\\\\left\\\\langle{${bra}}\\\\middle\\\\vert{${ket}}\\\\right\\\\rangle`;\n  }\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * The ketbra macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.KetBra = function(parser: TexParser, name: string) {\n  let star = parser.GetStar();\n  let ket = parser.GetArgument(name);\n  let bra = null;\n  if (parser.GetNext() === '{') {\n    bra = parser.GetArgument(name, true);\n  }\n  let macro = '';\n  if (bra == null) {\n    macro = star ?\n      `\\\\vert{${ket}}\\\\rangle\\\\!\\\\langle{${ket}}\\\\vert` :\n      `\\\\left\\\\vert{${ket}}\\\\middle\\\\rangle\\\\!\\\\middle\\\\langle{${ket}}\\\\right\\\\vert`;\n  } else {\n    macro = star ?\n      `\\\\vert{${ket}}\\\\rangle\\\\!\\\\langle{${bra}}\\\\vert` :\n      `\\\\left\\\\vert{${ket}}\\\\middle\\\\rangle\\\\!\\\\middle\\\\langle{${bra}}\\\\right\\\\vert`;\n  }\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * Generates the expanded braket LaTeX code for matrix operations.\n * @param {[string, string, string]} [arg1, arg2, arg3] The three arguments\n *     <arg1|arg2|arg3>.\n * @param {boolean} star1 No automatic sizing of fences.\n * @param {boolean} star2 Automatic sizing of fences wrt. to arg1 & arg3 only.\n */\nfunction outputBraket([arg1, arg2, arg3]: [string, string, string],\n                      star1: boolean, star2: boolean) {\n  return (star1 && star2) ?\n    `\\\\left\\\\langle{${arg1}}\\\\middle\\\\vert{${arg2}}\\\\middle\\\\vert{${arg3}}\\\\right\\\\rangle` :\n    (star1 ? `\\\\langle{${arg1}}\\\\vert{${arg2}}\\\\vert{${arg3}}\\\\rangle` :\n     `\\\\left\\\\langle{${arg1}}\\\\right\\\\vert{${arg2}}\\\\left\\\\vert{${arg3}}\\\\right\\\\rangle`);\n}\n\n\n/**\n * The expectation value macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.Expectation = function(parser: TexParser, name: string) {\n  let star1 = parser.GetStar();\n  let star2 = star1 && parser.GetStar();\n  let arg1 = parser.GetArgument(name);\n  let arg2 = null;\n  if (parser.GetNext() === '{') {\n    arg2 = parser.GetArgument(name, true);\n  }\n  let macro = (arg1 && arg2) ?\n    outputBraket([arg2, arg1, arg2], star1, star2) :\n    // Braces for semantics, similar to braket package.\n    (star1 ? `\\\\langle {${arg1}} \\\\rangle` :\n     `\\\\left\\\\langle {${arg1}} \\\\right\\\\rangle`);\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * The matrix element macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.MatrixElement = function(parser: TexParser, name: string) {\n  const star1 = parser.GetStar();\n  const star2 = star1 && parser.GetStar();\n  const arg1 = parser.GetArgument(name);\n  const arg2 = parser.GetArgument(name);\n  const arg3 = parser.GetArgument(name);\n  const macro = outputBraket([arg1, arg2, arg3], star1, star2);\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n\n/********************\n * Physics package Section 2.7\n * Matrix macros\n */\n/**\n * The matrix quantity macro.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean=} small Use small matrix.\n */\nPhysicsMethods.MatrixQuantity = function(parser: TexParser, name: string, small?: boolean) {\n  const star = parser.GetStar();\n  const next = parser.GetNext();\n  const array = small ? 'smallmatrix' : 'array';\n  let arg = '';\n  let open = '';\n  let close = '';\n  switch (next) {\n  case '{':\n    arg = parser.GetArgument(name);\n    break;\n  case '(':\n    parser.i++;\n    open = star ? '\\\\lgroup' : '(';\n    close = star ? '\\\\rgroup' : ')';\n    arg = parser.GetUpTo(name, ')');\n    break;\n  case '[':\n    parser.i++;\n    open = '[';\n    close = ']';\n    arg = parser.GetUpTo(name, ']');\n    break;\n  case '|':\n    parser.i++;\n    open = '|';\n    close = '|';\n    arg = parser.GetUpTo(name, '|');\n    break;\n  default:\n    open = '(';\n    close = ')';\n    break;\n  }\n  const macro = (open ? '\\\\left' : '') + open +\n    '\\\\begin{' + array + '}{} ' + arg + '\\\\end{' + array + '}' +\n    (open ? '\\\\right' : '') + close;\n  parser.Push(new TexParser(macro, parser.stack.env,\n                            parser.configuration).mml());\n};\n\n\n/**\n * Generation of identity matrices.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.IdentityMatrix = function(parser: TexParser, name: string) {\n  const arg = parser.GetArgument(name);\n  const size = parseInt(arg, 10);\n  if (isNaN(size)) {\n    throw new TexError('InvalidNumber', 'Invalid number');\n  }\n  if (size <= 1) {\n    parser.string = '1' + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  let zeros = Array(size).fill('0');\n  let columns = [];\n  for (let i = 0; i < size; i++) {\n    let row = zeros.slice();\n    row[i] = '1';\n    columns.push(row.join(' & '));\n  }\n  parser.string = columns.join('\\\\\\\\ ') + parser.string.slice(parser.i);\n  parser.i = 0;\n};\n\n\n/**\n * Generation of matrices with fixed value.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.XMatrix = function(parser: TexParser, name: string) {\n  const star = parser.GetStar();\n  const arg1 = parser.GetArgument(name);\n  const arg2 = parser.GetArgument(name);\n  const arg3 = parser.GetArgument(name);\n  let n = parseInt(arg2, 10);\n  let m = parseInt(arg3, 10);\n  if (isNaN(n) || isNaN(m) || m.toString() !== arg3 || n.toString() !== arg2) {\n    throw new TexError('InvalidNumber', 'Invalid number');\n  }\n  n = n < 1 ? 1 : n;\n  m = m < 1 ? 1 : m;\n  // Elements\n  if (!star) {\n    const row = Array(m).fill(arg1).join(' & ');\n    const matrix = Array(n).fill(row).join('\\\\\\\\ ');\n    parser.string = matrix + parser.string.slice(parser.i);\n    parser.i = 0;\n    return;\n  }\n  let matrix = '';\n  if (n === 1 && m === 1) {\n    // Case 1: n=m=1, no index.\n    matrix = arg1;\n  } else if (n === 1) {\n    // Case 2: n=1, row vector, single index.\n    let row = [];\n    for (let i = 1; i <= m; i++) {\n      row.push(`${arg1}_{${i}}`);\n    }\n    matrix = row.join(' & ');\n  } else if (m === 1) {\n    // Case 3: m=1, column vector, single index.\n    let row = [];\n    for (let i = 1; i <= n; i++) {\n      row.push(`${arg1}_{${i}}`);\n    }\n    matrix = row.join('\\\\\\\\ ');\n  } else {\n    // Case 4: matrix, double index. Note the extra mrows for indices.\n    let rows = [];\n    for (let i = 1; i <= n; i++) {\n      let row = [];\n      for (let j = 1; j <= m; j++) {\n        row.push(`${arg1}_{{${i}}{${j}}}`);\n      }\n      rows.push(row.join(' & '));\n    }\n    matrix = rows.join('\\\\\\\\ ');\n  }\n  parser.string = matrix + parser.string.slice(parser.i);\n  parser.i = 0;\n  return;\n};\n\n\n/**\n * Generation of Pauli matrices. Matrix 0 is the 2x2 identity.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.PauliMatrix = function(parser: TexParser, name: string) {\n  const arg = parser.GetArgument(name);\n  let matrix = arg.slice(1);\n  switch (arg[0]) {\n  case '0':\n    matrix += ' 1 & 0\\\\\\\\ 0 & 1';\n    break;\n  case '1':\n  case 'x':\n    matrix += ' 0 & 1\\\\\\\\ 1 & 0';\n    break;\n  case '2':\n  case 'y':\n    matrix += ' 0 & -i\\\\\\\\ i & 0';\n    break;\n  case '3':\n  case 'z':\n    matrix += ' 1 & 0\\\\\\\\ 0 & -1';\n    break;\n  default:\n  }\n  parser.string = matrix + parser.string.slice(parser.i);\n  parser.i = 0;\n};\n\n\n/**\n * Generation of anti/diagonal matrices.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean=} anti True if constructing anti-diagonal matrix.\n */\nPhysicsMethods.DiagonalMatrix = function(parser: TexParser, name: string,\n                                         anti?: boolean) {\n  if (parser.GetNext() !== '{') {\n    return;\n  }\n  let startI = parser.i;\n  /* let arg =*/ parser.GetArgument(name);\n  let endI = parser.i;\n  parser.i = startI + 1;\n  let elements = [];\n  let element = '';\n  let currentI = parser.i;\n  while (currentI < endI) {\n    try {\n      element = parser.GetUpTo(name, ',');\n    } catch (e) {\n      parser.i = endI;\n      elements.push(parser.string.slice(currentI, endI - 1));\n      break;\n    }\n    if (parser.i >= endI) {\n      elements.push(parser.string.slice(currentI, endI));\n      break;\n    }\n    currentI = parser.i;\n    elements.push(element);\n  }\n  parser.string = makeDiagMatrix(elements, anti) + parser.string.slice(endI);\n  parser.i = 0;\n};\n\n\n/**\n * Creates the a (anti)diagonal matrix string.\n * @param {string[]} elements The elements on the diagonal.\n * @param {boolean} anti True if constructing anti-diagonal matrix.\n */\nfunction makeDiagMatrix(elements: string[], anti: boolean) {\n  let length = elements.length;\n  let matrix = [];\n  for (let i = 0; i < length; i++) {\n    matrix.push(Array(anti ? length - i : i + 1).join('&') +\n                '\\\\mqty{' + elements[i] + '}');\n  }\n  return matrix.join('\\\\\\\\ ');\n}\n\n\n/**\n * Closes an automatic fence if one was opened.\n * @param {TexParser} parser The calling parser.\n * @param {string} fence The fence.\n * @param {number} texclass The TeX class.\n */\nPhysicsMethods.AutoClose = function(parser: TexParser, fence: string, _texclass: number) {\n  const mo = parser.create('token', 'mo', {stretchy: false}, fence);\n  const item = parser.itemFactory.create('mml', mo).\n    setProperties({autoclose: fence});\n  parser.Push(item);\n};\n\n\n/**\n * Generates the vector nabla depending on the arrowdel option.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.Vnabla = function(parser: TexParser, _name: string) {\n  let argument = parser.options.physics.arrowdel ?\n    '\\\\vec{\\\\gradientnabla}' : '{\\\\gradientnabla}';\n  return parser.Push(new TexParser(argument, parser.stack.env,\n                                   parser.configuration).mml());\n};\n\n\n/**\n * Generates the differential d depending on the italicdiff option.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nPhysicsMethods.DiffD = function(parser: TexParser, _name: string) {\n  let argument = parser.options.physics.italicdiff ? 'd' : '{\\\\rm d}';\n  return parser.Push(new TexParser(argument, parser.stack.env,\n                                   parser.configuration).mml());\n};\n\n\n/**\n *  Methods taken from Base package.\n */\nPhysicsMethods.Macro = BaseMethods.Macro;\n\nPhysicsMethods.NamedFn = BaseMethods.NamedFn;\n\nPhysicsMethods.Array = BaseMethods.Array;\n\n\nexport default PhysicsMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}