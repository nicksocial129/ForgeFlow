{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\nvar NodeUtil_js_1 = __importDefault(require(\"./NodeUtil.js\"));\nvar TexParser_js_1 = __importDefault(require(\"./TexParser.js\"));\nvar TexError_js_1 = __importDefault(require(\"./TexError.js\"));\nvar Entities_js_1 = require(\"../../util/Entities.js\");\nvar ParseUtil;\n(function (ParseUtil) {\n  var emPerInch = 7.2;\n  var pxPerInch = 72;\n  var UNIT_CASES = {\n    'em': function (m) {\n      return m;\n    },\n    'ex': function (m) {\n      return m * .43;\n    },\n    'pt': function (m) {\n      return m / 10;\n    },\n    'pc': function (m) {\n      return m * 1.2;\n    },\n    'px': function (m) {\n      return m * emPerInch / pxPerInch;\n    },\n    'in': function (m) {\n      return m * emPerInch;\n    },\n    'cm': function (m) {\n      return m * emPerInch / 2.54;\n    },\n    'mm': function (m) {\n      return m * emPerInch / 25.4;\n    },\n    'mu': function (m) {\n      return m / 18;\n    }\n  };\n  var num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  var unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  var dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  var dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n  function matchDimen(dim, rest) {\n    if (rest === void 0) {\n      rest = false;\n    }\n    var match = dim.match(rest ? dimenRest : dimenEnd);\n    return match ? muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) : [null, null, 0];\n  }\n  ParseUtil.matchDimen = matchDimen;\n  function muReplace(_a) {\n    var _b = __read(_a, 3),\n      value = _b[0],\n      unit = _b[1],\n      length = _b[2];\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    var em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n  function dimen2em(dim) {\n    var _a = __read(matchDimen(dim), 2),\n      value = _a[0],\n      unit = _a[1];\n    var m = parseFloat(value || '1');\n    var func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n  ParseUtil.dimen2em = dimen2em;\n  function Em(m) {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n  ParseUtil.Em = Em;\n  function cols() {\n    var W = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      W[_i] = arguments[_i];\n    }\n    return W.map(function (n) {\n      return Em(n);\n    }).join(' ');\n  }\n  ParseUtil.cols = cols;\n  function fenced(configuration, open, mml, close, big, color) {\n    if (big === void 0) {\n      big = '';\n    }\n    if (color === void 0) {\n      color = '';\n    }\n    var nf = configuration.nodeFactory;\n    var mrow = nf.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.INNER\n    });\n    var mo;\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.OPEN\n      }, openNode);\n    }\n    NodeUtil_js_1.default.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.CLOSE\n      }, closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil_js_1.default.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n  ParseUtil.fenced = fenced;\n  function fixedFence(configuration, open, mml, close) {\n    var mrow = configuration.nodeFactory.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.ORD\n    });\n    if (open) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil_js_1.default.isType(mml, 'mrow')) {\n      NodeUtil_js_1.default.appendChildren(mrow, NodeUtil_js_1.default.getChildren(mml));\n    } else {\n      NodeUtil_js_1.default.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n  ParseUtil.fixedFence = fixedFence;\n  function mathPalette(configuration, fence, side) {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    var D = '{\\\\bigg' + side + ' ' + fence + '}';\n    var T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser_js_1.default('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n  ParseUtil.mathPalette = mathPalette;\n  function fixInitialMO(configuration, nodes) {\n    for (var i = 0, m = nodes.length; i < m; i++) {\n      var child = nodes[i];\n      if (child && !NodeUtil_js_1.default.isType(child, 'mspace') && (!NodeUtil_js_1.default.isType(child, 'TeXAtom') || NodeUtil_js_1.default.getChildren(child)[0] && NodeUtil_js_1.default.getChildren(NodeUtil_js_1.default.getChildren(child)[0]).length)) {\n        if (NodeUtil_js_1.default.isEmbellished(child) || NodeUtil_js_1.default.isType(child, 'TeXAtom') && NodeUtil_js_1.default.getTexClass(child) === MmlNode_js_1.TEXCLASS.REL) {\n          var mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n  ParseUtil.fixInitialMO = fixInitialMO;\n  function internalMath(parser, text, level, font) {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    var mathvariant = font || parser.stack.env.font;\n    var def = mathvariant ? {\n      mathvariant: mathvariant\n    } : {};\n    var mml = [],\n      i = 0,\n      k = 0,\n      c,\n      node,\n      match = '',\n      braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 1), {}, parser.configuration).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          braces++;\n        } else if (c === '}') {\n          if (match === '}' && braces === 0) {\n            var atom = new TexParser_js_1.default(text.slice(k, i), {}, parser.configuration).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            if (braces) {\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            var len = RegExp['$&'].length;\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              if (k < i - 2) {\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')';\n              k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 2), {}, parser.configuration).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '') {\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i);\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        throw new TexError_js_1.default('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      mml = [parser.create('node', 'mstyle', mml, {\n        displaystyle: false,\n        scriptlevel: level\n      })];\n    } else if (mml.length > 1) {\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n  ParseUtil.internalMath = internalMath;\n  function internalText(parser, text, def) {\n    text = text.replace(/^\\s+/, Entities_js_1.entities.nbsp).replace(/\\s+$/, Entities_js_1.entities.nbsp);\n    var textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n  ParseUtil.internalText = internalText;\n  function underOver(parser, base, script, pos, stack) {\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil_js_1.default.isType(base, 'munderover') && NodeUtil_js_1.default.isEmbellished(base)) {\n      NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(base), {\n        lspace: 0,\n        rspace: 0\n      });\n      var mo = parser.create('node', 'mo', [], {\n        rspace: 0\n      });\n      base = parser.create('node', 'mrow', [mo, base]);\n    }\n    var mml = parser.create('node', 'munderover', [base]);\n    NodeUtil_js_1.default.setChild(mml, pos === 'over' ? mml.over : mml.under, script);\n    var node = mml;\n    if (stack) {\n      node = parser.create('node', 'TeXAtom', [mml], {\n        texClass: MmlNode_js_1.TEXCLASS.OP,\n        movesupsub: true\n      });\n    }\n    NodeUtil_js_1.default.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n  ParseUtil.underOver = underOver;\n  function checkMovableLimits(base) {\n    var symbol = NodeUtil_js_1.default.isType(base, 'mo') ? NodeUtil_js_1.default.getForm(base) : null;\n    if (NodeUtil_js_1.default.getProperty(base, 'movablelimits') || symbol && symbol[3] && symbol[3].movablelimits) {\n      NodeUtil_js_1.default.setProperties(base, {\n        movablelimits: false\n      });\n    }\n  }\n  ParseUtil.checkMovableLimits = checkMovableLimits;\n  function trimSpaces(text) {\n    if (typeof text !== 'string') {\n      return text;\n    }\n    var TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n  ParseUtil.trimSpaces = trimSpaces;\n  function setArrayAlign(array, align) {\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    }\n    return array;\n  }\n  ParseUtil.setArrayAlign = setArrayAlign;\n  function substituteArgs(parser, args, str) {\n    var text = '';\n    var newstring = '';\n    var i = 0;\n    while (i < str.length) {\n      var c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      } else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError_js_1.default('IllegalMacroParam', 'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n  ParseUtil.substituteArgs = substituteArgs;\n  function addArgs(parser, s1, s2) {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError_js_1.default('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' + ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n  ParseUtil.addArgs = addArgs;\n  function checkMaxMacros(parser, isMacro) {\n    if (isMacro === void 0) {\n      isMacro = true;\n    }\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError_js_1.default('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' + 'is here a recursive macro call?');\n    } else {\n      throw new TexError_js_1.default('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' + 'is there a recursive latex environment?');\n    }\n  }\n  ParseUtil.checkMaxMacros = checkMaxMacros;\n  function checkEqnEnv(parser) {\n    if (parser.stack.global.eqnenv) {\n      throw new TexError_js_1.default('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n  ParseUtil.checkEqnEnv = checkEqnEnv;\n  function copyNode(node, parser) {\n    var tree = node.copy();\n    var options = parser.configuration;\n    tree.walkTree(function (n) {\n      var e_1, _a;\n      options.addNode(n.kind, n);\n      var lists = (n.getProperty('in-lists') || '').split(/,/);\n      try {\n        for (var lists_1 = __values(lists), lists_1_1 = lists_1.next(); !lists_1_1.done; lists_1_1 = lists_1.next()) {\n          var list = lists_1_1.value;\n          list && options.addNode(list, n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (lists_1_1 && !lists_1_1.done && (_a = lists_1.return)) _a.call(lists_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n    return tree;\n  }\n  ParseUtil.copyNode = copyNode;\n  function MmlFilterAttribute(_parser, _name, value) {\n    return value;\n  }\n  ParseUtil.MmlFilterAttribute = MmlFilterAttribute;\n  function getFontDef(parser) {\n    var font = parser.stack.env['font'];\n    return font ? {\n      mathvariant: font\n    } : {};\n  }\n  ParseUtil.getFontDef = getFontDef;\n  function keyvalOptions(attrib, allowed, error) {\n    var e_2, _a;\n    if (allowed === void 0) {\n      allowed = null;\n    }\n    if (error === void 0) {\n      error = false;\n    }\n    var def = readKeyval(attrib);\n    if (allowed) {\n      try {\n        for (var _b = __values(Object.keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n          if (!allowed.hasOwnProperty(key)) {\n            if (error) {\n              throw new TexError_js_1.default('InvalidOption', 'Invalid option: %1', key);\n            }\n            delete def[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    return def;\n  }\n  ParseUtil.keyvalOptions = keyvalOptions;\n  function readKeyval(text) {\n    var _a, _b;\n    var options = {};\n    var rest = text;\n    var end, key, val;\n    while (rest) {\n      _a = __read(readValue(rest, ['=', ',']), 3), key = _a[0], end = _a[1], rest = _a[2];\n      if (end === '=') {\n        _b = __read(readValue(rest, [',']), 3), val = _b[0], end = _b[1], rest = _b[2];\n        val = val === 'false' || val === 'true' ? JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n  function removeBraces(text, count) {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n  function readValue(text, end) {\n    var length = text.length;\n    var braces = 0;\n    var value = '';\n    var index = 0;\n    var start = 0;\n    var startCount = true;\n    var stopCount = false;\n    while (index < length) {\n      var c = text[index++];\n      switch (c) {\n        case ' ':\n          break;\n        case '{':\n          if (startCount) {\n            start++;\n          } else {\n            stopCount = false;\n            if (start > braces) {\n              start = braces;\n            }\n          }\n          braces++;\n          break;\n        case '}':\n          if (braces) {\n            braces--;\n          }\n          if (startCount || stopCount) {\n            start--;\n            stopCount = true;\n          }\n          startCount = false;\n          break;\n        default:\n          if (!braces && end.indexOf(c) !== -1) {\n            return [stopCount ? 'true' : removeBraces(value, start), c, text.slice(index)];\n          }\n          startCount = false;\n          stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError_js_1.default('ExtraOpenMissingClose', 'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n})(ParseUtil || (ParseUtil = {}));\nexports.default = ParseUtil;","map":{"version":3,"names":["MmlNode_js_1","require","NodeUtil_js_1","__importDefault","TexParser_js_1","TexError_js_1","Entities_js_1","ParseUtil","emPerInch","pxPerInch","UNIT_CASES","em","m","ex","pt","pc","px","in","cm","mm","mu","num","unit","dimenEnd","RegExp","dimenRest","matchDimen","dim","rest","match","muReplace","replace","length","_a","_b","__read","value","Em","parseFloat","slice","dimen2em","func","Math","abs","toFixed","cols","W","_i","arguments","map","n","join","fenced","configuration","open","mml","close","big","color","nf","nodeFactory","mrow","create","texClass","TEXCLASS","INNER","mo","default","parser","stack","env","openNode","fence","stretchy","symmetric","OPEN","appendChildren","closeNode","CLOSE","attributes","set","fixedFence","ORD","mathPalette","isType","getChildren","side","D","T","fixInitialMO","nodes","i","child","isEmbellished","getTexClass","REL","mi","unshift","internalMath","text","level","font","options","mathvariant","def","k","c","node","braces","charAt","push","internalText","atom","substr","len","displaystyle","scriptlevel","entities","nbsp","textNode","underOver","base","script","pos","checkMovableLimits","setProperties","getCoreMO","lspace","rspace","setChild","over","under","OP","movesupsub","setProperty","symbol","getForm","getProperty","movablelimits","trimSpaces","TEXT","trim","setArrayAlign","array","align","arraydef","substituteArgs","args","str","newstring","parseInt","addArgs","s1","s2","checkMaxMacros","isMacro","macroCount","checkEqnEnv","global","eqnenv","copyNode","tree","copy","walkTree","addNode","kind","lists","split","lists_1","__values","lists_1_1","next","done","list","MmlFilterAttribute","_parser","_name","getFontDef","keyvalOptions","attrib","allowed","error","readKeyval","Object","keys","_c","key","hasOwnProperty","end","val","readValue","JSON","parse","removeBraces","count","index","start","startCount","stopCount","indexOf","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/ParseUtil.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview A namespace for utility functions for the TeX Parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TEXCLASS, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {EnvList} from './StackItem.js';\nimport {ArrayItem} from './base/BaseItems.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\nimport TexParser from './TexParser.js';\nimport TexError from './TexError.js';\nimport {entities} from '../../util/Entities.js';\nimport {MmlMunderover} from '../../core/MmlTree/MmlNodes/munderover.js';\n\n\nnamespace ParseUtil {\n\n  // TODO (VS): Combine some of this with lengths in util.\n  const emPerInch = 7.2;\n  const pxPerInch = 72;\n  // Note, the following are TeX CM font values.\n  const UNIT_CASES: {[key: string]: ((m: number) => number)}  = {\n    'em': m => m,\n    'ex': m => m * .43,\n    'pt': m => m / 10,                    // 10 pt to an em\n    'pc': m => m * 1.2,                   // 12 pt to a pc\n    'px': m => m * emPerInch / pxPerInch,\n    'in': m => m * emPerInch,\n    'cm': m => m * emPerInch / 2.54, // 2.54 cm to an inch\n    'mm': m => m * emPerInch / 25.4, // 10 mm to a cm\n    'mu': m => m / 18,\n  };\n  const num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  const unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  const dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  const dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n\n  /**\n   * Matches for a dimension argument.\n   * @param {string} dim The argument.\n   * @param {boolean} rest Allow for trailing garbage in the dimension string.\n   * @return {[string, string, number]} The match result as (Anglosaxon) value,\n   *     unit name, length of matched string. The latter is interesting in the\n   *     case of trailing garbage.\n   */\n  export function matchDimen(\n    dim: string, rest: boolean = false): [string, string, number] {\n      let match = dim.match(rest ? dimenRest : dimenEnd);\n      return match ?\n        muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :\n        [null, null, 0];\n  }\n\n\n  /**\n   * Transforms mu dimension to em if necessary.\n   * @param {[string, string, number]} [value, unit, length] The dimension triple.\n   * @return {[string, string, number]} [value, unit, length] The transformed triple.\n   */\n  function muReplace([value, unit, length]: [string, string, number]): [string, string, number] {\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    let em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n\n  /**\n   * Convert a dimension string into standard em dimension.\n   * @param {string} dim The attribute string.\n   * @return {number} The numerical value.\n   */\n  export function dimen2em(dim: string): number {\n    let [value, unit] = matchDimen(dim);\n    let m = parseFloat(value || '1');\n    let func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n\n  /**\n   * Turns a number into an em value.\n   * @param {number} m The number.\n   * @return {string} The em dimension string.\n   */\n  export function Em(m: number): string {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n\n  /**\n   * Takes an array of numbers and returns a space-separated string of em values.\n   * @param {number[]} W  The widths to be turned into em values\n   * @return {string}     The numbers with em units, separated by spaces.\n   */\n  export function cols(...W: number[]): string {\n    return W.map(n => Em(n)).join(' ');\n  }\n\n\n  /**\n   * Create an mrow that has stretchy delimiters at either end, as needed\n   * @param {ParseOptions} configuration Current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @param {string=} big Bigg command.\n   */\n  export function fenced(configuration: ParseOptions, open: string, mml: MmlNode,\n                         close: string, big: string = '', color: string = '') {\n    // @test Fenced, Fenced3\n    let nf = configuration.nodeFactory;\n    let mrow = nf.create('node', 'mrow', [],\n                         {open: open, close: close, texClass: TEXCLASS.INNER});\n    let mo;\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.OPEN},\n                     openNode);\n    }\n    NodeUtil.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.CLOSE},\n                     closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n\n  /**\n   *  Create an mrow that has \\\\mathchoice using \\\\bigg and \\\\big for the delimiters.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @return {MmlNode} The mrow node.\n   */\n  export function fixedFence(configuration: ParseOptions, open: string,\n                             mml: MmlNode, close: string): MmlNode {\n    // @test Choose, Over With Delims, Above with Delims\n    let mrow = configuration.nodeFactory.create('node',\n      'mrow', [], {open: open, close: close, texClass: TEXCLASS.ORD});\n    if (open) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil.isType(mml, 'mrow')) {\n      NodeUtil.appendChildren(mrow, NodeUtil.getChildren(mml));\n    } else {\n      NodeUtil.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n\n\n  /**\n   * Generates a mathchoice element for fences. These will be resolved later,\n   * once the position, and therefore size, of the of the fenced expression is\n   * known.\n   * @param {ParseOptions} configuration The current parse otpions.\n   * @param {string} fence The fence.\n   * @param {string} side The side of the fence (l or r).\n   * @return {MmlNode} The mathchoice node.\n   */\n  export function mathPalette(configuration: ParseOptions, fence: string,\n                              side: string): MmlNode  {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    let D = '{\\\\bigg' + side + ' ' + fence + '}';\n    let T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n\n  /**\n   * If the initial child, skipping any initial space or\n   * empty braces (TeXAtom with child being an empty inferred row),\n   * is an <mo>, precede it by an empty <mi> to force the <mo> to\n   * be infix.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {MmlNode[]} nodes The row of nodes to scan for an initial <mo>\n   */\n  export function fixInitialMO(configuration: ParseOptions, nodes: MmlNode[]) {\n    for (let i = 0, m = nodes.length; i < m; i++) {\n      let child = nodes[i];\n      if (child && (!NodeUtil.isType(child, 'mspace') &&\n                    (!NodeUtil.isType(child, 'TeXAtom') ||\n                     (NodeUtil.getChildren(child)[0] &&\n                      NodeUtil.getChildren(NodeUtil.getChildren(child)[0]).length)))) {\n        if (NodeUtil.isEmbellished(child) ||\n            (NodeUtil.isType(child, 'TeXAtom') && NodeUtil.getTexClass(child) === TEXCLASS.REL)) {\n          let mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Break up a string into text and math blocks.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} text The text in the math expression to parse.\n   * @param {number|string=} level The scriptlevel.\n   * @param {string} font The mathvariant to use\n   * @return {MmlNode[]} The nodes corresponding to the internal math expression.\n   */\n  export function internalMath(parser: TexParser, text: string,\n                               level?: number | string, font?: string): MmlNode[] {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    let mathvariant = font || parser.stack.env.font;\n    let def = (mathvariant ? {mathvariant} : {});\n    let mml: MmlNode[] = [], i = 0, k = 0, c, node, match = '', braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            // @test Interspersed Text\n            node = parser.create(\n              'node', 'TeXAtom',\n              [(new TexParser(text.slice(k, i - 1), {}, parser.configuration)).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            // @test Interspersed Text\n            if (k < i - 1) {\n              // @test Interspersed Text\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          // @test Mbox Mbox, Mbox Math\n          braces++;\n        } else if (c === '}') {\n          // @test Mbox Mbox, Mbox Math\n          if (match === '}' && braces === 0) {\n            // @test Mbox Eqref, Mbox Math\n            let atom = (new TexParser(text.slice(k, i), {}, parser.configuration)).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            // @test Mbox Math, Mbox Mbox\n            if (braces) {\n              // @test Mbox Math, Mbox Mbox\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          // @test Mbox Eqref, Mbox CR\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            // @test Mbox Eqref\n            let len = ((RegExp as any)['$&'] as string).length;\n            if (k < i - 1) {\n              // @test Mbox Eqref\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            // @test Mbox CR, Mbox Mbox\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              // @test Mbox Internal Display\n              if (k < i - 2) {\n                // @test Mbox Internal Display\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')'; k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              // @test Mbox Internal Display\n              node = parser.create(\n                'node', 'TeXAtom',\n                [(new TexParser(text.slice(k, i - 2), {}, parser.configuration)).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '')  {\n              // @test Mbox CR\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i); // remove \\ from \\$, \\{, \\}, or \\\\\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        // @test Internal Math Error\n        throw new TexError('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      // @test Interspersed Text, Mbox Mbox\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      // @test Label, Fbox, Hbox\n      mml = [parser.create('node', 'mstyle', mml, {displaystyle: false, scriptlevel: level})];\n    } else if (mml.length > 1) {\n      // @test Interspersed Text\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n\n\n  /**\n   * Parses text internal to boxes or labels.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} text The text to parse.\n   * @param {EnvList} def The attributes of the text node.\n   * @return {MmlNode} The text node.\n   */\n  export function internalText(parser: TexParser, text: string, def: EnvList): MmlNode {\n    // @test Label, Fbox, Hbox\n    text = text.replace(/^\\s+/, entities.nbsp).replace(/\\s+$/, entities.nbsp);\n    let textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  /**\n   * Create an munderover node with the given script position.\n   * @param {TexParser} parser   The current TeX parser.\n   * @param {MmlNode} base       The base node.\n   * @param {MmlNode} script     The under- or over-script.\n   * @param {string} pos         Either 'over' or 'under'.\n   * @param {boolean} stack      True if super- or sub-scripts should stack.\n   * @return {MmlNode}           The generated node (MmlMunderover or TeXAtom)\n   */\n  export function underOver(parser: TexParser, base: MmlNode, script: MmlNode, pos: string, stack: boolean): MmlNode {\n    // @test Overline\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil.isType(base, 'munderover') && NodeUtil.isEmbellished(base)) {\n      // @test Overline Limits\n      NodeUtil.setProperties(NodeUtil.getCoreMO(base), {lspace: 0, rspace: 0});\n      const mo = parser.create('node', 'mo', [], {rspace: 0});\n      base = parser.create('node', 'mrow', [mo, base]);\n      // TODO? add an empty <mi> so it's not embellished any more\n    }\n    const mml = parser.create('node', 'munderover', [base]) as MmlMunderover;\n    NodeUtil.setChild(mml, pos === 'over' ?  mml.over : mml.under, script);\n    let node: MmlNode = mml;\n    if (stack) {\n      // @test Overbrace 1 2 3, Underbrace, Overbrace Op 1 2\n      node = parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP, movesupsub: true});\n    }\n    NodeUtil.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  /**\n   * Set movablelimits to false if necessary.\n   * @param {MmlNode} base   The base node being tested.\n   */\n  export function checkMovableLimits(base: MmlNode) {\n    const symbol = (NodeUtil.isType(base, 'mo') ? NodeUtil.getForm(base) : null);\n    if (NodeUtil.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {\n      // @test Overline Sum\n      NodeUtil.setProperties(base, {movablelimits: false});\n    }\n  }\n\n  /**\n   * Trim spaces from a string.\n   * @param {string} text The string to clean.\n   * @return {string} The string with leading and trailing whitespace removed.\n   */\n  export function trimSpaces(text: string): string {\n    if (typeof(text) !== 'string') {\n      return text;\n    }\n    let TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n\n\n  /**\n   * Sets alignment in array definitions.\n   * @param {ArrayItem} array The array item.\n   * @param {string} align The alignment string.\n   * @return {ArrayItem} The altered array item.\n   */\n  export function setArrayAlign(array: ArrayItem, align: string): ArrayItem {\n    // @test Array1, Array2, Array Test\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    } // FIXME: should be an error?\n    return array;\n  }\n\n\n  /**\n   * Replace macro parameters with their values.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string[]} args A list of arguments for macro parameters.\n   * @param {string} str The macro parameter string.\n   * @return {string} The string with all parameters replaced by arguments.\n   */\n  export function substituteArgs(parser: TexParser, args: string[],\n                                 str: string): string {\n    let text = '';\n    let newstring = '';\n    let i = 0;\n    while (i < str.length) {\n      let c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      }\n      else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError('IllegalMacroParam',\n                                'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text),\n                              args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n\n\n  /**\n   * Adds a new expanded argument to an already macro parameter string.  Makes\n   * sure that macros are followed by a space if their names could accidentally\n   * be continued into the following text.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string} s1 The already expanded string.\n   * @param {string} s2 The string to add.\n   * @return {string} The combined string.\n   */\n  export function addArgs(parser: TexParser, s1: string, s2: string): string {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError('MaxBufferSize',\n                          'MathJax internal buffer size exceeded; is there a' +\n                          ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n\n  /**\n   * Report an error if there are too many macro substitutions.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {boolean} isMacro  True if we are substituting a macro, false for environment.\n   */\n  export function checkMaxMacros(parser: TexParser, isMacro: boolean = true) {\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError('MaxMacroSub1',\n                         'MathJax maximum macro substitution count exceeded; ' +\n                         'is here a recursive macro call?');\n    } else {\n      throw new TexError('MaxMacroSub2',\n                         'MathJax maximum substitution count exceeded; ' +\n                         'is there a recursive latex environment?');\n    }\n  }\n\n\n  /**\n   *  Check for bad nesting of equation environments\n   */\n  export function checkEqnEnv(parser: TexParser) {\n    if (parser.stack.global.eqnenv) {\n      // @test ErroneousNestingEq\n      throw new TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n\n  /**\n   * Copy an MmlNode and add it (and its children) to the proper lists.\n   *\n   * @param {MmlNode} node       The MmlNode to copy\n   * @param {TexParser} parser   The active tex parser\n   * @return {MmlNode}           The duplicate tree\n   */\n  export function copyNode(node: MmlNode, parser: TexParser): MmlNode  {\n    const tree = node.copy() as MmlNode;\n    const options = parser.configuration;\n    tree.walkTree((n: MmlNode) => {\n      options.addNode(n.kind, n);\n      const lists = (n.getProperty('in-lists') as string || '').split(/,/);\n      for (const list of lists) {\n        list && options.addNode(list, n);\n      }\n    });\n    return tree;\n  }\n\n  /**\n   * This is a placeholder for future security filtering of attributes.\n   * @param {TexParser} parser The current parser.\n   * @param {string} name The attribute name.\n   * @param {string} value The attribute value to filter.\n   * @return {string} The filtered value.\n   */\n  export function MmlFilterAttribute(_parser: TexParser, _name: string, value: string): string {\n    // TODO: Implement in security package.\n    return value;\n  }\n\n\n  /**\n   * Initialises an stack environment with current font definition in the parser.\n   * @param {TexParser} parser The current tex parser.\n   * @return {EnvList} The initialised environment list.\n   */\n  export function getFontDef(parser: TexParser): EnvList {\n    const font = parser.stack.env['font'];\n    return (font ? {mathvariant: font} : {});\n  }\n\n\n  /**\n   * Splits a package option list of the form [x=y,z=1] into an attribute list\n   * of the form {x: y, z: 1}.\n   * @param {string} attrib The attributes of the package.\n   * @param {{[key: string]: number}?} allowed A list of allowed options. If\n   *     given only allowed arguments are returned.\n   * @param {boolean?} error If true, raises an exception if not allowed options\n   *     are found.\n   * @return {EnvList} The attribute list.\n   */\n  export function keyvalOptions(attrib: string,\n                                allowed: {[key: string]: number} = null,\n                                error: boolean = false): EnvList {\n    let def: EnvList = readKeyval(attrib);\n    if (allowed) {\n      for (let key of Object.keys(def)) {\n        if (!allowed.hasOwnProperty(key)) {\n          if (error) {\n            throw new TexError('InvalidOption', 'Invalid option: %1', key);\n          }\n          delete def[key];\n        }\n      }\n    }\n    return def;\n  }\n\n\n  /**\n   * Implementation of the keyval function from https://www.ctan.org/pkg/keyval\n   * @param {string} text The optional parameter string for a package or\n   *     command.\n   * @return {EnvList} Set of options as key/value pairs.\n   */\n  function readKeyval(text: string): EnvList {\n    let options: EnvList = {};\n    let rest = text;\n    let end, key, val;\n    while (rest) {\n      [key, end, rest] = readValue(rest, ['=', ',']);\n      if (end === '=') {\n        [val, end, rest] = readValue(rest, [',']);\n        val = (val === 'false' || val === 'true') ?\n            JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n\n\n  /**\n   * Removes pairs of outer braces.\n   * @param {string} text The string to clean.\n   * @param {number} count The number of outer braces to slice off.\n   * @return {string} The cleaned string.\n   */\n  function removeBraces(text: string, count: number): string {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n\n\n  /**\n   * Read a value from the given string until an end parameter is reached or\n   * string is exhausted.\n   * @param {string} text The string to process.\n   * @param {string[]} end List of possible end characters.\n   * @return {[string, string, string]} The collected value, the actual end\n   *     character, and the rest of the string still to parse.\n   */\n  function readValue(text: string, end: string[]): [string, string, string] {\n    let length = text.length;\n    let braces = 0;\n    let value = '';\n    let index = 0;\n    let start = 0;             // Counter for the starting left braces.\n    let startCount = true;     // Flag for counting starting left braces.\n    let stopCount = false;     // If true right braces are found directly\n                               // after starting braces, but no other char yet.\n    while (index < length) {\n      let c = text[index++];\n      switch (c) {\n      case ' ':                // Ignore spaces.\n        break;\n      case '{':\n        if (startCount) {      // Count start left braces at start.\n          start++;\n        } else {\n          stopCount = false;\n          if (start > braces) {   // Some start left braces have been closed.\n            start = braces;\n          }\n        }\n        braces++;\n        break;\n      case '}':\n        if (braces) {          // Closing braces.\n          braces--;\n        }\n        if (startCount || stopCount) {  // Closing braces at the start.\n          start--;\n          stopCount = true;    // Continue to close braces.\n        }\n        startCount = false;    // Stop counting start left braces.\n        break;\n      default:\n        if (!braces && end.indexOf(c) !== -1) {   // End character reached.\n          return [stopCount ? 'true' :            // If Stop count is true we\n                                                  // have balanced braces, only.\n                  removeBraces(value, start), c, text.slice(index)];\n        }\n        startCount = false;\n        stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError('ExtraOpenMissingClose',\n                         'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n\n}\n\nexport default ParseUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}