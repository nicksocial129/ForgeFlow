{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TexError_js_1 = __importDefault(require(\"../TexError.js\"));\nvar sm = __importStar(require(\"../SymbolMap.js\"));\nvar BaseMethods_js_1 = __importDefault(require(\"../base/BaseMethods.js\"));\nvar ParseUtil_js_1 = __importDefault(require(\"../ParseUtil.js\"));\nvar NewcommandUtil_js_1 = __importDefault(require(\"./NewcommandUtil.js\"));\nvar NewcommandMethods = {};\nNewcommandMethods.NewCommand = function (parser, name) {\n  var cs = NewcommandUtil_js_1.default.GetCsNameArgument(parser, name);\n  var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);\n  var opt = parser.GetBrackets(name);\n  var def = parser.GetArgument(name);\n  NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [def, n, opt]);\n};\nNewcommandMethods.NewEnvironment = function (parser, name) {\n  var env = ParseUtil_js_1.default.trimSpaces(parser.GetArgument(name));\n  var n = NewcommandUtil_js_1.default.GetArgCount(parser, name);\n  var opt = parser.GetBrackets(name);\n  var bdef = parser.GetArgument(name);\n  var edef = parser.GetArgument(name);\n  NewcommandUtil_js_1.default.addEnvironment(parser, env, NewcommandMethods.BeginEnv, [true, bdef, edef, n, opt]);\n};\nNewcommandMethods.MacroDef = function (parser, name) {\n  var cs = NewcommandUtil_js_1.default.GetCSname(parser, name);\n  var params = NewcommandUtil_js_1.default.GetTemplate(parser, name, '\\\\' + cs);\n  var def = parser.GetArgument(name);\n  !(params instanceof Array) ? NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [def, params]) : NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.MacroWithTemplate, [def].concat(params));\n};\nNewcommandMethods.Let = function (parser, name) {\n  var cs = NewcommandUtil_js_1.default.GetCSname(parser, name);\n  var c = parser.GetNext();\n  if (c === '=') {\n    parser.i++;\n    c = parser.GetNext();\n  }\n  var handlers = parser.configuration.handlers;\n  if (c === '\\\\') {\n    name = NewcommandUtil_js_1.default.GetCSname(parser, name);\n    var macro_1 = handlers.get('delimiter').lookup('\\\\' + name);\n    if (macro_1) {\n      NewcommandUtil_js_1.default.addDelimiter(parser, '\\\\' + cs, macro_1.char, macro_1.attributes);\n      return;\n    }\n    var map_1 = handlers.get('macro').applicable(name);\n    if (!map_1) {\n      return;\n    }\n    if (map_1 instanceof sm.MacroMap) {\n      var macro_2 = map_1.lookup(name);\n      NewcommandUtil_js_1.default.addMacro(parser, cs, macro_2.func, macro_2.args, macro_2.symbol);\n      return;\n    }\n    macro_1 = map_1.lookup(name);\n    var newArgs = NewcommandUtil_js_1.default.disassembleSymbol(cs, macro_1);\n    var method = function (p, _cs) {\n      var rest = [];\n      for (var _i = 2; _i < arguments.length; _i++) {\n        rest[_i - 2] = arguments[_i];\n      }\n      var symb = NewcommandUtil_js_1.default.assembleSymbol(rest);\n      return map_1.parser(p, symb);\n    };\n    NewcommandUtil_js_1.default.addMacro(parser, cs, method, newArgs);\n    return;\n  }\n  parser.i++;\n  var macro = handlers.get('delimiter').lookup(c);\n  if (macro) {\n    NewcommandUtil_js_1.default.addDelimiter(parser, '\\\\' + cs, macro.char, macro.attributes);\n    return;\n  }\n  NewcommandUtil_js_1.default.addMacro(parser, cs, NewcommandMethods.Macro, [c]);\n};\nNewcommandMethods.MacroWithTemplate = function (parser, name, text, n) {\n  var params = [];\n  for (var _i = 4; _i < arguments.length; _i++) {\n    params[_i - 4] = arguments[_i];\n  }\n  var argCount = parseInt(n, 10);\n  if (argCount) {\n    var args = [];\n    parser.GetNext();\n    if (params[0] && !NewcommandUtil_js_1.default.MatchParam(parser, params[0])) {\n      throw new TexError_js_1.default('MismatchUseDef', 'Use of %1 doesn\\'t match its definition', name);\n    }\n    for (var i = 0; i < argCount; i++) {\n      args.push(NewcommandUtil_js_1.default.GetParameter(parser, name, params[i + 1]));\n    }\n    text = ParseUtil_js_1.default.substituteArgs(parser, args, text);\n  }\n  parser.string = ParseUtil_js_1.default.addArgs(parser, text, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil_js_1.default.checkMaxMacros(parser);\n};\nNewcommandMethods.BeginEnv = function (parser, begin, bdef, edef, n, def) {\n  if (begin.getProperty('end') && parser.stack.env['closing'] === begin.getName()) {\n    delete parser.stack.env['closing'];\n    var rest = parser.string.slice(parser.i);\n    parser.string = edef;\n    parser.i = 0;\n    parser.Parse();\n    parser.string = rest;\n    parser.i = 0;\n    return parser.itemFactory.create('end').setProperty('name', begin.getName());\n  }\n  if (n) {\n    var args = [];\n    if (def != null) {\n      var optional = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n      args.push(optional == null ? def : optional);\n    }\n    for (var i = args.length; i < n; i++) {\n      args.push(parser.GetArgument('\\\\begin{' + begin.getName() + '}'));\n    }\n    bdef = ParseUtil_js_1.default.substituteArgs(parser, args, bdef);\n    edef = ParseUtil_js_1.default.substituteArgs(parser, [], edef);\n  }\n  parser.string = ParseUtil_js_1.default.addArgs(parser, bdef, parser.string.slice(parser.i));\n  parser.i = 0;\n  return parser.itemFactory.create('beginEnv').setProperty('name', begin.getName());\n};\nNewcommandMethods.Macro = BaseMethods_js_1.default.Macro;\nexports.default = NewcommandMethods;","map":{"version":3,"names":["TexError_js_1","__importDefault","require","sm","__importStar","BaseMethods_js_1","ParseUtil_js_1","NewcommandUtil_js_1","NewcommandMethods","NewCommand","parser","name","cs","default","GetCsNameArgument","n","GetArgCount","opt","GetBrackets","def","GetArgument","addMacro","Macro","NewEnvironment","env","trimSpaces","bdef","edef","addEnvironment","BeginEnv","MacroDef","GetCSname","params","GetTemplate","Array","MacroWithTemplate","concat","Let","c","GetNext","i","handlers","configuration","macro_1","get","lookup","addDelimiter","char","attributes","map_1","applicable","MacroMap","macro_2","func","args","symbol","newArgs","disassembleSymbol","method","p","_cs","rest","_i","arguments","length","symb","assembleSymbol","macro","text","argCount","parseInt","MatchParam","push","GetParameter","substituteArgs","string","addArgs","slice","checkMaxMacros","begin","getProperty","stack","getName","Parse","itemFactory","create","setProperty","optional","exports"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/newcommand/NewcommandMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Mappings for TeX parsing for definitorial commands.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {ParseMethod} from '../Types.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport * as sm from '../SymbolMap.js';\nimport {Symbol, Macro} from '../Symbol.js';\nimport BaseMethods from '../base/BaseMethods.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {StackItem} from '../StackItem.js';\nimport NewcommandUtil from './NewcommandUtil.js';\n\n\n// Namespace\nlet NewcommandMethods: Record<string, ParseMethod> = {};\n\n/**\n * Implements \\newcommand{\\name}[n][default]{...}\n * @param {TexParser} parser The calling parser.\n * @param {string} name The name of the calling command.\n */\nNewcommandMethods.NewCommand = function(parser: TexParser, name: string) {\n  // @test Newcommand Simple\n  let cs = NewcommandUtil.GetCsNameArgument(parser, name);\n  let n = NewcommandUtil.GetArgCount(parser, name);\n  let opt = parser.GetBrackets(name);\n  let def = parser.GetArgument(name);\n  NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [def, n, opt]);\n};\n\n\n/**\n * Implements \\newenvironment{name}[n][default]{begincmd}{endcmd}\n * @param {TexParser} parser The calling parser.\n * @param {string} name The name of the calling command.\n */\nNewcommandMethods.NewEnvironment = function(parser: TexParser, name: string) {\n  // @test Newenvironment Empty, Newenvironment Content\n  let env = ParseUtil.trimSpaces(parser.GetArgument(name));\n  let n = NewcommandUtil.GetArgCount(parser, name);\n  let opt = parser.GetBrackets(name);\n  let bdef = parser.GetArgument(name);\n  let edef = parser.GetArgument(name);\n  NewcommandUtil.addEnvironment(parser, env, NewcommandMethods.BeginEnv, [true, bdef, edef, n, opt]);\n};\n\n\n/**\n * Implements \\def command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The name of the calling command.\n */\nNewcommandMethods.MacroDef = function(parser: TexParser, name: string) {\n  // @test Def DoubleLet, DefReDef\n  let cs = NewcommandUtil.GetCSname(parser, name);\n  let params = NewcommandUtil.GetTemplate(parser, name, '\\\\' + cs);\n  let def = parser.GetArgument(name);\n  !(params instanceof Array) ?\n    // @test Def DoubleLet, DefReDef\n    NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [def, params]) :\n    // @test Def Let\n    NewcommandUtil.addMacro(parser, cs, NewcommandMethods.MacroWithTemplate, [def].concat(params));\n};\n\n\n/**\n * Implements the \\let command.\n *\n * All \\let commands create either new delimiters or macros in the extension\n * maps. In the latter case if the let binds a symbol we have to generate a\n * macro with the appropriate parse methods from the SymbolMap. Otherwise we\n * simply copy the macro under a new name.\n *\n * Let does not always work on special characters as TeX does.  For example\n * \"\\let\\car^ a\\car b\" will yield a superscript, on the otherhand\n * \\let\\bgroup={ is possible and will work fine in \\bgroup a } but will fail\n * in \\sqrt\\bgroup a}.\n *\n * @param {TexParser} parser The calling parser.\n * @param {string} name The name of the calling command.\n */\nNewcommandMethods.Let = function(parser: TexParser, name: string) {\n  const cs = NewcommandUtil.GetCSname(parser, name);\n  let c = parser.GetNext();\n  // @test Let Bar, Let Caret\n  if (c === '=') {\n    // @test Let Brace Equal, Let Brace Equal Stretchy\n    parser.i++;\n    c = parser.GetNext();\n  }\n  const handlers = parser.configuration.handlers;\n  if (c === '\\\\') {\n    // @test Let Bar, Let Brace Equal Stretchy\n    name = NewcommandUtil.GetCSname(parser, name);\n    let macro = handlers.get('delimiter').lookup('\\\\' + name) as Symbol;\n    if (macro) {\n      // @test Let Bar, Let Brace Equal Stretchy\n      NewcommandUtil.addDelimiter(parser, '\\\\' + cs, macro.char, macro.attributes);\n      return;\n    }\n    const map = handlers.get('macro').applicable(name);\n    if (!map) {\n      // @test Let Undefined CS\n      return;\n    }\n    if (map instanceof sm.MacroMap) {\n      // @test Def Let, Newcommand Let\n      const macro = (map as sm.CommandMap).lookup(name) as Macro;\n      NewcommandUtil.addMacro(parser, cs, macro.func, macro.args, macro.symbol);\n      return;\n    }\n    macro = (map as sm.CharacterMap).lookup(name) as Symbol;\n    const newArgs = NewcommandUtil.disassembleSymbol(cs, macro);\n    const method = (p: TexParser, _cs: string, ...rest: any[]) => {\n      // @test Let Relet, Let Let, Let Circular Macro\n      const symb = NewcommandUtil.assembleSymbol(rest);\n      return map.parser(p, symb);\n    };\n    NewcommandUtil.addMacro(parser, cs, method, newArgs);\n    return;\n  }\n  // @test Let Brace Equal, Let Caret\n  parser.i++;\n  const macro = handlers.get('delimiter').lookup(c) as Symbol;\n  if (macro) {\n    // @test Let Paren Delim, Let Paren Stretchy\n    NewcommandUtil.addDelimiter(parser, '\\\\' + cs, macro.char, macro.attributes);\n    return;\n  }\n  // @test Let Brace Equal, Let Caret\n  NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [c]);\n};\n\n\n/**\n * Process a macro with a parameter template by replacing parameters in the\n * parser's string.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The name of the calling command.\n * @param {string} text The text template of the macro.\n * @param {string} n The number of parameters.\n * @param {string[]} ...params The parameter values.\n */\nNewcommandMethods.MacroWithTemplate = function (parser: TexParser, name: string,\n                                                text: string, n: string,\n                                                ...params: string[]) {\n  const argCount = parseInt(n, 10);\n  // @test Def Let\n  if (argCount) {\n    // @test Def Let\n    let args = [];\n    parser.GetNext();\n    if (params[0] && !NewcommandUtil.MatchParam(parser, params[0])) {\n      // @test Missing Arguments\n      throw new TexError('MismatchUseDef',\n                          'Use of %1 doesn\\'t match its definition', name);\n    }\n    for (let i = 0; i < argCount; i++) {\n      // @test Def Let\n      args.push(NewcommandUtil.GetParameter(parser, name, params[i + 1]));\n    }\n    text = ParseUtil.substituteArgs(parser, args, text);\n  }\n  parser.string = ParseUtil.addArgs(parser, text,\n                                    parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil.checkMaxMacros(parser);\n};\n\n\n/**\n * Process a user-defined environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The begin stackitem.\n * @param {string} bdef The begin definition in the newenvironment macro.\n * @param {string} edef The end definition in the newenvironment macro.\n * @param {number} n The number of parameters.\n * @param {string} def Default for an optional parameter.\n */\nNewcommandMethods.BeginEnv = function(parser: TexParser, begin: StackItem,\n                                      bdef: string, edef: string, n: number, def: string) {\n  // @test Newenvironment Empty, Newenvironment Content\n  // We have an end item, and we are supposed to close this environment.\n  if (begin.getProperty('end') && parser.stack.env['closing'] === begin.getName()) {\n    // @test Newenvironment Empty, Newenvironment Content\n    delete parser.stack.env['closing'];\n    // Parse the commands in the end environment definition.\n    let rest = parser.string.slice(parser.i);\n    parser.string = edef;\n    parser.i = 0;\n    parser.Parse();\n    // Reset to parsing the remainder of the expression.\n    parser.string = rest;\n    parser.i = 0;\n    // Close this environment.\n    return parser.itemFactory.create('end').setProperty('name', begin.getName());\n  }\n  if (n) {\n    // @test Newenvironment Optional, Newenvironment Arg Optional\n    let args: string[] = [];\n    if (def != null) {\n      // @test Newenvironment Optional, Newenvironment Arg Optional\n      let optional = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n      args.push(optional == null ? def : optional);\n    }\n    for (let i = args.length; i < n; i++) {\n      // @test Newenvironment Arg Optional\n      args.push(parser.GetArgument('\\\\begin{' + begin.getName() + '}'));\n    }\n    bdef = ParseUtil.substituteArgs(parser, args, bdef);\n    edef = ParseUtil.substituteArgs(parser, [], edef); // no args, but get errors for #n in edef\n  }\n  parser.string = ParseUtil.addArgs(parser, bdef,\n                                    parser.string.slice(parser.i));\n  parser.i = 0;\n  return parser.itemFactory.create('beginEnv').setProperty('name', begin.getName());\n};\n\nNewcommandMethods.Macro = BaseMethods.Macro;\n\nexport default NewcommandMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}