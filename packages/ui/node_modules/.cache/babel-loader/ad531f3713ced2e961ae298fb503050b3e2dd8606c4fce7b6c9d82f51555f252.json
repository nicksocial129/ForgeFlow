{"ast":null,"code":"/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport { longestStreak } from 'longest-streak';\nimport { safe } from 'mdast-util-to-markdown/lib/util/safe.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js';\nimport { patternCompile } from 'mdast-util-to-markdown/lib/util/pattern-compile.js';\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: ['math', 'math-display']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = /** @type {Math} */this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return;\n    this.buffer();\n    this.setData('mathFlowInside', true);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node = /** @type {Math} */this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data;\n    this.setData('mathFlowInside');\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: ['math', 'math-inline']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = /** @type {Math} */this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '\\n',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '$',\n      after: single ? undefined : '\\\\$',\n      inConstruct: 'phrasing'\n    }, {\n      character: '$',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || '';\n    const tracker = track(safeOptions);\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = context.enter('mathFlow');\n    let value = tracker.move(sequence);\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta');\n      value += tracker.move(safe(context, node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['$'],\n        ...tracker.current()\n      }));\n      subexit();\n    }\n    value += tracker.move('\\n');\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || '';\n    let size = 1;\n    if (!single) size++;\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    }\n    const sequence = '$'.repeat(size);\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n    // Contains non-space.\n    /[^ \\r\\n]/.test(value) && (\n    // Starts with space and ends with space.\n    /^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) ||\n    // Starts or ends with dollar.\n    /^\\$|\\$$/.test(value))) {\n      value = ' ' + value + ' ';\n    }\n    let index = -1;\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index];\n      const expression = patternCompile(pattern);\n      /** @type {RegExpExecArray | null} */\n      let match;\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue;\n      while (match = expression.exec(value)) {\n        let position = match.index;\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (value.codePointAt(position) === 10 /* `\\n` */ && value.codePointAt(position - 1) === 13 /* `\\r` */) {\n          position--;\n        }\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n      }\n    }\n    return sequence + value + sequence;\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":{"version":3,"names":["longestStreak","safe","track","patternCompile","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","type","meta","value","data","hName","hProperties","className","hChildren","buffer","resume","node","stack","length","getData","setData","replace","config","call","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","tracker","sequence","repeat","Math","max","move","subexit","before","encode","current","size","RegExp","test","index","pattern","expression","match","exec","position","codePointAt","slice"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mdast-util-math/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}