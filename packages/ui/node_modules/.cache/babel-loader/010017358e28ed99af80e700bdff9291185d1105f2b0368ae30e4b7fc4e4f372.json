{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TagsFactory = exports.AllTags = exports.NoTags = exports.AbstractTags = exports.TagInfo = exports.Label = void 0;\nvar TexParser_js_1 = __importDefault(require(\"./TexParser.js\"));\nvar Label = function () {\n  function Label(tag, id) {\n    if (tag === void 0) {\n      tag = '???';\n    }\n    if (id === void 0) {\n      id = '';\n    }\n    this.tag = tag;\n    this.id = id;\n  }\n  return Label;\n}();\nexports.Label = Label;\nvar TagInfo = function () {\n  function TagInfo(env, taggable, defaultTags, tag, tagId, tagFormat, noTag, labelId) {\n    if (env === void 0) {\n      env = '';\n    }\n    if (taggable === void 0) {\n      taggable = false;\n    }\n    if (defaultTags === void 0) {\n      defaultTags = false;\n    }\n    if (tag === void 0) {\n      tag = null;\n    }\n    if (tagId === void 0) {\n      tagId = '';\n    }\n    if (tagFormat === void 0) {\n      tagFormat = '';\n    }\n    if (noTag === void 0) {\n      noTag = false;\n    }\n    if (labelId === void 0) {\n      labelId = '';\n    }\n    this.env = env;\n    this.taggable = taggable;\n    this.defaultTags = defaultTags;\n    this.tag = tag;\n    this.tagId = tagId;\n    this.tagFormat = tagFormat;\n    this.noTag = noTag;\n    this.labelId = labelId;\n  }\n  return TagInfo;\n}();\nexports.TagInfo = TagInfo;\nvar AbstractTags = function () {\n  function AbstractTags() {\n    this.counter = 0;\n    this.allCounter = 0;\n    this.configuration = null;\n    this.ids = {};\n    this.allIds = {};\n    this.labels = {};\n    this.allLabels = {};\n    this.redo = false;\n    this.refUpdate = false;\n    this.currentTag = new TagInfo();\n    this.history = [];\n    this.stack = [];\n    this.enTag = function (node, tag) {\n      var nf = this.configuration.nodeFactory;\n      var cell = nf.create('node', 'mtd', [node]);\n      var row = nf.create('node', 'mlabeledtr', [tag, cell]);\n      var table = nf.create('node', 'mtable', [row], {\n        side: this.configuration.options['tagSide'],\n        minlabelspacing: this.configuration.options['tagIndent'],\n        displaystyle: true\n      });\n      return table;\n    };\n  }\n  AbstractTags.prototype.start = function (env, taggable, defaultTags) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  };\n  Object.defineProperty(AbstractTags.prototype, \"env\", {\n    get: function () {\n      return this.currentTag.env;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractTags.prototype.end = function () {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  };\n  AbstractTags.prototype.tag = function (tag, noFormat) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  };\n  AbstractTags.prototype.notag = function () {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  };\n  Object.defineProperty(AbstractTags.prototype, \"noTag\", {\n    get: function () {\n      return this.currentTag.noTag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTags.prototype, \"label\", {\n    get: function () {\n      return this.currentTag.labelId;\n    },\n    set: function (label) {\n      this.currentTag.labelId = label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractTags.prototype.formatUrl = function (id, base) {\n    return base + '#' + encodeURIComponent(id);\n  };\n  AbstractTags.prototype.formatTag = function (tag) {\n    return '(' + tag + ')';\n  };\n  AbstractTags.prototype.formatId = function (id) {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  };\n  AbstractTags.prototype.formatNumber = function (n) {\n    return n.toString();\n  };\n  AbstractTags.prototype.autoTag = function () {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  };\n  AbstractTags.prototype.clearTag = function () {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  };\n  AbstractTags.prototype.getTag = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    var ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  };\n  AbstractTags.prototype.resetTag = function () {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  };\n  AbstractTags.prototype.reset = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  };\n  AbstractTags.prototype.startEquation = function (math) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    var recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  };\n  AbstractTags.prototype.finishEquation = function (math) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  };\n  AbstractTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.currentTag.env || this.currentTag.tag == null) {\n      return node;\n    }\n    var tag = this.makeTag();\n    var table = this.enTag(node, tag);\n    return table;\n  };\n  AbstractTags.prototype.makeId = function () {\n    this.currentTag.tagId = this.formatId(this.configuration.options['useLabelIds'] ? this.label || this.currentTag.tag : this.currentTag.tag);\n  };\n  AbstractTags.prototype.makeTag = function () {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    var mml = new TexParser_js_1.default('\\\\text{' + this.currentTag.tagFormat + '}', {}, this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml], {\n      id: this.currentTag.tagId\n    });\n  };\n  return AbstractTags;\n}();\nexports.AbstractTags = AbstractTags;\nvar NoTags = function (_super) {\n  __extends(NoTags, _super);\n  function NoTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NoTags.prototype.autoTag = function () {};\n  NoTags.prototype.getTag = function () {\n    return !this.currentTag.tag ? null : _super.prototype.getTag.call(this);\n  };\n  return NoTags;\n}(AbstractTags);\nexports.NoTags = NoTags;\nvar AllTags = function (_super) {\n  __extends(AllTags, _super);\n  function AllTags() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  AllTags.prototype.finalize = function (node, env) {\n    if (!env.display || this.history.find(function (x) {\n      return x.taggable;\n    })) {\n      return node;\n    }\n    var tag = this.getTag(true);\n    return this.enTag(node, tag);\n  };\n  return AllTags;\n}(AbstractTags);\nexports.AllTags = AllTags;\nvar TagsFactory;\n(function (TagsFactory) {\n  var tagsMapping = new Map([['none', NoTags], ['all', AllTags]]);\n  var defaultTags = 'none';\n  TagsFactory.OPTIONS = {\n    tags: defaultTags,\n    tagSide: 'right',\n    tagIndent: '0.8em',\n    useLabelIds: true,\n    ignoreDuplicateLabels: false\n  };\n  TagsFactory.add = function (name, constr) {\n    tagsMapping.set(name, constr);\n  };\n  TagsFactory.addTags = function (tags) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.keys(tags)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        TagsFactory.add(key, tags[key]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  TagsFactory.create = function (name) {\n    var constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n      throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n  TagsFactory.setDefault = function (name) {\n    defaultTags = name;\n  };\n  TagsFactory.getDefault = function () {\n    return TagsFactory.create(defaultTags);\n  };\n})(TagsFactory = exports.TagsFactory || (exports.TagsFactory = {}));","map":{"version":3,"names":["TexParser_js_1","__importDefault","require","Label","tag","id","exports","TagInfo","env","taggable","defaultTags","tagId","tagFormat","noTag","labelId","AbstractTags","counter","allCounter","configuration","ids","allIds","labels","allLabels","redo","refUpdate","currentTag","history","stack","enTag","node","nf","nodeFactory","cell","create","row","table","side","options","minlabelspacing","displaystyle","prototype","start","push","Object","defineProperty","get","end","pop","noFormat","formatTag","notag","set","label","formatUrl","base","encodeURIComponent","formatId","replace","formatNumber","n","toString","autoTag","clearTag","getTag","force","makeTag","ct","resetTag","reset","offset","startEquation","math","undefined","recompile","inputData","finishEquation","state","assign","finalize","display","makeId","mml","default","NoTags","_super","__extends","call","AllTags","find","x","TagsFactory","tagsMapping","Map","OPTIONS","tags","tagSide","tagIndent","useLabelIds","ignoreDuplicateLabels","add","name","constr","addTags","_b","__values","keys","_c","next","done","key","value","Error","setDefault","getDefault"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/Tags.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Class for generating tags, references, etc.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport TexParser from './TexParser.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MathItem} from '../../core/MathItem.js';\nimport {EnvList} from './StackItem.js';\nimport ParseOptions from './ParseOptions.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n *  Simple class for label objects.\n */\nexport class Label {\n\n  /**\n   * @constructor\n   * @param {string=} tag The tag that's displayed.\n   * @param {string=} id The id that serves as reference.\n   */\n  constructor(public tag: string = '???', public id: string = '') {}\n}\n\n\n/**\n * A simple class for keeping track of tag information.\n */\nexport class TagInfo {\n\n  /**\n   * @constructor\n   * @param {string} env The environment name (e.g., align).\n   * @param {boolean} taggable Environment supports tags (e.g., align* does, but\n   *     split does not.)\n   * @param {boolean} defaultTags Environment is tagged by default (e.g., align\n   *     is, but align* is not).\n   * @param {string} tag The tag name (e.g., 1).\n   * @param {string} tagId The unique id for that tag (e.g., mjx-eqn:1).\n   * @param {string} tagFormat The formatted tag (e.g., \"(1)\").\n   * @param {boolean} noTag A no tagging command has been set (e.g., \\notag,\n   *     \\nonumber).\n   * @param {string} labelId The label referring to the tag.\n   */\n  constructor(readonly env: string = '',\n              readonly taggable: boolean = false,\n              readonly defaultTags: boolean = false,\n              public tag: string = null,\n              public tagId: string = '',\n              public tagFormat: string = '',\n              public noTag: boolean = false,\n              public labelId: string = '') {}\n\n}\n\n\nexport interface Tags {\n\n  /**\n   * The global configurations in which the parsing takes place.\n   * @type {ParseOptions}\n   */\n  configuration: ParseOptions;\n\n  /**\n   * IDs used in this equation.\n   * @type {Object.<boolean>}\n   */\n  ids: {[key: string]: boolean};\n\n  /**\n   * IDs used in previous equations.\n   * @type {Object.<boolean>}\n   */\n  allIds: {[key: string]: boolean};\n\n  /**\n   * Labels in the current equation.\n   * @type {Object.<Label>}\n   */\n  labels: {[key: string]: Label};\n\n  /**\n   * Labels in previous equations.\n   * @type {Object.<Label>}\n   */\n  allLabels: {[key: string]: Label};\n\n  /**\n   * The label to use for the next tag.\n   * @type {string}\n   */\n  label: string;\n\n  /**\n   * True if the equation contains an undefined label and must be reprocessed later.\n   * @type {boolean}\n   */\n  redo: boolean;\n\n  /**\n   * True when recompiling to update undefined references\n   * @type {boolean}\n   */\n  refUpdate: boolean;\n\n  /**\n   * The environment that is currently tagged.\n   * @type {string}\n   */\n  env: string;\n\n  /**\n   * The currently active tag.\n   * @type {TagInfo}\n   */\n  currentTag: TagInfo;\n\n  /**\n   * How to format tags.\n   * @param {string} tag The tag string.\n   * @return {string} The formatted numbered tag.\n   */\n  formatTag(tag: string): string;\n\n  /**\n   * How to format URLs for references.\n   * @param {string} id The reference id.\n   * @param {string} base The base URL in the reference.\n   * @return {}\n   */\n  formatUrl(id: string, base: string): string;\n\n  /**\n   * Set the tag automatically, by incrementing equation number.\n   */\n  autoTag(): void;\n\n  /**\n   * @return {MmlNode|void} Generates and returns the tag node.\n   */\n  getTag(): MmlNode | void;\n\n  /**\n   * Clears tagging information.\n   */\n  clearTag(): void;\n\n  /**\n   * Resets the tag structure after an expression has been typeset.\n   */\n  resetTag(): void;\n\n  /**\n   * Fully resets the tag structure, in particular all the tagging and label\n   * history.\n   * @param {number} offset A new offset value to start counting ids from.\n   */\n  reset(offset?: number): void;\n\n  /**\n   * Initialise tagging for a MathItem\n   * (clear equation-specific labels and ids, set counter\n   * and check for recompile)\n   * @param {MathItem} math   The MathItem for the current equation\n   */\n    startEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Move equation-specific labels and ids to global ones,\n   * save the counter, and mark the MathItem for redos\n   */\n    finishEquation(math: MathItem<any, any, any>): void;\n\n  /**\n   * Finalizes tag creation.\n   * @param {MmlNode} node\n   * @param {EnvList} env List of environment properties.\n   * @return {MmlNode} The newly created tag.\n   */\n  finalize(node: MmlNode, env: EnvList): MmlNode;\n\n  /**\n   * Starts tagging on a given environment.\n   * @param {string} env The name of the environment.\n   * @param {boolean} taggable True if taggable.\n   * @param {boolean} defaultTags True if tagged by default.\n   */\n  start(env: string, taggable: boolean, defaultTags: boolean): void;\n\n  /**\n   * End tagging.\n   */\n  end(): void;\n\n  /**\n   * Computes the next tag.\n   * @param {string} tag The tag content.\n   * @param {boolean} noFormat True if tag should not be formatted.\n   */\n  tag(tag: string, noFormat: boolean): void;\n\n  /**\n   * Call an explicit no tag.\n   */\n  notag(): void;\n\n  /**\n   * Entag an element by creating a table around it.\n   * @param {MmlNode} node The node to be tagged.\n   * @param {MmlNode} tag The tag node.\n   * @return {MmlNode} The table node containing the original node and tag.\n   */\n  enTag(node: MmlNode, tag: MmlNode): MmlNode;\n}\n\n\nexport class AbstractTags implements Tags {\n\n  /**\n   * Current equation number.\n   * @type {number}\n   */\n  protected counter: number = 0;\n\n  /**\n   * Equation number as equation begins.\n   * @type {number}\n   */\n  protected allCounter: number = 0;\n\n  /**\n   * @override\n   */\n  public configuration: ParseOptions = null;\n\n  /**\n   * @override\n   */\n  public ids: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public allIds: {[key: string]: boolean} = {};\n\n  /**\n   * @override\n   */\n  public labels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public allLabels: {[key: string]: Label} = {};\n\n  /**\n   * @override\n   */\n  public redo: boolean = false;\n\n  /**\n   * @override\n   */\n  public refUpdate: boolean = false;\n\n  /**\n   * @override\n   */\n  public currentTag: TagInfo = new TagInfo();\n\n\n  /**\n   * Chronology of all previous tags, in case we need to look something up in\n   * the finalize method.\n   * @type {TagInfo[]}\n   */\n  protected history: TagInfo[] = [];\n\n  private stack: TagInfo[] = [];\n\n  /**\n   * @override\n   */\n  public start(env: string, taggable: boolean, defaultTags: boolean) {\n    if (this.currentTag) {\n      this.stack.push(this.currentTag);\n    }\n    this.currentTag = new TagInfo(env, taggable, defaultTags);\n  }\n\n  public get env() {\n    return this.currentTag.env;\n  }\n\n\n  /**\n   * @override\n   */\n  public end() {\n    this.history.push(this.currentTag);\n    this.currentTag = this.stack.pop();\n  }\n\n\n  /**\n   * @override\n   */\n  public tag(tag: string, noFormat: boolean) {\n    this.currentTag.tag = tag;\n    this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);\n    this.currentTag.noTag = false;\n  }\n\n\n  /**\n   * @override\n   */\n  public notag() {\n    this.tag('', true);\n    this.currentTag.noTag = true;\n  }\n\n  protected get noTag(): boolean {\n    return this.currentTag.noTag;\n  }\n\n  public set label(label: string) {\n    this.currentTag.labelId = label;\n  }\n\n  public get label() {\n    return this.currentTag.labelId;\n  }\n\n  /**\n   * @override\n   */\n  public formatUrl(id: string, base: string) {\n    return base + '#' + encodeURIComponent(id);\n  }\n\n  /**\n   * @override\n   */\n  public formatTag(tag: string) {\n    return '(' + tag + ')';\n  }\n\n  /**\n   * How to format ids for labelling equations.\n   * @param {string} id The unique part of the id (e.g., label or number).\n   * @return {string} The formatted id.\n   */\n  protected formatId(id: string): string {\n    return 'mjx-eqn:' + id.replace(/\\s/g, '_');\n  }\n\n  /**\n   * How to format numbers in tags.\n   * @param {number} n The tag number.\n   * @return {string} The formatted number.\n   */\n  protected formatNumber(n: number): string {\n    return n.toString();\n  }\n\n  // Tag handling functions.\n  /**\n   * @override\n   */\n  public autoTag() {\n    if (this.currentTag.tag == null) {\n      this.counter++;\n      this.tag(this.formatNumber(this.counter), false);\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public clearTag() {\n    this.label = '';\n    this.tag(null, true);\n    this.currentTag.tagId = '';\n  }\n\n\n  /**\n   * @override\n   */\n  public getTag(force: boolean = false) {\n    if (force) {\n      this.autoTag();\n      return this.makeTag();\n    }\n    const ct = this.currentTag;\n    if (ct.taggable && !ct.noTag) {\n      if (ct.defaultTags) {\n        this.autoTag();\n      }\n      if (ct.tag) {\n        return this.makeTag();\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @override\n   */\n  public resetTag() {\n    this.history = [];\n    this.redo = false;\n    this.refUpdate = false;\n    this.clearTag();\n  }\n\n  /**\n   * @override\n   */\n  public reset(offset: number = 0) {\n    this.resetTag();\n    this.counter = this.allCounter = offset;\n    this.allLabels = {};\n    this.allIds = {};\n  }\n\n  /**\n   * @override\n   */\n  public startEquation(math: MathItem<any, any, any>) {\n    this.history = [];\n    this.stack = [];\n    this.clearTag();\n    this.currentTag = new TagInfo('', undefined, undefined);\n    this.labels = {};\n    this.ids = {};\n    this.counter = this.allCounter;\n    this.redo = false;\n    const recompile = math.inputData.recompile;\n    if (recompile) {\n      this.refUpdate = true;\n      this.counter = recompile.counter;\n    }\n  }\n\n  /**\n   * @override\n   */\n  public finishEquation(math: MathItem<any, any, any>) {\n    if (this.redo) {\n      math.inputData.recompile = {\n        state: math.state(),\n        counter: this.allCounter\n      };\n    }\n    if (!this.refUpdate) {\n      this.allCounter = this.counter;\n    }\n    Object.assign(this.allIds, this.ids);\n    Object.assign(this.allLabels, this.labels);\n  }\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList): MmlNode {\n    if (!env.display || this.currentTag.env ||\n        this.currentTag.tag == null) {\n      return node;\n    }\n    let tag = this.makeTag();\n    let table = this.enTag(node, tag);\n    return table;\n  }\n\n  /**\n   * @override\n   */\n  public enTag = function(node: MmlNode, tag: MmlNode): MmlNode {\n    let nf = this.configuration.nodeFactory;\n    let cell = nf.create('node', 'mtd', [node]);\n    let row = nf.create('node', 'mlabeledtr', [tag, cell]);\n    let table = nf.create('node', 'mtable', [row], {\n      side: this.configuration.options['tagSide'],\n      minlabelspacing: this.configuration.options['tagIndent'],\n      displaystyle: true\n    });\n    return table;\n  };\n\n\n  /**\n   * Sets the tag id.\n   */\n  private makeId() {\n    this.currentTag.tagId = this.formatId(\n      this.configuration.options['useLabelIds'] ?\n        (this.label || this.currentTag.tag) : this.currentTag.tag);\n  }\n\n\n  /**\n   * @return {MmlNode} The actual tag node as an mtd.\n   */\n  private makeTag(): MmlNode {\n    this.makeId();\n    if (this.label) {\n      this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);\n    }\n    let mml = new TexParser('\\\\text{' + this.currentTag.tagFormat + '}', {},\n                            this.configuration).mml();\n    return this.configuration.nodeFactory.create('node', 'mtd', [mml],\n                                                 {id: this.currentTag.tagId});\n  }\n\n}\n\n\n/**\n * No tags, except where explicitly set.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class NoTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public autoTag() {}\n\n  /**\n   * @override\n   */\n  public getTag() {\n    return !this.currentTag.tag ? null : super.getTag();\n  }\n\n}\n\n\n/**\n * Tags every display formula. Exceptions are: Environments that explicitly\n * disallow tags, e.g., equation*.\n * @constructor\n * @extends {AbstractTags}\n */\nexport class AllTags extends AbstractTags {\n\n  /**\n   * @override\n   */\n  public finalize(node: MmlNode, env: EnvList) {\n    if (!env.display || this.history.find(\n      function(x: TagInfo) { return x.taggable; })) {\n      return node;\n    }\n    let tag = this.getTag(true);\n    return this.enTag(node, tag);\n  }\n\n}\n\n\n/**\n * Class interface for factory.\n * @interface\n */\nexport interface TagsClass {\n  new (): Tags;\n}\n\n\nexport namespace TagsFactory {\n\n  let tagsMapping = new Map<string, TagsClass>([\n    ['none', NoTags],\n    ['all', AllTags]\n  ]);\n\n  let defaultTags = 'none';\n\n  /**\n   * The default options for tagging\n   * @type {OptionList}\n   */\n  export let OPTIONS: OptionList = {\n    // Tagging style, used to be autonumber in v2.\n    tags: defaultTags,\n    // This specifies the side on which \\tag{} macros will place the tags.\n    // Set to 'left' to place on the left-hand side.\n    tagSide: 'right',\n    // This is the amount of indentation (from right or left) for the tags.\n    tagIndent: '0.8em',\n    // make element ID's use \\label name rather than equation number\n    // MJ puts in an equation prefix: mjx-eqn\n    // When true it uses the label name XXX as mjx-eqn:XXX\n    // If false it uses the actual number N that is displayed: mjx-eqn:N\n    useLabelIds: true,\n    // Set to true in order to prevent error messages for duplicate label ids\n    ignoreDuplicateLabels: false\n  };\n\n\n  /**\n   * Add a tagging object.\n   * @param {string} name Name of the tagging object.\n   * @param {TagsClass} constr The class of the Tagging object.\n   */\n  export let add = function(name: string, constr: TagsClass) {\n    tagsMapping.set(name, constr);\n  };\n\n\n  /**\n   * Adds a list of tagging objects to the factory.\n   * @param {{[name: string]: TagsClass}} tags The list of tagging objects.\n   */\n  export let addTags = function(tags: {[name: string]: TagsClass}) {\n    for (const key of Object.keys(tags)) {\n      TagsFactory.add(key, tags[key]);\n    }\n  };\n\n\n  /**\n   * Creates a new tagging object.\n   * @param {string} name The name of the tagging object.\n   * @return {Tags} The newly created object.\n   */\n  export let create = function(name: string): Tags {\n    let constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);\n    if (!constr) {\n        throw Error('Unknown tags class');\n    }\n    return new constr();\n  };\n\n\n  /**\n   * Set the name of the default tagging object.\n   * @param {string} name The default.\n   */\n  export let setDefault = function(name: string) {\n    defaultTags = name;\n  };\n\n\n  /**\n   * @return {Tags} The default tagging object.\n   */\n  export let getDefault = function(): Tags {\n    return TagsFactory.create(defaultTags);\n  };\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}