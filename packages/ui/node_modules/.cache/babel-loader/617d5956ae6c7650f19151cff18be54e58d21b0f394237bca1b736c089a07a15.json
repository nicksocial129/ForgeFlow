{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextMacrosMethods = void 0;\nvar TexParser_js_1 = __importDefault(require(\"../TexParser.js\"));\nvar Retries_js_1 = require(\"../../../util/Retries.js\");\nvar BaseMethods_js_1 = __importDefault(require(\"../base/BaseMethods.js\"));\nexports.TextMacrosMethods = {\n  Comment: function (parser, _c) {\n    while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n      parser.i++;\n    }\n    parser.i++;\n  },\n  Math: function (parser, open) {\n    parser.saveText();\n    var i = parser.i;\n    var j, c;\n    var braces = 0;\n    while (c = parser.GetNext()) {\n      j = parser.i++;\n      switch (c) {\n        case '\\\\':\n          var cs = parser.GetCS();\n          if (cs === ')') c = '\\\\(';\n        case '$':\n          if (braces === 0 && open === c) {\n            var config = parser.texParser.configuration;\n            var mml = new TexParser_js_1.default(parser.string.substr(i, j - i), parser.stack.env, config).mml();\n            parser.PushMath(mml);\n            return;\n          }\n          break;\n        case '{':\n          braces++;\n          break;\n        case '}':\n          if (braces === 0) {\n            parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n          }\n          braces--;\n          break;\n      }\n    }\n    parser.Error('MathNotTerminated', 'Math-mode is not properly terminated');\n  },\n  MathModeOnly: function (parser, c) {\n    parser.Error('MathModeOnly', '\\'%1\\' allowed only in math mode', c);\n  },\n  Misplaced: function (parser, c) {\n    parser.Error('Misplaced', '\\'%1\\' can not be used here', c);\n  },\n  OpenBrace: function (parser, _c) {\n    var env = parser.stack.env;\n    parser.envStack.push(env);\n    parser.stack.env = Object.assign({}, env);\n  },\n  CloseBrace: function (parser, _c) {\n    if (parser.envStack.length) {\n      parser.saveText();\n      parser.stack.env = parser.envStack.pop();\n    } else {\n      parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n    }\n  },\n  OpenQuote: function (parser, c) {\n    if (parser.string.charAt(parser.i) === c) {\n      parser.text += '\\u201C';\n      parser.i++;\n    } else {\n      parser.text += '\\u2018';\n    }\n  },\n  CloseQuote: function (parser, c) {\n    if (parser.string.charAt(parser.i) === c) {\n      parser.text += '\\u201D';\n      parser.i++;\n    } else {\n      parser.text += '\\u2019';\n    }\n  },\n  Tilde: function (parser, _c) {\n    parser.text += '\\u00A0';\n  },\n  Space: function (parser, _c) {\n    parser.text += ' ';\n    while (parser.GetNext().match(/\\s/)) parser.i++;\n  },\n  SelfQuote: function (parser, name) {\n    parser.text += name.substr(1);\n  },\n  Insert: function (parser, _name, c) {\n    parser.text += c;\n  },\n  Accent: function (parser, name, c) {\n    var base = parser.ParseArg(name);\n    var accent = parser.create('token', 'mo', {}, c);\n    parser.addAttributes(accent);\n    parser.Push(parser.create('node', 'mover', [base, accent]));\n  },\n  Emph: function (parser, name) {\n    var variant = parser.stack.env.mathvariant === '-tex-mathit' ? 'normal' : '-tex-mathit';\n    parser.Push(parser.ParseTextArg(name, {\n      mathvariant: variant\n    }));\n  },\n  SetFont: function (parser, _name, variant) {\n    parser.saveText();\n    parser.stack.env.mathvariant = variant;\n  },\n  SetSize: function (parser, _name, size) {\n    parser.saveText();\n    parser.stack.env.mathsize = size;\n  },\n  CheckAutoload: function (parser, name) {\n    var autoload = parser.configuration.packageData.get('autoload');\n    var texParser = parser.texParser;\n    name = name.slice(1);\n    var macro = texParser.lookup('macro', name);\n    if (!macro || autoload && macro._func === autoload.Autoload) {\n      texParser.parse('macro', [texParser, name]);\n      if (!macro) return;\n      (0, Retries_js_1.retryAfter)(Promise.resolve());\n    }\n    texParser.parse('macro', [parser, name]);\n  },\n  Macro: BaseMethods_js_1.default.Macro,\n  Spacer: BaseMethods_js_1.default.Spacer,\n  Hskip: BaseMethods_js_1.default.Hskip,\n  rule: BaseMethods_js_1.default.rule,\n  Rule: BaseMethods_js_1.default.Rule,\n  HandleRef: BaseMethods_js_1.default.HandleRef\n};","map":{"version":3,"names":["TexParser_js_1","__importDefault","require","Retries_js_1","BaseMethods_js_1","exports","TextMacrosMethods","Comment","parser","_c","i","string","length","charAt","Math","open","saveText","j","c","braces","GetNext","cs","GetCS","config","texParser","configuration","mml","default","substr","stack","env","PushMath","Error","MathModeOnly","Misplaced","OpenBrace","envStack","push","Object","assign","CloseBrace","pop","OpenQuote","text","CloseQuote","Tilde","Space","match","SelfQuote","name","Insert","_name","Accent","base","ParseArg","accent","create","addAttributes","Push","Emph","variant","mathvariant","ParseTextArg","SetFont","SetSize","size","mathsize","CheckAutoload","autoload","packageData","get","slice","macro","lookup","_func","Autoload","parse","retryAfter","Promise","resolve","Macro","Spacer","Hskip","rule","Rule","HandleRef"],"sources":["/Users/nickprince/Desktop/Flowise Working Commit/node_modules/mathjax-full/ts/input/tex/textmacros/TextMacrosMethods.ts"],"sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2020-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview  Method definitions for the textmacros package\n *\n * @author dpvc@mathjax.org (Davide P. Cervone)\n */\n\nimport TexParser from '../TexParser.js';\nimport {retryAfter} from '../../../util/Retries.js';\nimport {TextParser} from './TextParser.js';\nimport BaseMethods from '../base/BaseMethods.js';\n\n/**\n * The methods used to implement the text-mode macros\n */\nexport const TextMacrosMethods = {\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  Comment(parser: TextParser, _c: string) {\n    while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n      parser.i++;\n    }\n    parser.i++;\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} open         The delimiter used to open math-mode in text-mode\n   */\n  Math(parser: TextParser, open: string) {\n    parser.saveText();\n    let i = parser.i;\n    let j, c;\n    let braces = 0;\n    //\n    // Loop through the string looking for the closing delimiter, while matching braces\n    //\n    while ((c = parser.GetNext())) {\n      j = parser.i++;\n      switch (c) {\n\n      case '\\\\':\n        const cs = parser.GetCS();\n        if (cs === ')') c = '\\\\(';  // \\( is the opening delimiter for \\)\n      case '$':\n        //\n        //  If there are no unbalanced braces and we have found the close delimiter,\n        //    process the contents of the delimiters in math mode (using the original TeX parser)\n        //\n        if (braces === 0 && open === c) {\n          const config = parser.texParser.configuration;\n          const mml = (new TexParser(parser.string.substr(i, j - i), parser.stack.env, config)).mml();\n          parser.PushMath(mml);\n          return;\n        }\n        break;\n\n      case '{':\n        braces++;\n        break;\n\n      case '}':\n        if (braces === 0) {\n          parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n        }\n        braces--;\n        break;\n      }\n    }\n    parser.Error('MathNotTerminated', 'Math-mode is not properly terminated');\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  MathModeOnly(parser: TextParser, c: string) {\n    parser.Error('MathModeOnly', '\\'%1\\' allowed only in math mode', c);\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  Misplaced(parser: TextParser, c: string) {\n    parser.Error('Misplaced', '\\'%1\\' can not be used here', c);\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  OpenBrace(parser: TextParser, _c: string) {\n    //\n    //  Save the current stack environment and make a copy of it for\n    //    use within the braced group.\n    //\n    const env = parser.stack.env;\n    parser.envStack.push(env);\n    parser.stack.env = Object.assign({}, env);\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  CloseBrace(parser: TextParser, _c: string) {\n    //\n    //  Restore the saved stack environment, if there was one\n    //\n    if (parser.envStack.length) {\n      parser.saveText();\n      parser.stack.env = parser.envStack.pop();\n    } else {\n      parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n    }\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  OpenQuote(parser: TextParser, c: string) {\n    //\n    //  Handle smart open quotes\n    //\n    if (parser.string.charAt(parser.i) === c) {\n      parser.text += '\\u201C';\n      parser.i++;\n    } else {\n      parser.text += '\\u2018';\n    }\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  CloseQuote(parser: TextParser, c: string) {\n    //\n    //  Handle smart close quotes\n    //\n    if (parser.string.charAt(parser.i) === c) {\n      parser.text += '\\u201D';\n      parser.i++;\n    } else {\n      parser.text += '\\u2019';\n    }\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  Tilde(parser: TextParser, _c: string) {\n    parser.text += '\\u00A0';  // non-breaking space\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} c            The character that called this function\n   */\n  Space(parser: TextParser, _c: string) {\n    parser.text += ' ';  // regular space, but skipping multiple spaces\n    while (parser.GetNext().match(/\\s/)) parser.i++;\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   */\n  SelfQuote(parser: TextParser, name: string) {\n    parser.text += name.substr(1);  // add in the quoted character\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   * @param {string} c            The character to insert into the string\n   */\n  Insert(parser: TextParser, _name: string, c: string) {\n    parser.text += c;\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   * @param {string} c            The character to insert into the string\n   */\n  Accent(parser: TextParser, name: string, c: string) {\n    //\n    //  Create an accented character using mover\n    //\n    const base = parser.ParseArg(name);\n    const accent = parser.create('token', 'mo', {}, c);\n    parser.addAttributes(accent);\n    parser.Push(parser.create('node', 'mover', [base, accent]));\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   */\n  Emph(parser: TextParser, name: string) {\n    //\n    //  Switch to/from italics\n    //\n    const variant = (parser.stack.env.mathvariant === '-tex-mathit' ? 'normal' : '-tex-mathit');\n    parser.Push(parser.ParseTextArg(name, {mathvariant: variant}));\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   * @param {string} variant      The font variant to use from now on\n   */\n  SetFont(parser: TextParser, _name: string, variant: string) {\n    parser.saveText();\n    parser.stack.env.mathvariant = variant;\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   * @param {number} size         The font size to use from now on\n   */\n  SetSize(parser: TextParser, _name: string, size: number) {\n    parser.saveText();\n    parser.stack.env.mathsize = size;\n  },\n\n  /**\n   * @param {TextParser} parser   The text-mode parser\n   * @param {string} name         The control sequence that called this function\n   */\n  CheckAutoload(parser: TextParser, name: string) {\n    const autoload = parser.configuration.packageData.get('autoload');\n    const texParser = parser.texParser;\n    name = name.slice(1);\n    //\n    // Check if a macro is undefined, or currently set to autoload an extension.\n    // If so, process the macro in the original TexParser:\n    //    This will handle the undefined macro using the TeX parser's configuration, then return,\n    //    or will cause the autoloaded extension to load or be processed and restart the expression.\n    // Otherwise, process the macro in text mode.\n    //\n    const macro = texParser.lookup('macro', name);\n    if (!macro || (autoload && macro._func === autoload.Autoload)) {\n      texParser.parse('macro', [texParser, name]);\n      if (!macro) return;\n      retryAfter(Promise.resolve());\n    }\n    texParser.parse('macro', [parser, name]);\n  },\n\n  //\n  // Copy some methods from the base package\n  //\n  Macro: BaseMethods.Macro,\n  Spacer: BaseMethods.Spacer,\n  Hskip: BaseMethods.Hskip,\n  rule: BaseMethods.rule,\n  Rule: BaseMethods.Rule,\n  HandleRef: BaseMethods.HandleRef\n\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}