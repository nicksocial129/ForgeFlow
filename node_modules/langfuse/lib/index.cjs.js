'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var LangfusePersistedProperty;
(function (LangfusePersistedProperty) {
    LangfusePersistedProperty["Props"] = "props";
    LangfusePersistedProperty["Queue"] = "queue";
    LangfusePersistedProperty["OptedOut"] = "opted_out";
})(LangfusePersistedProperty || (LangfusePersistedProperty = {}));
var LangfusePostApiRoutes = {
    createTrace: ["POST", "/api/public/traces"],
    createEvent: ["POST", "/api/public/events"],
    createSpan: ["POST", "/api/public/spans"],
    updateSpan: ["PATCH", "/api/public/spans"],
    createGeneration: ["POST", "/api/public/generations"],
    updateGeneration: ["PATCH", "/api/public/generations"],
    createScore: ["POST", "/api/public/scores"],
};

function assert(truthyValue, message) {
    if (!truthyValue) {
        throw new Error(message);
    }
}
function removeTrailingSlash(url) {
    return url === null || url === void 0 ? void 0 : url.replace(/\/+$/, "");
}
function retriable(fn, props, log) {
    if (props === void 0) { props = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, retryCount, _b, retryDelay, _c, retryCheck, lastError, i, res, e_1;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = props.retryCount, retryCount = _a === void 0 ? 3 : _a, _b = props.retryDelay, retryDelay = _b === void 0 ? 5000 : _b, _c = props.retryCheck, retryCheck = _c === void 0 ? function () { return true; } : _c;
                    lastError = null;
                    i = 0;
                    _d.label = 1;
                case 1:
                    if (!(i < retryCount + 1)) return [3 /*break*/, 7];
                    if (!(i > 0)) return [3 /*break*/, 3];
                    // don't wait when it's the first try
                    return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, retryDelay); })];
                case 2:
                    // don't wait when it's the first try
                    _d.sent();
                    log("Retrying ".concat(i + 1, " of ").concat(retryCount + 1));
                    _d.label = 3;
                case 3:
                    _d.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, fn()];
                case 4:
                    res = _d.sent();
                    return [2 /*return*/, res];
                case 5:
                    e_1 = _d.sent();
                    lastError = e_1;
                    if (!retryCheck(e_1)) {
                        throw e_1;
                    }
                    log("Retriable error: ".concat(JSON.stringify(e_1)));
                    return [3 /*break*/, 6];
                case 6:
                    i++;
                    return [3 /*break*/, 1];
                case 7: throw lastError;
            }
        });
    });
}
// https://stackoverflow.com/a/8809472
function generateUUID(globalThis) {
    // Public Domain/MIT
    var d = new Date().getTime(); //Timestamp
    var d2 = (globalThis && globalThis.performance && globalThis.performance.now && globalThis.performance.now() * 1000) || 0; //Time in microseconds since page-load or 0 if unsupported
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = Math.random() * 16; //random number between 0 and 16
        if (d > 0) {
            //Use timestamp until depleted
            r = (d + r) % 16 | 0;
            d = Math.floor(d / 16);
        }
        else {
            //Use microseconds since page-load if supported
            r = (d2 + r) % 16 | 0;
            d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
}
function safeSetTimeout(fn, timeout) {
    // NOTE: we use this so rarely that it is totally fine to do `safeSetTimeout(fn, 0)``
    // rather than setImmediate.
    var t = setTimeout(fn, timeout);
    // We unref if available to prevent Node.js hanging on exit
    (t === null || t === void 0 ? void 0 : t.unref) && (t === null || t === void 0 ? void 0 : t.unref());
    return t;
}
function getEnv(key) {
    if (typeof process !== "undefined" && process.env[key]) {
        return process.env[key];
    }
    else if (typeof globalThis !== "undefined") {
        return globalThis[key];
    }
    return;
}

var SimpleEventEmitter = /** @class */ (function () {
    function SimpleEventEmitter() {
        this.events = {};
        this.events = {};
    }
    SimpleEventEmitter.prototype.on = function (event, listener) {
        var _this = this;
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
        return function () {
            _this.events[event] = _this.events[event].filter(function (x) { return x !== listener; });
        };
    };
    SimpleEventEmitter.prototype.emit = function (event, payload) {
        for (var _i = 0, _a = this.events[event] || []; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener(payload);
        }
        for (var _b = 0, _c = this.events["*"] || []; _b < _c.length; _b++) {
            var listener = _c[_b];
            listener(event, payload);
        }
    };
    return SimpleEventEmitter;
}());

var common_release_envs = [
    // Vercel
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    // Netlify
    "COMMIT_REF",
    // Render
    "RENDER_GIT_COMMIT",
    // GitLab CI
    "CI_COMMIT_SHA",
    // CicleCI
    "CIRCLE_SHA1",
    // Cloudflare pages
    "CF_PAGES_COMMIT_SHA",
    // AWS Amplify
    "REACT_APP_GIT_SHA",
    // Heroku
    "SOURCE_VERSION",
];
function getCommonReleaseEnvs() {
    for (var _i = 0, common_release_envs_1 = common_release_envs; _i < common_release_envs_1.length; _i++) {
        var env = common_release_envs_1[_i];
        if (process.env[env]) {
            return process.env[env];
        }
    }
    return undefined;
}

var LangfuseFetchHttpError = /** @class */ (function (_super) {
    __extends(LangfuseFetchHttpError, _super);
    function LangfuseFetchHttpError(response) {
        var _this = _super.call(this, "HTTP error while fetching Langfuse: " + response.status) || this;
        _this.response = response;
        _this.name = "LangfuseFetchHttpError";
        return _this;
    }
    return LangfuseFetchHttpError;
}(Error));
var LangfuseFetchNetworkError = /** @class */ (function (_super) {
    __extends(LangfuseFetchNetworkError, _super);
    function LangfuseFetchNetworkError(error) {
        var _this = _super.call(this, "Network error while fetching Langfuse", error instanceof Error ? { cause: error } : {}) || this;
        _this.error = error;
        _this.name = "LangfuseFetchNetworkError";
        return _this;
    }
    return LangfuseFetchNetworkError;
}(Error));
function isLangfuseFetchError(err) {
    return typeof err === "object" && (err.name === "LangfuseFetchHttpError" || err.name === "LangfuseFetchNetworkError");
}
var LangfuseCoreStateless = /** @class */ (function () {
    function LangfuseCoreStateless(params) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.debugMode = false;
        this.pendingPromises = {};
        // internal
        this._events = new SimpleEventEmitter();
        var publicKey = params.publicKey, secretKey = params.secretKey, options = __rest(params, ["publicKey", "secretKey"]);
        assert(publicKey, "You must pass your Langfuse project's api public key.");
        this.publicKey = publicKey;
        this.secretKey = secretKey;
        this.baseUrl = removeTrailingSlash((options === null || options === void 0 ? void 0 : options.baseUrl) || "https://cloud.langfuse.com");
        this.flushAt = (options === null || options === void 0 ? void 0 : options.flushAt) ? Math.max(options === null || options === void 0 ? void 0 : options.flushAt, 1) : 1;
        this.flushInterval = (_a = options === null || options === void 0 ? void 0 : options.flushInterval) !== null && _a !== void 0 ? _a : 10000;
        this.release = (_d = (_c = (_b = options === null || options === void 0 ? void 0 : options.release) !== null && _b !== void 0 ? _b : getEnv("LANGFUSE_RELEASE")) !== null && _c !== void 0 ? _c : getCommonReleaseEnvs()) !== null && _d !== void 0 ? _d : undefined;
        this._retryOptions = {
            retryCount: (_e = options === null || options === void 0 ? void 0 : options.fetchRetryCount) !== null && _e !== void 0 ? _e : 3,
            retryDelay: (_f = options === null || options === void 0 ? void 0 : options.fetchRetryDelay) !== null && _f !== void 0 ? _f : 3000,
            retryCheck: isLangfuseFetchError,
        };
        this.requestTimeout = (_g = options === null || options === void 0 ? void 0 : options.requestTimeout) !== null && _g !== void 0 ? _g : 10000; // 10 seconds
    }
    LangfuseCoreStateless.prototype.getCommonEventProperties = function () {
        return {
            $lib: this.getLibraryId(),
            $lib_version: this.getLibraryVersion(),
        };
    };
    LangfuseCoreStateless.prototype.on = function (event, cb) {
        return this._events.on(event, cb);
    };
    LangfuseCoreStateless.prototype.debug = function (enabled) {
        var _a;
        if (enabled === void 0) { enabled = true; }
        (_a = this.removeDebugCallback) === null || _a === void 0 ? void 0 : _a.call(this);
        this.debugMode = enabled;
        if (enabled) {
            this.removeDebugCallback = this.on("*", function (event, payload) { return console.log("Langfuse Debug", event, payload); });
        }
    };
    /***
     *** Handlers for each object type
     ***/
    LangfuseCoreStateless.prototype.traceStateless = function (body) {
        var bodyId = body.id, bodyRelease = body.release, rest = __rest(body, ["id", "release"]);
        var id = bodyId !== null && bodyId !== void 0 ? bodyId : generateUUID();
        var release = bodyRelease !== null && bodyRelease !== void 0 ? bodyRelease : this.release;
        var parsedBody = __assign({ id: id, release: release }, rest);
        this.enqueue("createTrace", parsedBody);
        return id;
    };
    LangfuseCoreStateless.prototype.eventStateless = function (body) {
        var bodyId = body.id, bodyStartTime = body.startTime, rest = __rest(body, ["id", "startTime"]);
        var id = bodyId !== null && bodyId !== void 0 ? bodyId : generateUUID();
        var parsedBody = __assign({ id: id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createEvent", parsedBody);
        return id;
    };
    LangfuseCoreStateless.prototype.spanStateless = function (body) {
        var bodyId = body.id, bodyStartTime = body.startTime, rest = __rest(body, ["id", "startTime"]);
        var id = bodyId || generateUUID();
        var parsedBody = __assign({ id: id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createSpan", parsedBody);
        return id;
    };
    LangfuseCoreStateless.prototype.generationStateless = function (body) {
        var bodyId = body.id, bodyStartTime = body.startTime, rest = __rest(body, ["id", "startTime"]);
        var id = bodyId || generateUUID();
        var parsedBody = __assign({ id: id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createGeneration", parsedBody);
        return id;
    };
    LangfuseCoreStateless.prototype.scoreStateless = function (body) {
        var bodyId = body.id, rest = __rest(body, ["id"]);
        var id = bodyId || generateUUID();
        var parsedBody = __assign({ id: id }, rest);
        this.enqueue("createScore", parsedBody);
        return id;
    };
    LangfuseCoreStateless.prototype.updateSpanStateless = function (body) {
        this.enqueue("updateSpan", body);
        return body.spanId;
    };
    LangfuseCoreStateless.prototype.updateGenerationStateless = function (body) {
        this.enqueue("updateGeneration", body);
        return body.generationId;
    };
    LangfuseCoreStateless.prototype._getDataset = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/datasets/").concat(name), this.getFetchOptions({ method: "GET" })).then(function (res) { return res.json(); })];
            });
        });
    };
    LangfuseCoreStateless.prototype.getDatasetRun = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/datasets/").concat(params.datasetName, "/runs/").concat(params.runName), this.getFetchOptions({ method: "GET" })).then(function (res) { return res.json(); })];
            });
        });
    };
    LangfuseCoreStateless.prototype.createDatasetRunItem = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/dataset-run-items"), this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then(function (res) { return res.json(); })];
            });
        });
    };
    LangfuseCoreStateless.prototype.createDataset = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var body;
            return __generator(this, function (_a) {
                body = { name: name };
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/datasets"), this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then(function (res) { return res.json(); })];
            });
        });
    };
    /**
     * Creates a dataset item. Upserts the item if it already exists.
     * @param body The body of the dataset item to be created.
     * @returns A promise that resolves to the response of the create operation.
     */
    LangfuseCoreStateless.prototype.createDatasetItem = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/dataset-items"), this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then(function (res) { return res.json(); })];
            });
        });
    };
    LangfuseCoreStateless.prototype.getDatasetItem = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.fetch("".concat(this.baseUrl, "/api/public/dataset-items/").concat(id), this.getFetchOptions({ method: "GET" })).then(function (res) { return res.json(); })];
            });
        });
    };
    LangfuseCoreStateless.prototype._parsePayload = function (response) {
        try {
            return JSON.parse(response);
        }
        catch (_a) {
            return response;
        }
    };
    /***
     *** QUEUEING AND FLUSHING
     ***/
    LangfuseCoreStateless.prototype.enqueue = function (type, body) {
        var _this = this;
        var queue = this.getPersistedProperty(LangfusePersistedProperty.Queue) || [];
        var id = generateUUID();
        queue.push({
            id: id,
            method: LangfusePostApiRoutes[type][0],
            apiRoute: LangfusePostApiRoutes[type][1],
            body: body,
        });
        this.setPersistedProperty(LangfusePersistedProperty.Queue, queue);
        this._events.emit(type, body);
        // Flush queued events if we meet the flushAt length
        if (queue.length >= this.flushAt) {
            this.flush();
        }
        if (this.flushInterval && !this._flushTimer) {
            this._flushTimer = safeSetTimeout(function () { return _this.flush(); }, this.flushInterval);
        }
    };
    LangfuseCoreStateless.prototype.flushAsync = function () {
        return Promise.all(this.flush());
    };
    // Flushes all events that are not yet sent to the server
    // @returns {Promise[]} - list of promises for each item in the queue that is flushed
    LangfuseCoreStateless.prototype.flush = function () {
        var _this = this;
        if (this._flushTimer) {
            clearTimeout(this._flushTimer);
            this._flushTimer = null;
        }
        var queue = this.getPersistedProperty(LangfusePersistedProperty.Queue) || [];
        if (!queue.length) {
            return [];
        }
        // Flush all items in queue, could also use flushAt with splice to flush only a certain number of items (e.g. when batching)
        var items = queue;
        this.setPersistedProperty(LangfusePersistedProperty.Queue, []);
        // TODO: add /batch endpoint to ingest multiple events at once
        var promises = items.map(function (item) {
            var done = function (err) {
                if (err) {
                    _this._events.emit("error", err);
                }
                // remove promise from pendingPromises
                delete _this.pendingPromises[item.id];
                _this._events.emit("flush", item);
            };
            var payload = JSON.stringify(item.body); // implicit conversion also of dates to strings
            var url = "".concat(_this.baseUrl).concat(item.apiRoute);
            var fetchOptions = _this.getFetchOptions({
                method: item.method,
                body: payload,
            });
            var requestPromise = _this.fetchWithRetry(url, fetchOptions);
            _this.pendingPromises[item.id] = requestPromise;
            requestPromise
                .then(function () { return done(); })
                .catch(function (err) {
                done(err);
            });
            return requestPromise;
        });
        return promises;
    };
    LangfuseCoreStateless.prototype.getFetchOptions = function (p) {
        var fetchOptions = {
            method: p.method,
            headers: __assign({ "Content-Type": "application/json", "X-Langfuse-Sdk-Name": "langfuse-js", "X-Langfuse-Sdk-Version": this.getLibraryVersion(), "X-Langfuse-Sdk-Variant": this.getLibraryId(), "X-Langfuse-Public-Key": this.publicKey }, this.constructAuthorizationHeader(this.publicKey, this.secretKey)),
            body: p.body,
        };
        return fetchOptions;
    };
    LangfuseCoreStateless.prototype.constructAuthorizationHeader = function (publicKey, secretKey) {
        if (secretKey === undefined) {
            return { Authorization: "Bearer " + publicKey };
        }
        else {
            var encodedCredentials = typeof btoa === "function"
                ? // btoa() is available, the code is running in a browser or edge environment
                    btoa(publicKey + ":" + secretKey)
                : // btoa() is not available, the code is running in Node.js
                    Buffer.from(publicKey + ":" + secretKey).toString("base64");
            return { Authorization: "Basic " + encodedCredentials };
        }
    };
    LangfuseCoreStateless.prototype.fetchWithRetry = function (url, options, retryOptions) {
        var _a;
        var _b;
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        (_a = (_b = AbortSignal).timeout) !== null && _a !== void 0 ? _a : (_b.timeout = function timeout(ms) {
                            var ctrl = new AbortController();
                            setTimeout(function () { return ctrl.abort(); }, ms);
                            return ctrl.signal;
                        });
                        return [4 /*yield*/, retriable(function () { return __awaiter(_this, void 0, void 0, function () {
                                var res, e_1;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            res = null;
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, this.fetch(url, __assign({ signal: AbortSignal.timeout(this.requestTimeout) }, options))];
                                        case 2:
                                            res = _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            e_1 = _a.sent();
                                            // fetch will only throw on network errors or on timeouts
                                            throw new LangfuseFetchNetworkError(e_1);
                                        case 4:
                                            if (res.status < 200 || res.status >= 400) {
                                                throw new LangfuseFetchHttpError(res);
                                            }
                                            return [2 /*return*/, res];
                                    }
                                });
                            }); }, __assign(__assign({}, this._retryOptions), retryOptions), function (string) { return _this._events.emit("retry", string + ", " + url + ", " + JSON.stringify(options)); })];
                    case 1: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    LangfuseCoreStateless.prototype.shutdownAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        clearTimeout(this._flushTimer);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, this.flushAsync()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, Promise.all(Object.values(this.pendingPromises).map(function (x) {
                                return x.catch(function () {
                                    // ignore errors as we are shutting down and can't deal with them anyways.
                                });
                            }))];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _a.sent();
                        if (!isLangfuseFetchError(e_2)) {
                            throw e_2;
                        }
                        console.error("Error while shutting down Langfuse", e_2);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    LangfuseCoreStateless.prototype.shutdown = function () {
        void this.shutdownAsync();
    };
    LangfuseCoreStateless.prototype.awaitAllQueuedAndPendingRequests = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        clearTimeout(this._flushTimer);
                        return [4 /*yield*/, this.flushAsync()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, Promise.all(Object.values(this.pendingPromises))];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return LangfuseCoreStateless;
}());
var LangfuseWebStateless = /** @class */ (function (_super) {
    __extends(LangfuseWebStateless, _super);
    function LangfuseWebStateless(params) {
        var flushAt = params.flushAt, flushInterval = params.flushInterval, rest = __rest(params, ["flushAt", "flushInterval"]);
        return _super.call(this, __assign(__assign({}, rest), { flushAt: flushAt !== null && flushAt !== void 0 ? flushAt : 1, flushInterval: flushInterval !== null && flushInterval !== void 0 ? flushInterval : 0 })) || this;
    }
    LangfuseWebStateless.prototype.score = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.scoreStateless(body);
                        return [4 /*yield*/, this.awaitAllQueuedAndPendingRequests()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    return LangfuseWebStateless;
}(LangfuseCoreStateless));
var LangfuseCore = /** @class */ (function (_super) {
    __extends(LangfuseCore, _super);
    function LangfuseCore(params) {
        assert(params.publicKey, "You must pass your Langfuse project's api public key.");
        assert(params.secretKey, "You must pass your Langfuse project's api secret key.");
        return _super.call(this, params) || this;
    }
    LangfuseCore.prototype.trace = function (body) {
        var id = this.traceStateless(body !== null && body !== void 0 ? body : {});
        var t = new LangfuseTraceClient(this, id);
        if (getEnv("DEFER") && body) {
            try {
                var deferRuntime = getEnv("__deferRuntime");
                if (deferRuntime) {
                    deferRuntime.langfuseTraces([
                        {
                            id: id,
                            name: body.name || "",
                            url: t.getTraceUrl(),
                        },
                    ]);
                }
            }
            catch (_a) { }
        }
        return t;
    };
    LangfuseCore.prototype.span = function (body) {
        var traceId = body.traceId || this.traceStateless({ name: body.name });
        var id = this.spanStateless(__assign(__assign({}, body), { traceId: traceId }));
        return new LangfuseSpanClient(this, id, traceId);
    };
    LangfuseCore.prototype.generation = function (body) {
        var traceId = body.traceId || this.traceStateless({ name: body.name });
        var id = this.generationStateless(__assign(__assign({}, body), { traceId: traceId }));
        return new LangfuseGenerationClient(this, id, traceId);
    };
    LangfuseCore.prototype.event = function (body) {
        var traceId = body.traceId || this.traceStateless({ name: body.name });
        var id = this.eventStateless(__assign(__assign({}, body), { traceId: traceId }));
        return new LangfuseEventClient(this, id, traceId);
    };
    LangfuseCore.prototype.score = function (body) {
        this.scoreStateless(body);
        return this;
    };
    LangfuseCore.prototype.getDataset = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, items, dataset, returnDataset;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._getDataset(name)];
                    case 1:
                        _a = _b.sent(), items = _a.items, dataset = __rest(_a, ["items"]);
                        returnDataset = __assign(__assign({}, dataset), { items: items.map(function (item) { return (__assign(__assign({}, item), { link: function (obj, runName) { return __awaiter(_this, void 0, void 0, function () {
                                    var data;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.awaitAllQueuedAndPendingRequests()];
                                            case 1:
                                                _a.sent();
                                                return [4 /*yield*/, this.createDatasetRunItem({
                                                        runName: runName,
                                                        datasetItemId: item.id,
                                                        observationId: obj.id,
                                                    })];
                                            case 2:
                                                data = _a.sent();
                                                return [2 /*return*/, data];
                                        }
                                    });
                                }); } })); }) });
                        return [2 /*return*/, returnDataset];
                }
            });
        });
    };
    LangfuseCore.prototype._updateSpan = function (body) {
        this.updateSpanStateless(body);
        return this;
    };
    LangfuseCore.prototype._updateGeneration = function (body) {
        this.updateGenerationStateless(body);
        return this;
    };
    return LangfuseCore;
}(LangfuseCoreStateless));
var LangfuseObjectClient = /** @class */ (function () {
    function LangfuseObjectClient(_a) {
        var client = _a.client, id = _a.id, traceId = _a.traceId, observationId = _a.observationId;
        this.client = client;
        this.id = id;
        this.traceId = traceId;
        this.observationId = observationId;
    }
    LangfuseObjectClient.prototype.event = function (body) {
        return this.client.event(__assign(__assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    };
    LangfuseObjectClient.prototype.span = function (body) {
        return this.client.span(__assign(__assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    };
    LangfuseObjectClient.prototype.generation = function (body) {
        return this.client.generation(__assign(__assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    };
    LangfuseObjectClient.prototype.score = function (body) {
        this.client.score(__assign(__assign({}, body), { traceId: this.traceId, observationId: this.observationId }));
        return this;
    };
    LangfuseObjectClient.prototype.getTraceUrl = function () {
        return "".concat(this.client.baseUrl, "/trace/").concat(this.traceId);
    };
    return LangfuseObjectClient;
}());
var LangfuseTraceClient = /** @class */ (function (_super) {
    __extends(LangfuseTraceClient, _super);
    function LangfuseTraceClient(client, traceId) {
        return _super.call(this, { client: client, id: traceId, traceId: traceId, observationId: null }) || this;
    }
    LangfuseTraceClient.prototype.update = function (body) {
        this.client.trace(__assign(__assign({}, body), { id: this.id }));
        return this;
    };
    return LangfuseTraceClient;
}(LangfuseObjectClient));
var LangfuseObservationClient = /** @class */ (function (_super) {
    __extends(LangfuseObservationClient, _super);
    function LangfuseObservationClient(client, id, traceId) {
        return _super.call(this, { client: client, id: id, traceId: traceId, observationId: id }) || this;
    }
    return LangfuseObservationClient;
}(LangfuseObjectClient));
var LangfuseSpanClient = /** @class */ (function (_super) {
    __extends(LangfuseSpanClient, _super);
    function LangfuseSpanClient(client, id, traceId) {
        return _super.call(this, client, id, traceId) || this;
    }
    LangfuseSpanClient.prototype.update = function (body) {
        this.client._updateSpan(__assign(__assign({}, body), { spanId: this.id, traceId: this.traceId }));
        return this;
    };
    LangfuseSpanClient.prototype.end = function (body) {
        this.client._updateSpan(__assign(__assign({}, body), { spanId: this.id, traceId: this.traceId, endTime: new Date() }));
        return this;
    };
    return LangfuseSpanClient;
}(LangfuseObservationClient));
var LangfuseGenerationClient = /** @class */ (function (_super) {
    __extends(LangfuseGenerationClient, _super);
    function LangfuseGenerationClient(client, id, traceId) {
        return _super.call(this, client, id, traceId) || this;
    }
    LangfuseGenerationClient.prototype.update = function (body) {
        this.client._updateGeneration(__assign(__assign({}, body), { generationId: this.id, traceId: this.traceId }));
        return this;
    };
    LangfuseGenerationClient.prototype.end = function (body) {
        this.client._updateGeneration(__assign(__assign({}, body), { generationId: this.id, traceId: this.traceId, endTime: new Date() }));
        return this;
    };
    return LangfuseGenerationClient;
}(LangfuseObservationClient));
var LangfuseEventClient = /** @class */ (function (_super) {
    __extends(LangfuseEventClient, _super);
    function LangfuseEventClient(client, id, traceId) {
        return _super.call(this, client, id, traceId) || this;
    }
    return LangfuseEventClient;
}(LangfuseObservationClient));

// Methods partially borrowed from quirksmode.org/js/cookies.html
var cookieStore = {
  getItem: function (key) {
    try {
      var nameEQ = key + "=";
      var ca = document.cookie.split(";");
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == " ") {
          c = c.substring(1, c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
          return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
      }
    } catch (err) {}
    return null;
  },
  setItem: function (key, value) {
    try {
      var cdomain = "",
        expires = "",
        secure = "";
      var new_cookie_val = key + "=" + encodeURIComponent(value) + expires + "; path=/" + cdomain + secure;
      document.cookie = new_cookie_val;
    } catch (err) {
      return;
    }
  },
  removeItem: function (name) {
    try {
      cookieStore.setItem(name, "");
    } catch (err) {
      return;
    }
  },
  clear: function () {
    document.cookie = "";
  },
  getAllKeys: function () {
    var ca = document.cookie.split(";");
    var keys = [];
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1, c.length);
      }
      keys.push(c.split("=")[0]);
    }
    return keys;
  }
};
var createStorageLike = function (store) {
  return {
    getItem: function (key) {
      return store.getItem(key);
    },
    setItem: function (key, value) {
      store.setItem(key, value);
    },
    removeItem: function (key) {
      store.removeItem(key);
    },
    clear: function () {
      store.clear();
    },
    getAllKeys: function () {
      var keys = [];
      for (var key in localStorage) {
        keys.push(key);
      }
      return keys;
    }
  };
};
var checkStoreIsSupported = function (storage, key) {
  if (key === void 0) {
    key = "__mplssupport__";
  }
  if (!window) {
    return false;
  }
  try {
    var val = "xyz";
    storage.setItem(key, val);
    if (storage.getItem(key) !== val) {
      return false;
    }
    storage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
};
var localStore = undefined;
var sessionStore = undefined;
var createMemoryStorage = function () {
  var _cache = {};
  var store = {
    getItem: function (key) {
      return _cache[key];
    },
    setItem: function (key, value) {
      _cache[key] = value !== null ? value : undefined;
    },
    removeItem: function (key) {
      delete _cache[key];
    },
    clear: function () {
      for (var key in _cache) {
        delete _cache[key];
      }
    },
    getAllKeys: function () {
      var keys = [];
      for (var key in _cache) {
        keys.push(key);
      }
      return keys;
    }
  };
  return store;
};
var getStorage = function (type, window) {
  if (typeof window !== undefined && window) {
    if (!localStorage) {
      var _localStore = createStorageLike(window.localStorage);
      localStore = checkStoreIsSupported(_localStore) ? _localStore : undefined;
    }
    if (!sessionStore) {
      var _sessionStore = createStorageLike(window.sessionStorage);
      sessionStore = checkStoreIsSupported(_sessionStore) ? _sessionStore : undefined;
    }
  }
  switch (type) {
    case "cookie":
      return cookieStore || localStore || sessionStore || createMemoryStorage();
    case "localStorage":
      return localStore || sessionStore || createMemoryStorage();
    case "sessionStorage":
      return sessionStore || createMemoryStorage();
    case "memory":
      return createMemoryStorage();
    default:
      return createMemoryStorage();
  }
};

var version = "1.3.0";

var Langfuse = /** @class */function (_super) {
  __extends(Langfuse, _super);
  function Langfuse(params) {
    var _this = _super.call(this, params) || this;
    var publicKey = params.publicKey;
      params.secretKey;
      var options = __rest(params, ["publicKey", "secretKey"]);
    if (typeof window !== "undefined" && "Deno" in window === false) {
      _this._storageKey = (options === null || options === void 0 ? void 0 : options.persistence_name) ? "lf_".concat(options.persistence_name) : "lf_".concat(publicKey, "_langfuse");
      _this._storage = getStorage((options === null || options === void 0 ? void 0 : options.persistence) || "localStorage", window);
    } else {
      _this._storageKey = "lf_".concat(publicKey, "_langfuse");
      _this._storage = getStorage("memory", undefined);
    }
    return _this;
  }
  Langfuse.prototype.getPersistedProperty = function (key) {
    if (!this._storageCache) {
      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
    }
    return this._storageCache[key];
  };
  Langfuse.prototype.setPersistedProperty = function (key, value) {
    if (!this._storageCache) {
      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
    }
    if (value === null) {
      delete this._storageCache[key];
    } else {
      this._storageCache[key] = value;
    }
    this._storage.setItem(this._storageKey, JSON.stringify(this._storageCache));
  };
  Langfuse.prototype.fetch = function (url, options) {
    return fetch(url, options);
  };
  Langfuse.prototype.getLibraryId = function () {
    return "langfuse";
  };
  Langfuse.prototype.getLibraryVersion = function () {
    return version;
  };
  Langfuse.prototype.getCustomUserAgent = function () {
    return;
  };
  return Langfuse;
}(LangfuseCore);
var LangfuseWeb = /** @class */function (_super) {
  __extends(LangfuseWeb, _super);
  function LangfuseWeb(params) {
    var _this = _super.call(this, params) || this;
    var publicKey = params.publicKey,
      options = __rest(params, ["publicKey"]);
    if (typeof window !== "undefined") {
      _this._storageKey = (options === null || options === void 0 ? void 0 : options.persistence_name) ? "lf_".concat(options.persistence_name) : "lf_".concat(publicKey, "_langfuse");
      _this._storage = getStorage((options === null || options === void 0 ? void 0 : options.persistence) || "localStorage", window);
    } else {
      _this._storageKey = "lf_".concat(publicKey, "_langfuse");
      _this._storage = getStorage("memory", undefined);
    }
    return _this;
  }
  LangfuseWeb.prototype.getPersistedProperty = function (key) {
    if (!this._storageCache) {
      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
    }
    return this._storageCache[key];
  };
  LangfuseWeb.prototype.setPersistedProperty = function (key, value) {
    if (!this._storageCache) {
      this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
    }
    if (value === null) {
      delete this._storageCache[key];
    } else {
      this._storageCache[key] = value;
    }
    this._storage.setItem(this._storageKey, JSON.stringify(this._storageCache));
  };
  LangfuseWeb.prototype.fetch = function (url, options) {
    return fetch(url, options);
  };
  LangfuseWeb.prototype.getLibraryId = function () {
    return "langfuse-frontend";
  };
  LangfuseWeb.prototype.getLibraryVersion = function () {
    return version;
  };
  LangfuseWeb.prototype.getCustomUserAgent = function () {
    return;
  };
  return LangfuseWeb;
}(LangfuseWebStateless);

exports.Langfuse = Langfuse;
exports.LangfuseWeb = LangfuseWeb;
exports.default = Langfuse;
//# sourceMappingURL=index.cjs.js.map
