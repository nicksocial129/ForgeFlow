"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractVectorIndexClient = void 0;
class AbstractVectorIndexClient {
    constructor(controlClient, dataClient) {
        this.controlClient = controlClient;
        this.dataClient = dataClient;
    }
    /**
     * Creates a vector index if it does not exist.
     *
     * Remark on the choice of similarity metric:
     * - Cosine similarity is appropriate for most embedding models as they tend to be optimized
     *     for this metric.
     * - If the vectors are unit normalized, cosine similarity is equivalent to inner product.
     *     If your vectors are already unit normalized, you can use inner product to improve
     *     performance.
     * - Euclidean similarity, the sum of squared differences, is appropriate for datasets where
     *     this metric is meaningful. For example, if the vectors represent images, and the
     *     embedding model is trained to optimize the euclidean distance between images, then
     *     euclidean similarity is appropriate.
     *
     * @param {string} indexName - The vector index to be created.
     * @param {number} numDimensions - Number of dimensions per vector.
     * @param {VectorSimilarityMetric} similarityMetric - The metric used to
     * quantify the distance between vectors. Can be cosine similarity,
     * inner product, or euclidean similarity. Defaults to cosine similarity.
     * @returns {Promise<CreateVectorIndex.Response>} -
     * {@link CreateVectorIndex.Success} on success.
     * {@link CreateVectorIndex.AlreadyExists} if the cache already exists.
     * {@link CreateVectorIndex.Error} on failure.
     */
    async createIndex(indexName, numDimensions, similarityMetric) {
        return await this.controlClient.createIndex(indexName, numDimensions, similarityMetric);
    }
    /**
     * Lists all vector indexes.
     *
     * @returns {Promise<ListVectorIndexes.Response>} -
     * {@link ListVectorIndexes.Success} containing the list on success.
     * {@link ListVectorIndexes.Error} on error.
     */
    async listIndexes() {
        return await this.controlClient.listIndexes();
    }
    /**
     * Deletes a vector index and all the vectors stored in it.
     *
     * @param {string} indexName - The name of the vector index to delete.
     * @returns {Promise<DeleteVectorIndex.Response>} -
     * {@link DeleteVectorIndex.Success} on success.
     * {@link DeleteVectorIndex.Error} on error.
     */
    async deleteIndex(indexName) {
        return await this.controlClient.deleteIndex(indexName);
    }
    /**
     * Counts the number of items in a vector index.
     *
     * Note that if the index does not exist, an error with
     * {@link MomentoErrorCode} `NOT_FOUND` error will be returned.
     *
     * @param indexName - Name of the index to count the items in.
     * @returns {Promise<VectorCountItems.Response>} -
     * {@link VectorCountItems.Success} on success.
     * {@link VectorCountItems.Error} on error.
     */
    async countItems(indexName) {
        return await this.dataClient.countItems(indexName);
    }
    /**
     * Upserts a batch of items into a vector index.
     *
     * If an item with the same ID already exists in the index, it will be replaced.
     * Otherwise, it will be added to the index.
     *
     * @param {string} indexName - Name of the index to upsert the items into.
     * @param {Array<VectorIndexItem>} items - The items to be upserted into the index.
     * @returns {Promise<VectorUpsertItemBatch.Response>} -
     * {@link VectorUpsertItemBatch.Success} on success.
     * {@link VectorUpsertItemBatch.Error} on error.
     */
    async upsertItemBatch(indexName, items) {
        return await this.dataClient.upsertItemBatch(indexName, items);
    }
    /**
     * Searches for the most similar vectors to the query vector in the index.
     *
     * Ranks the vectors according to the similarity metric specified when the
     * index was created.
     *
     * @param {string} indexName - Name of the index to search in.
     * @param {Array<number>} queryVector - The vector to search for.
     * @param {SearchOptions} options - Optional search arguments, including
     * the number of results to return, metadata fields to return, and a score
     * threshold to filter results by.
     * @returns {Promise<VectorSearch.Response>} -
     * {@link VectorSearch.Success} on success.
     * {@link VectorSearch.Error} on error.
     */
    async search(indexName, queryVector, options) {
        return await this.dataClient.search(indexName, queryVector, options);
    }
    /**
     * Searches for the most similar vectors to the query vector in the index.
     *
     * Ranks the vectors according to the similarity metric specified when the
     * index was created.
     * Also returns the vectors associated with each result.
     *
     * @param indexName - Name of the index to search in.
     * @param queryVector - The vector to search for.
     * @param options - Optional search arguments, including
     * the number of results to return, metadata fields to return, and a score
     * threshold to filter results by.
     * @returns {Promise<VectorSearchAndFetchVectors.Response>} -
     * {@link VectorSearchAndFetchVectors.Success} on success.
     * {@link VectorSearchAndFetchVectors.Error} on error.
     */
    async searchAndFetchVectors(indexName, queryVector, options) {
        return await this.dataClient.searchAndFetchVectors(indexName, queryVector, options);
    }
    /**
     * Deletes a batch of items from a vector index.
     * Deletes any and all items with the given IDs from the index.
     *
     * @param {string} indexName - Name of the index to delete the items from.
     * @param {Array<string>} ids - The IDs of the items to be deleted from the index.
     * @returns {Promise<VectorDeleteItemBatch.Response>}
     * {@link VectorDeleteItemBatch.Success} on success.
     * {@link VectorDeleteItemBatch.Error} on error.
     */
    async deleteItemBatch(indexName, ids) {
        return await this.dataClient.deleteItemBatch(indexName, ids);
    }
    /**
     * Gets a batch of items from a vector index by ID.
     *
     * @param indexName - Name of the index to get the items from.
     * @param ids - The IDs of the items to be retrieved from the index.
     * @returns {Promise<VectorGetItemBatch.Response>}
     * {@link VectorGetItemBatch.Success} on success, with the found items.
     * {@link VectorGetItemBatch.Error} on error.
     */
    async getItemBatch(indexName, ids) {
        return await this.dataClient.getItemBatch(indexName, ids);
    }
    /**
     * Gets metadata for a batch of items from a vector index by ID.
     *
     * @param indexName - Name of the index to get the items from.
     * @param ids - The IDs of the items to be retrieved from the index.
     * @returns {Promise<VectorGetItemMetadataBatch.Response>}
     * {@link VectorGetItemMetadataBatch.Success} on success, with the found item metadata.
     * {@link VectorGetItemMetadataBatch.Error} on error.
     */
    async getItemMetadataBatch(indexName, ids) {
        return await this.dataClient.getItemMetadataBatch(indexName, ids);
    }
}
exports.AbstractVectorIndexClient = AbstractVectorIndexClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RWZWN0b3JJbmRleENsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL3ZlY3Rvci9BYnN0cmFjdFZlY3RvckluZGV4Q2xpZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQXVCQSxNQUFzQix5QkFBeUI7SUFNN0MsWUFDRSxhQUF3QyxFQUN4QyxVQUFrQztRQUVsQyxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJHO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FDdEIsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsZ0JBQXlDO1FBRXpDLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FDekMsU0FBUyxFQUNULGFBQWEsRUFDYixnQkFBZ0IsQ0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsV0FBVztRQUN0QixPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCO1FBRWpCLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQ3JCLFNBQWlCO1FBRWpCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUMxQixTQUFpQixFQUNqQixLQUE2QjtRQUU3QixPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNJLEtBQUssQ0FBQyxNQUFNLENBQ2pCLFNBQWlCLEVBQ2pCLFdBQTBCLEVBQzFCLE9BQXVCO1FBRXZCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMscUJBQXFCLENBQ2hDLFNBQWlCLEVBQ2pCLFdBQXFCLEVBQ3JCLE9BQW1DO1FBRW5DLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUNoRCxTQUFTLEVBQ1QsV0FBVyxFQUNYLE9BQU8sQ0FDUixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxlQUFlLENBQzFCLFNBQWlCLEVBQ2pCLEdBQWtCO1FBRWxCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLFlBQVksQ0FDdkIsU0FBaUIsRUFDakIsR0FBYTtRQUViLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLG9CQUFvQixDQUMvQixTQUFpQixFQUNqQixHQUFhO1FBRWIsT0FBTyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7Q0FDRjtBQWxORCw4REFrTkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDcmVhdGVWZWN0b3JJbmRleCxcbiAgRGVsZXRlVmVjdG9ySW5kZXgsXG4gIExpc3RWZWN0b3JJbmRleGVzLFxuICBWZWN0b3JDb3VudEl0ZW1zLFxuICBWZWN0b3JVcHNlcnRJdGVtQmF0Y2gsXG4gIFZlY3RvclNlYXJjaCxcbiAgVmVjdG9yU2VhcmNoQW5kRmV0Y2hWZWN0b3JzLFxuICBWZWN0b3JEZWxldGVJdGVtQmF0Y2gsXG4gIFZlY3RvckdldEl0ZW1CYXRjaCxcbiAgVmVjdG9yR2V0SXRlbU1ldGFkYXRhQmF0Y2gsXG59IGZyb20gJy4uLy4uLy4uJztcbmltcG9ydCB7XG4gIElWZWN0b3JJbmRleENsaWVudCxcbiAgU2VhcmNoT3B0aW9ucyxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50cy9JVmVjdG9ySW5kZXhDbGllbnQnO1xuaW1wb3J0IHtcbiAgSVZlY3RvckluZGV4Q29udHJvbENsaWVudCxcbiAgVmVjdG9yU2ltaWxhcml0eU1ldHJpYyxcbn0gZnJvbSAnLi9JVmVjdG9ySW5kZXhDb250cm9sQ2xpZW50JztcbmltcG9ydCB7VmVjdG9ySW5kZXhJdGVtfSBmcm9tICcuLi8uLi8uLi9tZXNzYWdlcy92ZWN0b3ItaW5kZXgnO1xuaW1wb3J0IHtJVmVjdG9ySW5kZXhEYXRhQ2xpZW50fSBmcm9tICcuL0lWZWN0b3JJbmRleERhdGFDbGllbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RWZWN0b3JJbmRleENsaWVudFxuICBpbXBsZW1lbnRzIElWZWN0b3JJbmRleENsaWVudCwgSVZlY3RvckluZGV4RGF0YUNsaWVudFxue1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29udHJvbENsaWVudDogSVZlY3RvckluZGV4Q29udHJvbENsaWVudDtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFDbGllbnQ6IElWZWN0b3JJbmRleERhdGFDbGllbnQ7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRyb2xDbGllbnQ6IElWZWN0b3JJbmRleENvbnRyb2xDbGllbnQsXG4gICAgZGF0YUNsaWVudDogSVZlY3RvckluZGV4RGF0YUNsaWVudFxuICApIHtcbiAgICB0aGlzLmNvbnRyb2xDbGllbnQgPSBjb250cm9sQ2xpZW50O1xuICAgIHRoaXMuZGF0YUNsaWVudCA9IGRhdGFDbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHZlY3RvciBpbmRleCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogUmVtYXJrIG9uIHRoZSBjaG9pY2Ugb2Ygc2ltaWxhcml0eSBtZXRyaWM6XG4gICAqIC0gQ29zaW5lIHNpbWlsYXJpdHkgaXMgYXBwcm9wcmlhdGUgZm9yIG1vc3QgZW1iZWRkaW5nIG1vZGVscyBhcyB0aGV5IHRlbmQgdG8gYmUgb3B0aW1pemVkXG4gICAqICAgICBmb3IgdGhpcyBtZXRyaWMuXG4gICAqIC0gSWYgdGhlIHZlY3RvcnMgYXJlIHVuaXQgbm9ybWFsaXplZCwgY29zaW5lIHNpbWlsYXJpdHkgaXMgZXF1aXZhbGVudCB0byBpbm5lciBwcm9kdWN0LlxuICAgKiAgICAgSWYgeW91ciB2ZWN0b3JzIGFyZSBhbHJlYWR5IHVuaXQgbm9ybWFsaXplZCwgeW91IGNhbiB1c2UgaW5uZXIgcHJvZHVjdCB0byBpbXByb3ZlXG4gICAqICAgICBwZXJmb3JtYW5jZS5cbiAgICogLSBFdWNsaWRlYW4gc2ltaWxhcml0eSwgdGhlIHN1bSBvZiBzcXVhcmVkIGRpZmZlcmVuY2VzLCBpcyBhcHByb3ByaWF0ZSBmb3IgZGF0YXNldHMgd2hlcmVcbiAgICogICAgIHRoaXMgbWV0cmljIGlzIG1lYW5pbmdmdWwuIEZvciBleGFtcGxlLCBpZiB0aGUgdmVjdG9ycyByZXByZXNlbnQgaW1hZ2VzLCBhbmQgdGhlXG4gICAqICAgICBlbWJlZGRpbmcgbW9kZWwgaXMgdHJhaW5lZCB0byBvcHRpbWl6ZSB0aGUgZXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gaW1hZ2VzLCB0aGVuXG4gICAqICAgICBldWNsaWRlYW4gc2ltaWxhcml0eSBpcyBhcHByb3ByaWF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4TmFtZSAtIFRoZSB2ZWN0b3IgaW5kZXggdG8gYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bURpbWVuc2lvbnMgLSBOdW1iZXIgb2YgZGltZW5zaW9ucyBwZXIgdmVjdG9yLlxuICAgKiBAcGFyYW0ge1ZlY3RvclNpbWlsYXJpdHlNZXRyaWN9IHNpbWlsYXJpdHlNZXRyaWMgLSBUaGUgbWV0cmljIHVzZWQgdG9cbiAgICogcXVhbnRpZnkgdGhlIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9ycy4gQ2FuIGJlIGNvc2luZSBzaW1pbGFyaXR5LFxuICAgKiBpbm5lciBwcm9kdWN0LCBvciBldWNsaWRlYW4gc2ltaWxhcml0eS4gRGVmYXVsdHMgdG8gY29zaW5lIHNpbWlsYXJpdHkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENyZWF0ZVZlY3RvckluZGV4LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ3JlYXRlVmVjdG9ySW5kZXguU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENyZWF0ZVZlY3RvckluZGV4LkFscmVhZHlFeGlzdHN9IGlmIHRoZSBjYWNoZSBhbHJlYWR5IGV4aXN0cy5cbiAgICoge0BsaW5rIENyZWF0ZVZlY3RvckluZGV4LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUluZGV4KFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIG51bURpbWVuc2lvbnM6IG51bWJlcixcbiAgICBzaW1pbGFyaXR5TWV0cmljPzogVmVjdG9yU2ltaWxhcml0eU1ldHJpY1xuICApOiBQcm9taXNlPENyZWF0ZVZlY3RvckluZGV4LlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5jcmVhdGVJbmRleChcbiAgICAgIGluZGV4TmFtZSxcbiAgICAgIG51bURpbWVuc2lvbnMsXG4gICAgICBzaW1pbGFyaXR5TWV0cmljXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgdmVjdG9yIGluZGV4ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RWZWN0b3JJbmRleGVzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgTGlzdFZlY3RvckluZGV4ZXMuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgTGlzdFZlY3RvckluZGV4ZXMuRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RJbmRleGVzKCk6IFByb21pc2U8TGlzdFZlY3RvckluZGV4ZXMuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50Lmxpc3RJbmRleGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIHZlY3RvciBpbmRleCBhbmQgYWxsIHRoZSB2ZWN0b3JzIHN0b3JlZCBpbiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZWN0b3IgaW5kZXggdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVWZWN0b3JJbmRleC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIERlbGV0ZVZlY3RvckluZGV4LlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBEZWxldGVWZWN0b3JJbmRleC5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlSW5kZXgoXG4gICAgaW5kZXhOYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxEZWxldGVWZWN0b3JJbmRleC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQuZGVsZXRlSW5kZXgoaW5kZXhOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBpdGVtcyBpbiBhIHZlY3RvciBpbmRleC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHRoZSBpbmRleCBkb2VzIG5vdCBleGlzdCwgYW4gZXJyb3Igd2l0aFxuICAgKiB7QGxpbmsgTW9tZW50b0Vycm9yQ29kZX0gYE5PVF9GT1VORGAgZXJyb3Igd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGNvdW50IHRoZSBpdGVtcyBpbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yQ291bnRJdGVtcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIFZlY3RvckNvdW50SXRlbXMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIFZlY3RvckNvdW50SXRlbXMuRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvdW50SXRlbXMoXG4gICAgaW5kZXhOYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxWZWN0b3JDb3VudEl0ZW1zLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5jb3VudEl0ZW1zKGluZGV4TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVXBzZXJ0cyBhIGJhdGNoIG9mIGl0ZW1zIGludG8gYSB2ZWN0b3IgaW5kZXguXG4gICAqXG4gICAqIElmIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBJRCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgaW5kZXgsIGl0IHdpbGwgYmUgcmVwbGFjZWQuXG4gICAqIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byB1cHNlcnQgdGhlIGl0ZW1zIGludG8uXG4gICAqIEBwYXJhbSB7QXJyYXk8VmVjdG9ySW5kZXhJdGVtPn0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYmUgdXBzZXJ0ZWQgaW50byB0aGUgaW5kZXguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZlY3RvclVwc2VydEl0ZW1CYXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIFZlY3RvclVwc2VydEl0ZW1CYXRjaC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgVmVjdG9yVXBzZXJ0SXRlbUJhdGNoLkVycm9yfSBvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cHNlcnRJdGVtQmF0Y2goXG4gICAgaW5kZXhOYW1lOiBzdHJpbmcsXG4gICAgaXRlbXM6IEFycmF5PFZlY3RvckluZGV4SXRlbT5cbiAgKTogUHJvbWlzZTxWZWN0b3JVcHNlcnRJdGVtQmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LnVwc2VydEl0ZW1CYXRjaChpbmRleE5hbWUsIGl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgdGhlIG1vc3Qgc2ltaWxhciB2ZWN0b3JzIHRvIHRoZSBxdWVyeSB2ZWN0b3IgaW4gdGhlIGluZGV4LlxuICAgKlxuICAgKiBSYW5rcyB0aGUgdmVjdG9ycyBhY2NvcmRpbmcgdG8gdGhlIHNpbWlsYXJpdHkgbWV0cmljIHNwZWNpZmllZCB3aGVuIHRoZVxuICAgKiBpbmRleCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHNlYXJjaCBpbi5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxdWVyeVZlY3RvciAtIFRoZSB2ZWN0b3IgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtTZWFyY2hPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9uYWwgc2VhcmNoIGFyZ3VtZW50cywgaW5jbHVkaW5nXG4gICAqIHRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4sIG1ldGFkYXRhIGZpZWxkcyB0byByZXR1cm4sIGFuZCBhIHNjb3JlXG4gICAqIHRocmVzaG9sZCB0byBmaWx0ZXIgcmVzdWx0cyBieS5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yU2VhcmNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgVmVjdG9yU2VhcmNoLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBWZWN0b3JTZWFyY2guRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlYXJjaChcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBxdWVyeVZlY3RvcjogQXJyYXk8bnVtYmVyPixcbiAgICBvcHRpb25zPzogU2VhcmNoT3B0aW9uc1xuICApOiBQcm9taXNlPFZlY3RvclNlYXJjaC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQuc2VhcmNoKGluZGV4TmFtZSwgcXVlcnlWZWN0b3IsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciB0aGUgbW9zdCBzaW1pbGFyIHZlY3RvcnMgdG8gdGhlIHF1ZXJ5IHZlY3RvciBpbiB0aGUgaW5kZXguXG4gICAqXG4gICAqIFJhbmtzIHRoZSB2ZWN0b3JzIGFjY29yZGluZyB0byB0aGUgc2ltaWxhcml0eSBtZXRyaWMgc3BlY2lmaWVkIHdoZW4gdGhlXG4gICAqIGluZGV4IHdhcyBjcmVhdGVkLlxuICAgKiBBbHNvIHJldHVybnMgdGhlIHZlY3RvcnMgYXNzb2NpYXRlZCB3aXRoIGVhY2ggcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gc2VhcmNoIGluLlxuICAgKiBAcGFyYW0gcXVlcnlWZWN0b3IgLSBUaGUgdmVjdG9yIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2VhcmNoIGFyZ3VtZW50cywgaW5jbHVkaW5nXG4gICAqIHRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4sIG1ldGFkYXRhIGZpZWxkcyB0byByZXR1cm4sIGFuZCBhIHNjb3JlXG4gICAqIHRocmVzaG9sZCB0byBmaWx0ZXIgcmVzdWx0cyBieS5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yU2VhcmNoQW5kRmV0Y2hWZWN0b3JzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgVmVjdG9yU2VhcmNoQW5kRmV0Y2hWZWN0b3JzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBWZWN0b3JTZWFyY2hBbmRGZXRjaFZlY3RvcnMuRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlYXJjaEFuZEZldGNoVmVjdG9ycyhcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBxdWVyeVZlY3RvcjogbnVtYmVyW10sXG4gICAgb3B0aW9ucz86IFNlYXJjaE9wdGlvbnMgfCB1bmRlZmluZWRcbiAgKTogUHJvbWlzZTxWZWN0b3JTZWFyY2hBbmRGZXRjaFZlY3RvcnMuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LnNlYXJjaEFuZEZldGNoVmVjdG9ycyhcbiAgICAgIGluZGV4TmFtZSxcbiAgICAgIHF1ZXJ5VmVjdG9yLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGJhdGNoIG9mIGl0ZW1zIGZyb20gYSB2ZWN0b3IgaW5kZXguXG4gICAqIERlbGV0ZXMgYW55IGFuZCBhbGwgaXRlbXMgd2l0aCB0aGUgZ2l2ZW4gSURzIGZyb20gdGhlIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZGVsZXRlIHRoZSBpdGVtcyBmcm9tLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlkcyAtIFRoZSBJRHMgb2YgdGhlIGl0ZW1zIHRvIGJlIGRlbGV0ZWQgZnJvbSB0aGUgaW5kZXguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZlY3RvckRlbGV0ZUl0ZW1CYXRjaC5SZXNwb25zZT59XG4gICAqIHtAbGluayBWZWN0b3JEZWxldGVJdGVtQmF0Y2guU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIFZlY3RvckRlbGV0ZUl0ZW1CYXRjaC5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlSXRlbUJhdGNoKFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGlkczogQXJyYXk8c3RyaW5nPlxuICApOiBQcm9taXNlPFZlY3RvckRlbGV0ZUl0ZW1CYXRjaC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQuZGVsZXRlSXRlbUJhdGNoKGluZGV4TmFtZSwgaWRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgYmF0Y2ggb2YgaXRlbXMgZnJvbSBhIHZlY3RvciBpbmRleCBieSBJRC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGdldCB0aGUgaXRlbXMgZnJvbS5cbiAgICogQHBhcmFtIGlkcyAtIFRoZSBJRHMgb2YgdGhlIGl0ZW1zIHRvIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBpbmRleC5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yR2V0SXRlbUJhdGNoLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIFZlY3RvckdldEl0ZW1CYXRjaC5TdWNjZXNzfSBvbiBzdWNjZXNzLCB3aXRoIHRoZSBmb3VuZCBpdGVtcy5cbiAgICoge0BsaW5rIFZlY3RvckdldEl0ZW1CYXRjaC5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0SXRlbUJhdGNoKFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGlkczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxWZWN0b3JHZXRJdGVtQmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LmdldEl0ZW1CYXRjaChpbmRleE5hbWUsIGlkcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBtZXRhZGF0YSBmb3IgYSBiYXRjaCBvZiBpdGVtcyBmcm9tIGEgdmVjdG9yIGluZGV4IGJ5IElELlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZ2V0IHRoZSBpdGVtcyBmcm9tLlxuICAgKiBAcGFyYW0gaWRzIC0gVGhlIElEcyBvZiB0aGUgaXRlbXMgdG8gYmUgcmV0cmlldmVkIGZyb20gdGhlIGluZGV4LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWZWN0b3JHZXRJdGVtTWV0YWRhdGFCYXRjaC5SZXNwb25zZT59XG4gICAqIHtAbGluayBWZWN0b3JHZXRJdGVtTWV0YWRhdGFCYXRjaC5TdWNjZXNzfSBvbiBzdWNjZXNzLCB3aXRoIHRoZSBmb3VuZCBpdGVtIG1ldGFkYXRhLlxuICAgKiB7QGxpbmsgVmVjdG9yR2V0SXRlbU1ldGFkYXRhQmF0Y2guRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEl0ZW1NZXRhZGF0YUJhdGNoKFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGlkczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxWZWN0b3JHZXRJdGVtTWV0YWRhdGFCYXRjaC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQuZ2V0SXRlbU1ldGFkYXRhQmF0Y2goaW5kZXhOYW1lLCBpZHMpO1xuICB9XG59XG4iXX0=