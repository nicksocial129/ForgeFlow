/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var LangfusePersistedProperty;
(function (LangfusePersistedProperty) {
    LangfusePersistedProperty["Props"] = "props";
    LangfusePersistedProperty["Queue"] = "queue";
    LangfusePersistedProperty["OptedOut"] = "opted_out";
})(LangfusePersistedProperty || (LangfusePersistedProperty = {}));
const LangfusePostApiRoutes = {
    createTrace: ["POST", "/api/public/traces"],
    createEvent: ["POST", "/api/public/events"],
    createSpan: ["POST", "/api/public/spans"],
    updateSpan: ["PATCH", "/api/public/spans"],
    createGeneration: ["POST", "/api/public/generations"],
    updateGeneration: ["PATCH", "/api/public/generations"],
    createScore: ["POST", "/api/public/scores"],
};

function assert(truthyValue, message) {
    if (!truthyValue) {
        throw new Error(message);
    }
}
function removeTrailingSlash(url) {
    return url === null || url === void 0 ? void 0 : url.replace(/\/+$/, "");
}
function retriable(fn, props = {}, log) {
    return __awaiter(this, void 0, void 0, function* () {
        const { retryCount = 3, retryDelay = 5000, retryCheck = () => true } = props;
        let lastError = null;
        for (let i = 0; i < retryCount + 1; i++) {
            if (i > 0) {
                // don't wait when it's the first try
                yield new Promise((resolve) => setTimeout(resolve, retryDelay));
                log(`Retrying ${i + 1} of ${retryCount + 1}`);
            }
            try {
                const res = yield fn();
                return res;
            }
            catch (e) {
                lastError = e;
                if (!retryCheck(e)) {
                    throw e;
                }
                log(`Retriable error: ${JSON.stringify(e)}`);
            }
        }
        throw lastError;
    });
}
// https://stackoverflow.com/a/8809472
function generateUUID(globalThis) {
    // Public Domain/MIT
    let d = new Date().getTime(); //Timestamp
    let d2 = (globalThis && globalThis.performance && globalThis.performance.now && globalThis.performance.now() * 1000) || 0; //Time in microseconds since page-load or 0 if unsupported
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        let r = Math.random() * 16; //random number between 0 and 16
        if (d > 0) {
            //Use timestamp until depleted
            r = (d + r) % 16 | 0;
            d = Math.floor(d / 16);
        }
        else {
            //Use microseconds since page-load if supported
            r = (d2 + r) % 16 | 0;
            d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
}
function safeSetTimeout(fn, timeout) {
    // NOTE: we use this so rarely that it is totally fine to do `safeSetTimeout(fn, 0)``
    // rather than setImmediate.
    const t = setTimeout(fn, timeout);
    // We unref if available to prevent Node.js hanging on exit
    (t === null || t === void 0 ? void 0 : t.unref) && (t === null || t === void 0 ? void 0 : t.unref());
    return t;
}
function getEnv(key) {
    if (typeof process !== "undefined" && process.env[key]) {
        return process.env[key];
    }
    else if (typeof globalThis !== "undefined") {
        return globalThis[key];
    }
    return;
}

class SimpleEventEmitter {
    constructor() {
        this.events = {};
        this.events = {};
    }
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
        return () => {
            this.events[event] = this.events[event].filter((x) => x !== listener);
        };
    }
    emit(event, payload) {
        for (const listener of this.events[event] || []) {
            listener(payload);
        }
        for (const listener of this.events["*"] || []) {
            listener(event, payload);
        }
    }
}

const common_release_envs = [
    // Vercel
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    // Netlify
    "COMMIT_REF",
    // Render
    "RENDER_GIT_COMMIT",
    // GitLab CI
    "CI_COMMIT_SHA",
    // CicleCI
    "CIRCLE_SHA1",
    // Cloudflare pages
    "CF_PAGES_COMMIT_SHA",
    // AWS Amplify
    "REACT_APP_GIT_SHA",
    // Heroku
    "SOURCE_VERSION",
];
function getCommonReleaseEnvs() {
    for (const env of common_release_envs) {
        if (process.env[env]) {
            return process.env[env];
        }
    }
    return undefined;
}

class LangfuseFetchHttpError extends Error {
    constructor(response) {
        super("HTTP error while fetching Langfuse: " + response.status);
        this.response = response;
        this.name = "LangfuseFetchHttpError";
    }
}
class LangfuseFetchNetworkError extends Error {
    constructor(error) {
        super("Network error while fetching Langfuse", error instanceof Error ? { cause: error } : {});
        this.error = error;
        this.name = "LangfuseFetchNetworkError";
    }
}
function isLangfuseFetchError(err) {
    return typeof err === "object" && (err.name === "LangfuseFetchHttpError" || err.name === "LangfuseFetchNetworkError");
}
class LangfuseCoreStateless {
    constructor(params) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.debugMode = false;
        this.pendingPromises = {};
        // internal
        this._events = new SimpleEventEmitter();
        const { publicKey, secretKey } = params, options = __rest(params, ["publicKey", "secretKey"]);
        assert(publicKey, "You must pass your Langfuse project's api public key.");
        this.publicKey = publicKey;
        this.secretKey = secretKey;
        this.baseUrl = removeTrailingSlash((options === null || options === void 0 ? void 0 : options.baseUrl) || "https://cloud.langfuse.com");
        this.flushAt = (options === null || options === void 0 ? void 0 : options.flushAt) ? Math.max(options === null || options === void 0 ? void 0 : options.flushAt, 1) : 1;
        this.flushInterval = (_a = options === null || options === void 0 ? void 0 : options.flushInterval) !== null && _a !== void 0 ? _a : 10000;
        this.release = (_d = (_c = (_b = options === null || options === void 0 ? void 0 : options.release) !== null && _b !== void 0 ? _b : getEnv("LANGFUSE_RELEASE")) !== null && _c !== void 0 ? _c : getCommonReleaseEnvs()) !== null && _d !== void 0 ? _d : undefined;
        this._retryOptions = {
            retryCount: (_e = options === null || options === void 0 ? void 0 : options.fetchRetryCount) !== null && _e !== void 0 ? _e : 3,
            retryDelay: (_f = options === null || options === void 0 ? void 0 : options.fetchRetryDelay) !== null && _f !== void 0 ? _f : 3000,
            retryCheck: isLangfuseFetchError,
        };
        this.requestTimeout = (_g = options === null || options === void 0 ? void 0 : options.requestTimeout) !== null && _g !== void 0 ? _g : 10000; // 10 seconds
    }
    getCommonEventProperties() {
        return {
            $lib: this.getLibraryId(),
            $lib_version: this.getLibraryVersion(),
        };
    }
    on(event, cb) {
        return this._events.on(event, cb);
    }
    debug(enabled = true) {
        var _a;
        (_a = this.removeDebugCallback) === null || _a === void 0 ? void 0 : _a.call(this);
        this.debugMode = enabled;
        if (enabled) {
            this.removeDebugCallback = this.on("*", (event, payload) => console.log("Langfuse Debug", event, payload));
        }
    }
    /***
     *** Handlers for each object type
     ***/
    traceStateless(body) {
        const { id: bodyId, release: bodyRelease } = body, rest = __rest(body, ["id", "release"]);
        const id = bodyId !== null && bodyId !== void 0 ? bodyId : generateUUID();
        const release = bodyRelease !== null && bodyRelease !== void 0 ? bodyRelease : this.release;
        const parsedBody = Object.assign({ id,
            release }, rest);
        this.enqueue("createTrace", parsedBody);
        return id;
    }
    eventStateless(body) {
        const { id: bodyId, startTime: bodyStartTime } = body, rest = __rest(body, ["id", "startTime"]);
        const id = bodyId !== null && bodyId !== void 0 ? bodyId : generateUUID();
        const parsedBody = Object.assign({ id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createEvent", parsedBody);
        return id;
    }
    spanStateless(body) {
        const { id: bodyId, startTime: bodyStartTime } = body, rest = __rest(body, ["id", "startTime"]);
        const id = bodyId || generateUUID();
        const parsedBody = Object.assign({ id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createSpan", parsedBody);
        return id;
    }
    generationStateless(body) {
        const { id: bodyId, startTime: bodyStartTime } = body, rest = __rest(body, ["id", "startTime"]);
        const id = bodyId || generateUUID();
        const parsedBody = Object.assign({ id, startTime: bodyStartTime !== null && bodyStartTime !== void 0 ? bodyStartTime : new Date() }, rest);
        this.enqueue("createGeneration", parsedBody);
        return id;
    }
    scoreStateless(body) {
        const { id: bodyId } = body, rest = __rest(body, ["id"]);
        const id = bodyId || generateUUID();
        const parsedBody = Object.assign({ id }, rest);
        this.enqueue("createScore", parsedBody);
        return id;
    }
    updateSpanStateless(body) {
        this.enqueue("updateSpan", body);
        return body.spanId;
    }
    updateGenerationStateless(body) {
        this.enqueue("updateGeneration", body);
        return body.generationId;
    }
    _getDataset(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch(`${this.baseUrl}/api/public/datasets/${name}`, this.getFetchOptions({ method: "GET" })).then((res) => res.json());
        });
    }
    getDatasetRun(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch(`${this.baseUrl}/api/public/datasets/${params.datasetName}/runs/${params.runName}`, this.getFetchOptions({ method: "GET" })).then((res) => res.json());
        });
    }
    createDatasetRunItem(body) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch(`${this.baseUrl}/api/public/dataset-run-items`, this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then((res) => res.json());
        });
    }
    createDataset(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { name };
            return this.fetch(`${this.baseUrl}/api/public/datasets`, this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then((res) => res.json());
        });
    }
    /**
     * Creates a dataset item. Upserts the item if it already exists.
     * @param body The body of the dataset item to be created.
     * @returns A promise that resolves to the response of the create operation.
     */
    createDatasetItem(body) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch(`${this.baseUrl}/api/public/dataset-items`, this.getFetchOptions({ method: "POST", body: JSON.stringify(body) })).then((res) => res.json());
        });
    }
    getDatasetItem(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch(`${this.baseUrl}/api/public/dataset-items/${id}`, this.getFetchOptions({ method: "GET" })).then((res) => res.json());
        });
    }
    _parsePayload(response) {
        try {
            return JSON.parse(response);
        }
        catch (_a) {
            return response;
        }
    }
    /***
     *** QUEUEING AND FLUSHING
     ***/
    enqueue(type, body) {
        const queue = this.getPersistedProperty(LangfusePersistedProperty.Queue) || [];
        const id = generateUUID();
        queue.push({
            id,
            method: LangfusePostApiRoutes[type][0],
            apiRoute: LangfusePostApiRoutes[type][1],
            body,
        });
        this.setPersistedProperty(LangfusePersistedProperty.Queue, queue);
        this._events.emit(type, body);
        // Flush queued events if we meet the flushAt length
        if (queue.length >= this.flushAt) {
            this.flush();
        }
        if (this.flushInterval && !this._flushTimer) {
            this._flushTimer = safeSetTimeout(() => this.flush(), this.flushInterval);
        }
    }
    flushAsync() {
        return Promise.all(this.flush());
    }
    // Flushes all events that are not yet sent to the server
    // @returns {Promise[]} - list of promises for each item in the queue that is flushed
    flush() {
        if (this._flushTimer) {
            clearTimeout(this._flushTimer);
            this._flushTimer = null;
        }
        const queue = this.getPersistedProperty(LangfusePersistedProperty.Queue) || [];
        if (!queue.length) {
            return [];
        }
        // Flush all items in queue, could also use flushAt with splice to flush only a certain number of items (e.g. when batching)
        const items = queue;
        this.setPersistedProperty(LangfusePersistedProperty.Queue, []);
        // TODO: add /batch endpoint to ingest multiple events at once
        const promises = items.map((item) => {
            const done = (err) => {
                if (err) {
                    this._events.emit("error", err);
                }
                // remove promise from pendingPromises
                delete this.pendingPromises[item.id];
                this._events.emit("flush", item);
            };
            const payload = JSON.stringify(item.body); // implicit conversion also of dates to strings
            const url = `${this.baseUrl}${item.apiRoute}`;
            const fetchOptions = this.getFetchOptions({
                method: item.method,
                body: payload,
            });
            const requestPromise = this.fetchWithRetry(url, fetchOptions);
            this.pendingPromises[item.id] = requestPromise;
            requestPromise
                .then(() => done())
                .catch((err) => {
                done(err);
            });
            return requestPromise;
        });
        return promises;
    }
    getFetchOptions(p) {
        const fetchOptions = {
            method: p.method,
            headers: Object.assign({ "Content-Type": "application/json", "X-Langfuse-Sdk-Name": "langfuse-js", "X-Langfuse-Sdk-Version": this.getLibraryVersion(), "X-Langfuse-Sdk-Variant": this.getLibraryId(), "X-Langfuse-Public-Key": this.publicKey }, this.constructAuthorizationHeader(this.publicKey, this.secretKey)),
            body: p.body,
        };
        return fetchOptions;
    }
    constructAuthorizationHeader(publicKey, secretKey) {
        if (secretKey === undefined) {
            return { Authorization: "Bearer " + publicKey };
        }
        else {
            const encodedCredentials = typeof btoa === "function"
                ? // btoa() is available, the code is running in a browser or edge environment
                    btoa(publicKey + ":" + secretKey)
                : // btoa() is not available, the code is running in Node.js
                    Buffer.from(publicKey + ":" + secretKey).toString("base64");
            return { Authorization: "Basic " + encodedCredentials };
        }
    }
    fetchWithRetry(url, options, retryOptions) {
        var _a;
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = (_b = AbortSignal).timeout) !== null && _a !== void 0 ? _a : (_b.timeout = function timeout(ms) {
                const ctrl = new AbortController();
                setTimeout(() => ctrl.abort(), ms);
                return ctrl.signal;
            });
            return yield retriable(() => __awaiter(this, void 0, void 0, function* () {
                let res = null;
                try {
                    res = yield this.fetch(url, Object.assign({ signal: AbortSignal.timeout(this.requestTimeout) }, options));
                }
                catch (e) {
                    // fetch will only throw on network errors or on timeouts
                    throw new LangfuseFetchNetworkError(e);
                }
                if (res.status < 200 || res.status >= 400) {
                    throw new LangfuseFetchHttpError(res);
                }
                return res;
            }), Object.assign(Object.assign({}, this._retryOptions), retryOptions), (string) => this._events.emit("retry", string + ", " + url + ", " + JSON.stringify(options)));
        });
    }
    shutdownAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._flushTimer);
            try {
                yield this.flushAsync();
                yield Promise.all(Object.values(this.pendingPromises).map((x) => x.catch(() => {
                    // ignore errors as we are shutting down and can't deal with them anyways.
                })));
            }
            catch (e) {
                if (!isLangfuseFetchError(e)) {
                    throw e;
                }
                console.error("Error while shutting down Langfuse", e);
            }
        });
    }
    shutdown() {
        void this.shutdownAsync();
    }
    awaitAllQueuedAndPendingRequests() {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._flushTimer);
            yield this.flushAsync();
            yield Promise.all(Object.values(this.pendingPromises));
        });
    }
}
class LangfuseCore extends LangfuseCoreStateless {
    constructor(params) {
        assert(params.publicKey, "You must pass your Langfuse project's api public key.");
        assert(params.secretKey, "You must pass your Langfuse project's api secret key.");
        super(params);
    }
    trace(body) {
        const id = this.traceStateless(body !== null && body !== void 0 ? body : {});
        const t = new LangfuseTraceClient(this, id);
        if (getEnv("DEFER") && body) {
            try {
                const deferRuntime = getEnv("__deferRuntime");
                if (deferRuntime) {
                    deferRuntime.langfuseTraces([
                        {
                            id: id,
                            name: body.name || "",
                            url: t.getTraceUrl(),
                        },
                    ]);
                }
            }
            catch (_a) { }
        }
        return t;
    }
    span(body) {
        const traceId = body.traceId || this.traceStateless({ name: body.name });
        const id = this.spanStateless(Object.assign(Object.assign({}, body), { traceId }));
        return new LangfuseSpanClient(this, id, traceId);
    }
    generation(body) {
        const traceId = body.traceId || this.traceStateless({ name: body.name });
        const id = this.generationStateless(Object.assign(Object.assign({}, body), { traceId }));
        return new LangfuseGenerationClient(this, id, traceId);
    }
    event(body) {
        const traceId = body.traceId || this.traceStateless({ name: body.name });
        const id = this.eventStateless(Object.assign(Object.assign({}, body), { traceId }));
        return new LangfuseEventClient(this, id, traceId);
    }
    score(body) {
        this.scoreStateless(body);
        return this;
    }
    getDataset(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const _a = yield this._getDataset(name), { items } = _a, dataset = __rest(_a, ["items"]);
            const returnDataset = Object.assign(Object.assign({}, dataset), { items: items.map((item) => (Object.assign(Object.assign({}, item), { link: (obj, runName) => __awaiter(this, void 0, void 0, function* () {
                        yield this.awaitAllQueuedAndPendingRequests();
                        const data = yield this.createDatasetRunItem({
                            runName,
                            datasetItemId: item.id,
                            observationId: obj.id,
                        });
                        return data;
                    }) }))) });
            return returnDataset;
        });
    }
    _updateSpan(body) {
        this.updateSpanStateless(body);
        return this;
    }
    _updateGeneration(body) {
        this.updateGenerationStateless(body);
        return this;
    }
}
class LangfuseObjectClient {
    constructor({ client, id, traceId, observationId, }) {
        this.client = client;
        this.id = id;
        this.traceId = traceId;
        this.observationId = observationId;
    }
    event(body) {
        return this.client.event(Object.assign(Object.assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    }
    span(body) {
        return this.client.span(Object.assign(Object.assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    }
    generation(body) {
        return this.client.generation(Object.assign(Object.assign({}, body), { traceId: this.traceId, parentObservationId: this.observationId }));
    }
    score(body) {
        this.client.score(Object.assign(Object.assign({}, body), { traceId: this.traceId, observationId: this.observationId }));
        return this;
    }
    getTraceUrl() {
        return `${this.client.baseUrl}/trace/${this.traceId}`;
    }
}
class LangfuseTraceClient extends LangfuseObjectClient {
    constructor(client, traceId) {
        super({ client, id: traceId, traceId, observationId: null });
    }
    update(body) {
        this.client.trace(Object.assign(Object.assign({}, body), { id: this.id }));
        return this;
    }
}
class LangfuseObservationClient extends LangfuseObjectClient {
    constructor(client, id, traceId) {
        super({ client, id, traceId, observationId: id });
    }
}
class LangfuseSpanClient extends LangfuseObservationClient {
    constructor(client, id, traceId) {
        super(client, id, traceId);
    }
    update(body) {
        this.client._updateSpan(Object.assign(Object.assign({}, body), { spanId: this.id, traceId: this.traceId }));
        return this;
    }
    end(body) {
        this.client._updateSpan(Object.assign(Object.assign({}, body), { spanId: this.id, traceId: this.traceId, endTime: new Date() }));
        return this;
    }
}
class LangfuseGenerationClient extends LangfuseObservationClient {
    constructor(client, id, traceId) {
        super(client, id, traceId);
    }
    update(body) {
        this.client._updateGeneration(Object.assign(Object.assign({}, body), { generationId: this.id, traceId: this.traceId }));
        return this;
    }
    end(body) {
        this.client._updateGeneration(Object.assign(Object.assign({}, body), { generationId: this.id, traceId: this.traceId, endTime: new Date() }));
        return this;
    }
}
class LangfuseEventClient extends LangfuseObservationClient {
    constructor(client, id, traceId) {
        super(client, id, traceId);
    }
}

// Methods partially borrowed from quirksmode.org/js/cookies.html
const cookieStore = {
    getItem(key) {
        try {
            const nameEQ = key + "=";
            const ca = document.cookie.split(";");
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == " ") {
                    c = c.substring(1, c.length);
                }
                if (c.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(c.substring(nameEQ.length, c.length));
                }
            }
        }
        catch (err) { }
        return null;
    },
    setItem(key, value) {
        try {
            const cdomain = "", expires = "", secure = "";
            const new_cookie_val = key + "=" + encodeURIComponent(value) + expires + "; path=/" + cdomain + secure;
            document.cookie = new_cookie_val;
        }
        catch (err) {
            return;
        }
    },
    removeItem(name) {
        try {
            cookieStore.setItem(name, "");
        }
        catch (err) {
            return;
        }
    },
    clear() {
        document.cookie = "";
    },
    getAllKeys() {
        const ca = document.cookie.split(";");
        const keys = [];
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == " ") {
                c = c.substring(1, c.length);
            }
            keys.push(c.split("=")[0]);
        }
        return keys;
    },
};
const createStorageLike = (store) => {
    return {
        getItem(key) {
            return store.getItem(key);
        },
        setItem(key, value) {
            store.setItem(key, value);
        },
        removeItem(key) {
            store.removeItem(key);
        },
        clear() {
            store.clear();
        },
        getAllKeys() {
            const keys = [];
            for (const key in localStorage) {
                keys.push(key);
            }
            return keys;
        },
    };
};
const checkStoreIsSupported = (storage, key = "__mplssupport__") => {
    if (!window) {
        return false;
    }
    try {
        const val = "xyz";
        storage.setItem(key, val);
        if (storage.getItem(key) !== val) {
            return false;
        }
        storage.removeItem(key);
        return true;
    }
    catch (err) {
        return false;
    }
};
let localStore = undefined;
let sessionStore = undefined;
const createMemoryStorage = () => {
    const _cache = {};
    const store = {
        getItem(key) {
            return _cache[key];
        },
        setItem(key, value) {
            _cache[key] = value !== null ? value : undefined;
        },
        removeItem(key) {
            delete _cache[key];
        },
        clear() {
            for (const key in _cache) {
                delete _cache[key];
            }
        },
        getAllKeys() {
            const keys = [];
            for (const key in _cache) {
                keys.push(key);
            }
            return keys;
        },
    };
    return store;
};
const getStorage = (type, window) => {
    if (typeof window !== undefined && window) {
        if (!localStorage) {
            const _localStore = createStorageLike(window.localStorage);
            localStore = checkStoreIsSupported(_localStore) ? _localStore : undefined;
        }
        if (!sessionStore) {
            const _sessionStore = createStorageLike(window.sessionStorage);
            sessionStore = checkStoreIsSupported(_sessionStore) ? _sessionStore : undefined;
        }
    }
    switch (type) {
        case "cookie":
            return cookieStore || localStore || sessionStore || createMemoryStorage();
        case "localStorage":
            return localStore || sessionStore || createMemoryStorage();
        case "sessionStorage":
            return sessionStore || createMemoryStorage();
        case "memory":
            return createMemoryStorage();
        default:
            return createMemoryStorage();
    }
};

var version = "1.3.0";

class Langfuse extends LangfuseCore {
    constructor(params) {
        super(params);
        const { publicKey, secretKey } = params, options = __rest(params, ["publicKey", "secretKey"]);
        if (typeof window !== "undefined" && "Deno" in window === false) {
            this._storageKey = (options === null || options === void 0 ? void 0 : options.persistence_name) ? `lf_${options.persistence_name}` : `lf_${publicKey}_langfuse`;
            this._storage = getStorage((options === null || options === void 0 ? void 0 : options.persistence) || "localStorage", window);
        }
        else {
            this._storageKey = `lf_${publicKey}_langfuse`;
            this._storage = getStorage("memory", undefined);
        }
    }
    getPersistedProperty(key) {
        if (!this._storageCache) {
            this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
        }
        return this._storageCache[key];
    }
    setPersistedProperty(key, value) {
        if (!this._storageCache) {
            this._storageCache = JSON.parse(this._storage.getItem(this._storageKey) || "{}") || {};
        }
        if (value === null) {
            delete this._storageCache[key];
        }
        else {
            this._storageCache[key] = value;
        }
        this._storage.setItem(this._storageKey, JSON.stringify(this._storageCache));
    }
    fetch(url, options) {
        return fetch(url, options);
    }
    getLibraryId() {
        return "langfuse";
    }
    getLibraryVersion() {
        return version;
    }
    getCustomUserAgent() {
        return;
    }
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
    }
    return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

function parse(uuid) {
    if (!validate(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}

function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === 'string') {
            value = stringToBytes(value);
        }
        if (typeof namespace === 'string') {
            namespace = parse(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
            throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for (let i = 0; i < 16; ++i) {
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return unsafeStringify(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    }
    catch (err) { } // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
    if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
            bytes[i] = msg.charCodeAt(i);
        }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */
function md5ToHexEncodedArray(input) {
    const output = [];
    const length32 = input.length * 32;
    const hexTab = '0123456789abcdef';
    for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 0xff;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
    }
    return output;
}
/**
 * Calculate output length with padding and bit length
 */
function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function wordsToMd5(x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32;
    x[getOutputLength(len) - 1] = len;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function bytesToWords(input) {
    if (input.length === 0) {
        return [];
    }
    const length8 = input.length * 8;
    const output = new Uint32Array(getOutputLength(length8));
    for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
    }
    return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safeAdd(x, y) {
    const lsw = (x & 0xffff) + (y & 0xffff);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

v35('v3', 0x30, md5);

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
    randomUUID
};

function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return unsafeStringify(rnds);
}

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
    switch (s) {
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
            bytes.push(msg.charCodeAt(i));
        }
    }
    else if (!Array.isArray(bytes)) {
        // Convert Array-like to Array
        bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
            arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
            W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
            const s = Math.floor(t / 20);
            const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

v35('v5', 0x50, sha1);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var decamelize = function (str, sep) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    }
    sep = typeof sep === 'undefined' ? '_' : sep;
    return str
        .replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
        .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
        .toLowerCase();
};
var snakeCase = /*@__PURE__*/ getDefaultExportFromCjs(decamelize);

var camelcase = {exports: {}};

const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');
const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
            string = string.slice(0, i) + '-' + string.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
        }
        else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
            string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
        }
        else {
            isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
    }
    return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));
};
const postProcess = (input, toUpperCase) => {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))
        .replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));
};
const camelCase = (input, options) => {
    if (!(typeof input === 'string' || Array.isArray(input))) {
        throw new TypeError('Expected the input to be `string | string[]`');
    }
    options = Object.assign({ pascalCase: false, preserveConsecutiveUppercase: false }, options);
    if (Array.isArray(input)) {
        input = input.map(x => x.trim())
            .filter(x => x.length)
            .join('-');
    }
    else {
        input = input.trim();
    }
    if (input.length === 0) {
        return '';
    }
    const toLowerCase = options.locale === false ?
        string => string.toLowerCase() :
        string => string.toLocaleLowerCase(options.locale);
    const toUpperCase = options.locale === false ?
        string => string.toUpperCase() :
        string => string.toLocaleUpperCase(options.locale);
    if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
    }
    input = input.replace(LEADING_SEPARATORS, '');
    if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
    }
    else {
        input = toLowerCase(input);
    }
    if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
};
camelcase.exports = camelCase;
// TODO: Remove this for the next major release
camelcase.exports.default = camelCase;

function keyToJson(key, map) {
    return (map === null || map === void 0 ? void 0 : map[key]) || snakeCase(key);
}
function mapKeys(fields, mapper, map) {
    const mapped = {};
    for (const key in fields) {
        if (Object.hasOwn(fields, key)) {
            mapped[mapper(key, map)] = fields[key];
        }
    }
    return mapped;
}

function shallowCopy(obj) {
    return Array.isArray(obj) ? [...obj] : Object.assign({}, obj);
}
function replaceSecrets(root, secretsMap) {
    const result = shallowCopy(root);
    for (const [path, secretId] of Object.entries(secretsMap)) {
        const [last, ...partsReverse] = path.split(".").reverse();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let current = result;
        for (const part of partsReverse.reverse()) {
            if (current[part] === undefined) {
                break;
            }
            current[part] = shallowCopy(current[part]);
            current = current[part];
        }
        if (current[last] !== undefined) {
            current[last] = {
                lc: 1,
                type: "secret",
                id: [secretId],
            };
        }
    }
    return result;
}
/**
 * Get a unique name for the module, rather than parent class implementations.
 * Should not be subclassed, subclass lc_name above instead.
 */
function get_lc_unique_name(
// eslint-disable-next-line @typescript-eslint/no-use-before-define
serializableClass) {
    // "super" here would refer to the parent class of Serializable,
    // when we want the parent class of the module actually calling this method.
    const parentClass = Object.getPrototypeOf(serializableClass);
    const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" &&
        (typeof parentClass.lc_name !== "function" ||
            serializableClass.lc_name() !== parentClass.lc_name());
    if (lcNameIsSubclassed) {
        return serializableClass.lc_name();
    }
    else {
        return serializableClass.name;
    }
}
class Serializable {
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    static lc_name() {
        return this.name;
    }
    /**
     * The final serialized identifier for the module.
     */
    get lc_id() {
        return [
            ...this.lc_namespace,
            get_lc_unique_name(this.constructor),
        ];
    }
    /**
     * A map of secrets, which will be omitted from serialization.
     * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
     * Values are the secret ids, which will be used when deserializing.
     */
    get lc_secrets() {
        return undefined;
    }
    /**
     * A map of additional attributes to merge with constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the attribute values, which will be serialized.
     * These attributes need to be accepted by the constructor as arguments.
     */
    get lc_attributes() {
        return undefined;
    }
    /**
     * A map of aliases for constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the alias that will replace the key in serialization.
     * This is used to eg. make argument names match Python.
     */
    get lc_aliases() {
        return undefined;
    }
    constructor(kwargs, ..._args) {
        Object.defineProperty(this, "lc_serializable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "lc_kwargs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.lc_kwargs = kwargs || {};
    }
    toJSON() {
        if (!this.lc_serializable) {
            return this.toJSONNotImplemented();
        }
        if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        this.lc_kwargs instanceof Serializable ||
            typeof this.lc_kwargs !== "object" ||
            Array.isArray(this.lc_kwargs)) {
            // We do not support serialization of classes with arg not a POJO
            // I'm aware the check above isn't as strict as it could be
            return this.toJSONNotImplemented();
        }
        const aliases = {};
        const secrets = {};
        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
            acc[key] = key in this ? this[key] : this.lc_kwargs[key];
            return acc;
        }, {});
        // get secrets, attributes and aliases from all superclasses
        for (
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
            Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
            Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
            Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
        }
        // include all secrets used, even if not in kwargs,
        // will be replaced with sentinel value in replaceSecrets
        Object.keys(secrets).forEach((keyPath) => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any
            let read = this;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let write = kwargs;
            const [last, ...partsReverse] = keyPath.split(".").reverse();
            for (const key of partsReverse.reverse()) {
                if (!(key in read) || read[key] === undefined)
                    return;
                if (!(key in write) || write[key] === undefined) {
                    if (typeof read[key] === "object" && read[key] != null) {
                        write[key] = {};
                    }
                    else if (Array.isArray(read[key])) {
                        write[key] = [];
                    }
                }
                read = read[key];
                write = write[key];
            }
            if (last in read && read[last] !== undefined) {
                write[last] = write[last] || read[last];
            }
        });
        return {
            lc: 1,
            type: "constructor",
            id: this.lc_id,
            kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases),
        };
    }
    toJSONNotImplemented() {
        return {
            lc: 1,
            type: "not_implemented",
            id: this.lc_id,
        };
    }
}

/**
 * Abstract class that provides a set of optional methods that can be
 * overridden in derived classes to handle various events during the
 * execution of a LangChain application.
 */
class BaseCallbackHandlerMethodsClass {
}
/**
 * Abstract base class for creating callback handlers in the LangChain
 * framework. It provides a set of optional methods that can be overridden
 * in derived classes to handle various events during the execution of a
 * LangChain application.
 */
class BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
    get lc_namespace() {
        return ["langchain", "callbacks", this.name];
    }
    get lc_secrets() {
        return undefined;
    }
    get lc_attributes() {
        return undefined;
    }
    get lc_aliases() {
        return undefined;
    }
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    static lc_name() {
        return this.name;
    }
    /**
     * The final serialized identifier for the module.
     */
    get lc_id() {
        return [
            ...this.lc_namespace,
            get_lc_unique_name(this.constructor),
        ];
    }
    constructor(input) {
        var _a, _b, _c, _d, _e;
        super();
        Object.defineProperty(this, "lc_serializable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "lc_kwargs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ignoreLLM", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ignoreChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ignoreAgent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ignoreRetriever", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "awaitHandlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: typeof process !== "undefined"
                ? // eslint-disable-next-line no-process-env
                    ((_a = process.env) === null || _a === void 0 ? void 0 : _a.LANGCHAIN_CALLBACKS_BACKGROUND) !== "true"
                : true
        });
        this.lc_kwargs = input || {};
        if (input) {
            this.ignoreLLM = (_b = input.ignoreLLM) !== null && _b !== void 0 ? _b : this.ignoreLLM;
            this.ignoreChain = (_c = input.ignoreChain) !== null && _c !== void 0 ? _c : this.ignoreChain;
            this.ignoreAgent = (_d = input.ignoreAgent) !== null && _d !== void 0 ? _d : this.ignoreAgent;
            this.ignoreRetriever = (_e = input.ignoreRetriever) !== null && _e !== void 0 ? _e : this.ignoreRetriever;
        }
    }
    copy() {
        return new this.constructor(this);
    }
    toJSON() {
        return Serializable.prototype.toJSON.call(this);
    }
    toJSONNotImplemented() {
        return Serializable.prototype.toJSONNotImplemented.call(this);
    }
    static fromMethods(methods) {
        class Handler extends BaseCallbackHandler {
            constructor() {
                super();
                Object.defineProperty(this, "name", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: v4()
                });
                Object.assign(this, methods);
            }
        }
        return new Handler();
    }
}

var ansiStyles = {exports: {}};

ansiStyles.exports;
(function (module) {
    const ANSI_BACKGROUND_OFFSET = 10;
    const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;
    const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
        const codes = new Map();
        const styles = {
            modifier: {
                reset: [0, 0],
                // 21 isn't widely supported and 22 does the same thing
                bold: [1, 22],
                dim: [2, 22],
                italic: [3, 23],
                underline: [4, 24],
                overline: [53, 55],
                inverse: [7, 27],
                hidden: [8, 28],
                strikethrough: [9, 29]
            },
            color: {
                black: [30, 39],
                red: [31, 39],
                green: [32, 39],
                yellow: [33, 39],
                blue: [34, 39],
                magenta: [35, 39],
                cyan: [36, 39],
                white: [37, 39],
                // Bright color
                blackBright: [90, 39],
                redBright: [91, 39],
                greenBright: [92, 39],
                yellowBright: [93, 39],
                blueBright: [94, 39],
                magentaBright: [95, 39],
                cyanBright: [96, 39],
                whiteBright: [97, 39]
            },
            bgColor: {
                bgBlack: [40, 49],
                bgRed: [41, 49],
                bgGreen: [42, 49],
                bgYellow: [43, 49],
                bgBlue: [44, 49],
                bgMagenta: [45, 49],
                bgCyan: [46, 49],
                bgWhite: [47, 49],
                // Bright color
                bgBlackBright: [100, 49],
                bgRedBright: [101, 49],
                bgGreenBright: [102, 49],
                bgYellowBright: [103, 49],
                bgBlueBright: [104, 49],
                bgMagentaBright: [105, 49],
                bgCyanBright: [106, 49],
                bgWhiteBright: [107, 49]
            }
        };
        // Alias bright black as gray (and grey)
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style] of Object.entries(group)) {
                styles[styleName] = {
                    open: `\u001B[${style[0]}m`,
                    close: `\u001B[${style[1]}m`
                };
                group[styleName] = styles[styleName];
                codes.set(style[0], style[1]);
            }
            Object.defineProperty(styles, groupName, {
                value: group,
                enumerable: false
            });
        }
        Object.defineProperty(styles, 'codes', {
            value: codes,
            enumerable: false
        });
        styles.color.close = '\u001B[39m';
        styles.bgColor.close = '\u001B[49m';
        styles.color.ansi256 = wrapAnsi256();
        styles.color.ansi16m = wrapAnsi16m();
        styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
        styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
        // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
        Object.defineProperties(styles, {
            rgbToAnsi256: {
                value: (red, green, blue) => {
                    // We use the extended greyscale palette here, with the exception of
                    // black and white. normal palette only has 4 greyscale shades.
                    if (red === green && green === blue) {
                        if (red < 8) {
                            return 16;
                        }
                        if (red > 248) {
                            return 231;
                        }
                        return Math.round(((red - 8) / 247) * 24) + 232;
                    }
                    return 16 +
                        (36 * Math.round(red / 255 * 5)) +
                        (6 * Math.round(green / 255 * 5)) +
                        Math.round(blue / 255 * 5);
                },
                enumerable: false
            },
            hexToRgb: {
                value: hex => {
                    const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
                    if (!matches) {
                        return [0, 0, 0];
                    }
                    let { colorString } = matches.groups;
                    if (colorString.length === 3) {
                        colorString = colorString.split('').map(character => character + character).join('');
                    }
                    const integer = Number.parseInt(colorString, 16);
                    return [
                        (integer >> 16) & 0xFF,
                        (integer >> 8) & 0xFF,
                        integer & 0xFF
                    ];
                },
                enumerable: false
            },
            hexToAnsi256: {
                value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
                enumerable: false
            }
        });
        return styles;
    }
    // Make the export immutable
    Object.defineProperty(module, 'exports', {
        enumerable: true,
        get: assembleStyles
    });
}(ansiStyles));
ansiStyles.exports;

var pRetry$1 = {exports: {}};

var retry$2 = {};

function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
        options = { forever: options };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
    }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function () {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function () {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (this._timer) {
        clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function (err) {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (!err) {
        return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error('RetryOperation timeout occurred'));
        return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
        if (this._cachedTimeouts) {
            // retry forever, only keep last error
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
        }
        else {
            return false;
        }
    }
    var self = this;
    this._timer = setTimeout(function () {
        self._attempts++;
        if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function () {
                self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
                self._timeout.unref();
            }
        }
        self._fn(self._attempts);
    }, timeout);
    if (this._options.unref) {
        this._timer.unref();
    }
    return true;
};
RetryOperation.prototype.attempt = function (fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
        if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
        }
    }
    var self = this;
    if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function () {
            self._operationTimeoutCb();
        }, self._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
};
RetryOperation.prototype.try = function (fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = function (fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function () {
    return this._errors;
};
RetryOperation.prototype.attempts = function () {
    return this._attempts;
};
RetryOperation.prototype.mainError = function () {
    if (this._errors.length === 0) {
        return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
        }
    }
    return mainError;
};

(function (exports) {
    var RetryOperation = retry_operation;
    exports.operation = function (options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
            forever: options && (options.forever || options.retries === Infinity),
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
        });
    };
    exports.timeouts = function (options) {
        if (options instanceof Array) {
            return [].concat(options);
        }
        var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1000,
            maxTimeout: Infinity,
            randomize: false
        };
        for (var key in options) {
            opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
            throw new Error('minTimeout is greater than maxTimeout');
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
        }
        // sort the array numerically ascending
        timeouts.sort(function (a, b) {
            return a - b;
        });
        return timeouts;
    };
    exports.createTimeout = function (attempt, opts) {
        var random = (opts.randomize)
            ? (Math.random() + 1)
            : 1;
        var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
    };
    exports.wrap = function (obj, options, methods) {
        if (options instanceof Array) {
            methods = options;
            options = null;
        }
        if (!methods) {
            methods = [];
            for (var key in obj) {
                if (typeof obj[key] === 'function') {
                    methods.push(key);
                }
            }
        }
        for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = function retryWrapper(original) {
                var op = exports.operation(options);
                var args = Array.prototype.slice.call(arguments, 1);
                var callback = args.pop();
                args.push(function (err) {
                    if (op.retry(err)) {
                        return;
                    }
                    if (err) {
                        arguments[0] = op.mainError();
                    }
                    callback.apply(this, arguments);
                });
                op.attempt(function () {
                    original.apply(obj, args);
                });
            }.bind(obj, original);
            obj[method].options = options;
        }
    };
}(retry$2));

var retry$1 = retry$2;

const retry = retry$1;
const networkErrorMsgs = [
    'Failed to fetch',
    'NetworkError when attempting to fetch resource.',
    'The Internet connection appears to be offline.',
    'Network request failed' // `cross-fetch`
];
class AbortError extends Error {
    constructor(message) {
        super();
        if (message instanceof Error) {
            this.originalError = message;
            ({ message } = message);
        }
        else {
            this.originalError = new Error(message);
            this.originalError.stack = this.stack;
        }
        this.name = 'AbortError';
        this.message = message;
    }
}
const decorateErrorWithCounts = (error, attemptNumber, options) => {
    // Minus 1 from attemptNumber because the first attempt does not count as a retry
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
};
const isNetworkError = errorMessage => networkErrorMsgs.includes(errorMessage);
const pRetry = (input, options) => new Promise((resolve, reject) => {
    options = Object.assign({ onFailedAttempt: () => { }, retries: 10 }, options);
    const operation = retry.operation(options);
    operation.attempt((attemptNumber) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            resolve(yield input(attemptNumber));
        }
        catch (error) {
            if (!(error instanceof Error)) {
                reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
                return;
            }
            if (error instanceof AbortError) {
                operation.stop();
                reject(error.originalError);
            }
            else if (error instanceof TypeError && !isNetworkError(error.message)) {
                operation.stop();
                reject(error);
            }
            else {
                decorateErrorWithCounts(error, attemptNumber, options);
                try {
                    yield options.onFailedAttempt(error);
                }
                catch (error) {
                    reject(error);
                    return;
                }
                if (!operation.retry(error)) {
                    reject(operation.mainError());
                }
            }
        }
    }));
});
pRetry$1.exports = pRetry;
// TODO: remove this in the next major version
pRetry$1.exports.default = pRetry;
pRetry$1.exports.AbortError = AbortError;

var dist = {};

var eventemitter3 = {exports: {}};

(function (module) {
    var has = Object.prototype.hasOwnProperty, prefix = '~';
    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() { }
    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
        Events.prototype = Object.create(null);
        //
        // This hack is needed because the `__proto__` property is still inherited in
        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
        //
        if (!new Events().__proto__)
            prefix = false;
    }
    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
    }
    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== 'function') {
            throw new TypeError('The listener must be a function');
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
            emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
            emitter._events[evt].push(listener);
        else
            emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
    }
    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
            emitter._events = new Events();
        else
            delete emitter._events[evt];
    }
    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
    }
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
            return names;
        for (name in (events = this._events)) {
            if (has.call(events, name))
                names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
    };
    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
            return [];
        if (handlers.fn)
            return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
        }
        return ee;
    };
    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
            return 0;
        if (listeners.fn)
            return 1;
        return listeners.length;
    };
    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
            return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
            if (listeners.once)
                this.removeListener(event, listeners.fn, undefined, true);
            switch (len) {
                case 1: return listeners.fn.call(listeners.context), true;
                case 2: return listeners.fn.call(listeners.context, a1), true;
                case 3: return listeners.fn.call(listeners.context, a1, a2), true;
                case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
                args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
        }
        else {
            var length = listeners.length, j;
            for (i = 0; i < length; i++) {
                if (listeners[i].once)
                    this.removeListener(event, listeners[i].fn, undefined, true);
                switch (len) {
                    case 1:
                        listeners[i].fn.call(listeners[i].context);
                        break;
                    case 2:
                        listeners[i].fn.call(listeners[i].context, a1);
                        break;
                    case 3:
                        listeners[i].fn.call(listeners[i].context, a1, a2);
                        break;
                    case 4:
                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                        break;
                    default:
                        if (!args)
                            for (j = 1, args = new Array(len - 1); j < len; j++) {
                                args[j - 1] = arguments[j];
                            }
                        listeners[i].fn.apply(listeners[i].context, args);
                }
            }
        }
        return true;
    };
    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
    };
    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
    };
    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
            return this;
        if (!fn) {
            clearEvent(this, evt);
            return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
            if (listeners.fn === fn &&
                (!once || listeners.once) &&
                (!context || listeners.context === context)) {
                clearEvent(this, evt);
            }
        }
        else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                if (listeners[i].fn !== fn ||
                    (once && !listeners[i].once) ||
                    (context && listeners[i].context !== context)) {
                    events.push(listeners[i]);
                }
            }
            //
            // Reset the array, or remove it completely if we have no more listeners.
            //
            if (events.length)
                this._events[evt] = events.length === 1 ? events[0] : events;
            else
                clearEvent(this, evt);
        }
        return this;
    };
    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt])
                clearEvent(this, evt);
        }
        else {
            this._events = new Events();
            this._eventsCount = 0;
        }
        return this;
    };
    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;
    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;
    //
    // Expose the module.
    //
    {
        module.exports = EventEmitter;
    }
}(eventemitter3));
var eventemitter3Exports = eventemitter3.exports;

var pTimeout$1 = {exports: {}};

var pFinally$1 = (promise, onFinally) => {
    onFinally = onFinally || (() => { });
    return promise.then(val => new Promise(resolve => {
        resolve(onFinally());
    }).then(() => val), err => new Promise(resolve => {
        resolve(onFinally());
    }).then(() => {
        throw err;
    }));
};

const pFinally = pFinally$1;
class TimeoutError extends Error {
    constructor(message) {
        super(message);
        this.name = 'TimeoutError';
    }
}
const pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== 'number' || milliseconds < 0) {
        throw new TypeError('Expected `milliseconds` to be a positive number');
    }
    if (milliseconds === Infinity) {
        resolve(promise);
        return;
    }
    const timer = setTimeout(() => {
        if (typeof fallback === 'function') {
            try {
                resolve(fallback());
            }
            catch (error) {
                reject(error);
            }
            return;
        }
        const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === 'function') {
            promise.cancel();
        }
        reject(timeoutError);
    }, milliseconds);
    // TODO: Use native `finally` keyword when targeting Node.js 10
    pFinally(
    // eslint-disable-next-line promise/prefer-await-to-then
    promise.then(resolve, reject), () => {
        clearTimeout(timer);
    });
});
pTimeout$1.exports = pTimeout;
// TODO: Remove this for the next major release
pTimeout$1.exports.default = pTimeout;
pTimeout$1.exports.TimeoutError = TimeoutError;
var pTimeoutExports = pTimeout$1.exports;

var priorityQueue = {};

var lowerBound$1 = {};

Object.defineProperty(lowerBound$1, "__esModule", { value: true });
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
        const step = (count / 2) | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        }
        else {
            count = step;
        }
    }
    return first;
}
lowerBound$1.default = lowerBound;

Object.defineProperty(priorityQueue, "__esModule", { value: true });
const lower_bound_1 = lowerBound$1;
class PriorityQueue {
    constructor() {
        this._queue = [];
    }
    enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
            priority: options.priority,
            run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
            this._queue.push(element);
            return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
    }
    dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
        return this._queue.length;
    }
}
priorityQueue.default = PriorityQueue;

Object.defineProperty(dist, "__esModule", { value: true });
const EventEmitter = eventemitter3Exports;
const p_timeout_1 = pTimeoutExports;
const priority_queue_1 = priorityQueue;
// eslint-disable-next-line @typescript-eslint/no-empty-function
const empty = () => { };
const timeoutError = new p_timeout_1.TimeoutError();
/**
Promise queue with concurrency control.
*/
class PQueue extends EventEmitter {
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
            throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
    }
    _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit('next');
    }
    _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
            this._resolveIdle();
            this._resolveIdle = empty;
            this.emit('idle');
        }
    }
    _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = undefined;
    }
    _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === undefined) {
            const delay = this._intervalEnd - now;
            if (delay < 0) {
                // Act as the interval was done
                // We don't need to resume it here because it will be resumed on line 160
                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
            }
            else {
                // Act as the interval is pending
                if (this._timeoutId === undefined) {
                    this._timeoutId = setTimeout(() => {
                        this._onResumeInterval();
                    }, delay);
                }
                return true;
            }
        }
        return false;
    }
    _tryToStartAnother() {
        if (this._queue.size === 0) {
            // We can clear the interval ("pause")
            // Because we can redo it later ("resume")
            if (this._intervalId) {
                clearInterval(this._intervalId);
            }
            this._intervalId = undefined;
            this._resolvePromises();
            return false;
        }
        if (!this._isPaused) {
            const canInitializeInterval = !this._isIntervalPaused();
            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                const job = this._queue.dequeue();
                if (!job) {
                    return false;
                }
                this.emit('active');
                job();
                if (canInitializeInterval) {
                    this._initializeIntervalIfNeeded();
                }
                return true;
            }
        }
        return false;
    }
    _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== undefined) {
            return;
        }
        this._intervalId = setInterval(() => {
            this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = undefined;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
        // eslint-disable-next-line no-empty
        while (this._tryToStartAnother()) { }
    }
    get concurrency() {
        return this._concurrency;
    }
    set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
            throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    add(fn, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const run = () => __awaiter(this, void 0, void 0, function* () {
                    this._pendingCount++;
                    this._intervalCount++;
                    try {
                        const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {
                            if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {
                                reject(timeoutError);
                            }
                            return undefined;
                        });
                        resolve(yield operation);
                    }
                    catch (error) {
                        reject(error);
                    }
                    this._next();
                });
                this._queue.enqueue(run, options);
                this._tryToStartAnother();
                this.emit('add');
            });
        });
    }
    /**
    Same as `.add()`, but accepts an array of sync or async functions.

    @returns A promise that resolves when all functions are resolved.
    */
    addAll(functions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(functions.map((function_) => __awaiter(this, void 0, void 0, function* () { return this.add(function_, options); })));
        });
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
        this._isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
        this._queue = new this._queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */
    onEmpty() {
        return __awaiter(this, void 0, void 0, function* () {
            // Instantly resolve if the queue is empty
            if (this._queue.size === 0) {
                return;
            }
            return new Promise(resolve => {
                const existingResolve = this._resolveEmpty;
                this._resolveEmpty = () => {
                    existingResolve();
                    resolve();
                };
            });
        });
    }
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    onIdle() {
        return __awaiter(this, void 0, void 0, function* () {
            // Instantly resolve if none pending and if nothing else is queued
            if (this._pendingCount === 0 && this._queue.size === 0) {
                return;
            }
            return new Promise(resolve => {
                const existingResolve = this._resolveIdle;
                this._resolveIdle = () => {
                    existingResolve();
                    resolve();
                };
            });
        });
    }
    /**
    Size of the queue.
    */
    get size() {
        return this._queue.size;
    }
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
    sizeBy(options) {
        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
        return this._queue.filter(options).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
        return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
        return this._isPaused;
    }
    get timeout() {
        return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(milliseconds) {
        this._timeout = milliseconds;
    }
}
dist.default = PQueue;

/**
 * Base class for all types of messages in a conversation. It includes
 * properties like `content`, `name`, and `additional_kwargs`. It also
 * includes methods like `toDict()` and `_getType()`.
 */
class BaseMessage extends Serializable {
    /**
     * @deprecated
     * Use {@link BaseMessage.content} instead.
     */
    get text() {
        return this.content;
    }
    constructor(fields, 
    /** @deprecated */
    kwargs) {
        if (typeof fields === "string") {
            // eslint-disable-next-line no-param-reassign
            fields = { content: fields, additional_kwargs: kwargs };
        }
        // Make sure the default value for additional_kwargs is passed into super() for serialization
        if (!fields.additional_kwargs) {
            // eslint-disable-next-line no-param-reassign
            fields.additional_kwargs = {};
        }
        super(fields);
        Object.defineProperty(this, "lc_namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["langchain", "schema"]
        });
        Object.defineProperty(this, "lc_serializable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        /** The text of the message. */
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The name of the message sender in a multi-user chat. */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Additional keyword arguments */
        Object.defineProperty(this, "additional_kwargs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = fields.name;
        this.content = fields.content;
        this.additional_kwargs = fields.additional_kwargs;
    }
    toDict() {
        return {
            type: this._getType(),
            data: this.toJSON()
                .kwargs,
        };
    }
}
/**
 * Represents an AI message in a conversation.
 */
class AIMessage extends BaseMessage {
    static lc_name() {
        return "AIMessage";
    }
    _getType() {
        return "ai";
    }
}

class CallbackHandler extends BaseCallbackHandler {
  constructor(params) {
    var _a;
    super();
    this.name = "CallbackHandler";
    if ("root" in params) {
      this.langfuse = params.root.client;
      this.rootObservationId = (_a = params.root.observationId) !== null && _a !== void 0 ? _a : undefined;
      this.traceId = params.root.traceId;
    } else {
      this.langfuse = new Langfuse(Object.assign(Object.assign({}, params), {
        persistence: "memory"
      }));
    }
    this.userId = params.userId;
    this.version = params.version;
  }
  flushAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.langfuse.flushAsync();
    });
  }
  shutdownAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.langfuse.shutdownAsync();
    });
  }
  debug(enabled = true) {
    this.langfuse.debug(enabled);
  }
  handleNewToken(token, runId) {
    return __awaiter(this, void 0, void 0, function* () {
      console.log("New token:", token, "with ID:", runId);
    });
  }
  getTraceId() {
    return this.traceId;
  }
  getTraceUrl() {
    return this.traceId ? `${this.langfuse.baseUrl}/trace/${this.traceId}` : undefined;
  }
  getLangchainRunId() {
    return this.topLevelObservationId;
  }
  handleRetrieverError(err, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Retriever error:", err, runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          level: "ERROR",
          statusMessage: err.toString(),
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleChainStart(chain, inputs, runId, parentRunId, tags, metadata) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Chain start with Id:", runId);
        this.generateTrace(chain, runId, parentRunId, tags, metadata);
        this.langfuse.span({
          id: runId,
          traceId: this.traceId,
          parentObservationId: parentRunId !== null && parentRunId !== void 0 ? parentRunId : this.rootObservationId,
          name: (_a = chain.id.at(-1)) === null || _a === void 0 ? void 0 : _a.toString(),
          metadata: this.joinTagsAndMetaData(tags, metadata),
          input: inputs,
          startTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleAgentAction(action, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Agent action:", runId);
        this.langfuse.span({
          id: runId,
          parentObservationId: parentRunId,
          traceId: this.traceId,
          endTime: new Date(),
          input: action,
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleAgentEnd(action, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Agent finish:", runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          endTime: new Date(),
          output: action,
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleChainError(err, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Chain error:", err, runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          level: "ERROR",
          statusMessage: err.toString(),
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  generateTrace(serialized, runId, parentRunId, tags, metadata) {
    var _a;
    if (!this.traceId) {
      this.langfuse.trace({
        id: runId,
        name: (_a = serialized.id.at(-1)) === null || _a === void 0 ? void 0 : _a.toString(),
        metadata: this.joinTagsAndMetaData(tags, metadata),
        userId: this.userId,
        version: this.version
      });
      this.traceId = runId;
    }
    this.topLevelObservationId = parentRunId ? this.topLevelObservationId : runId;
  }
  handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      console.log("Generation start:", runId);
      this.generateTrace(llm, runId, parentRunId, tags, metadata);
      const modelParameters = {};
      const invocationParams = extraParams === null || extraParams === void 0 ? void 0 : extraParams["invocation_params"];
      for (const [key, value] of Object.entries({
        temperature: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.temperature,
        max_tokens: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.max_tokens,
        top_p: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.top_p,
        frequency_penalty: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.frequency_penalty,
        presence_penalty: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.presence_penalty,
        request_timeout: invocationParams === null || invocationParams === void 0 ? void 0 : invocationParams.request_timeout
      })) {
        if (value !== undefined && value !== null) {
          modelParameters[key] = value;
        }
      }
      let extractedModelName;
      if (extraParams) {
        const params = extraParams.invocation_params;
        extractedModelName = params.model;
      }
      this.langfuse.generation({
        id: runId,
        traceId: this.traceId,
        name: (_a = llm.id.at(-1)) === null || _a === void 0 ? void 0 : _a.toString(),
        startTime: new Date(),
        metadata: this.joinTagsAndMetaData(tags, metadata),
        parentObservationId: parentRunId !== null && parentRunId !== void 0 ? parentRunId : this.rootObservationId,
        prompt: messages,
        model: extractedModelName,
        modelParameters: modelParameters,
        version: this.version
      });
    });
  }
  handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("ChatModel start:", runId);
        this.handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata);
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleChainEnd(outputs, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Chain end:", runId, parentRunId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          output: outputs,
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("LLM start:", runId);
        this.handleGenerationStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata);
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleToolStart(tool, input, runId, parentRunId, tags, metadata) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Tool start:", runId);
        this.langfuse.span({
          id: runId,
          parentObservationId: parentRunId,
          traceId: this.traceId,
          name: (_a = tool.id.at(-1)) === null || _a === void 0 ? void 0 : _a.toString(),
          input: input,
          metadata: this.joinTagsAndMetaData(tags, metadata),
          startTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Retriever start:", runId);
        this.langfuse.span({
          id: runId,
          parentObservationId: parentRunId,
          traceId: this.traceId,
          name: (_a = retriever.id.at(-1)) === null || _a === void 0 ? void 0 : _a.toString(),
          input: query,
          metadata: this.joinTagsAndMetaData(tags, metadata),
          startTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleRetrieverEnd(documents, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Retriever end:", runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          output: documents,
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleToolEnd(output, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Tool end:", runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          output: output,
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleToolError(err, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("Tool error:", err, runId);
        this.langfuse._updateSpan({
          spanId: runId,
          traceId: this.traceId,
          level: "ERROR",
          statusMessage: err.toString(),
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleLLMEnd(output, runId, parentRunId) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("LLM end:", runId, parentRunId);
        const lastResponse = output.generations[output.generations.length - 1][output.generations[output.generations.length - 1].length - 1];
        const llmUsage = (_a = output.llmOutput) === null || _a === void 0 ? void 0 : _a["tokenUsage"];
        this.langfuse._updateGeneration({
          generationId: runId,
          traceId: this.traceId,
          completion: !lastResponse.text && "message" in lastResponse && lastResponse["message"] instanceof AIMessage && lastResponse["message"].additional_kwargs ? lastResponse["message"].additional_kwargs : lastResponse.text,
          endTime: new Date(),
          usage: llmUsage,
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  handleLLMError(err, runId, parentRunId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        console.log("LLM error:", err, runId);
        this.langfuse._updateGeneration({
          generationId: runId,
          traceId: this.traceId,
          level: "ERROR",
          statusMessage: err.toString(),
          endTime: new Date(),
          version: this.version
        });
      } catch (e) {
        console.log("Error:", e);
      }
    });
  }
  joinTagsAndMetaData(tags, metadata) {
    if (tags) {
      const finalDict = {
        tags: tags
      };
      if (metadata) {
        return Object.assign(Object.assign({}, finalDict), metadata);
      }
    }
    return metadata !== null && metadata !== void 0 ? metadata : {};
  }
}

export { CallbackHandler, Langfuse, CallbackHandler as default };
//# sourceMappingURL=index.esm.js.map
