import { type LangfuseFetchOptions, type LangfuseFetchResponse, type LangfuseCoreOptions, LangfusePersistedProperty, type CreateLangfuseTraceBody, type LangfuseObject, type CreateLangfuseEventBody, type CreateLangfuseSpanBody, type CreateLangfuseGenerationBody, type CreateLangfuseScoreBody, type UpdateLangfuseSpanBody, type UpdateLangfuseGenerationBody, type GetLangfuseDatasetParams, type GetLangfuseDatasetResponse, type CreateLangfuseDatasetRunItemBody, type CreateLangfuseDatasetRunItemResponse, type CreateLangfuseDatasetResponse, type CreateLangfuseDatasetItemBody, type CreateLangfuseDatasetItemResponse, type GetLangfuseDatasetRunResponse, type GetLangfuseDatasetRunParams } from "./types";
import { type RetriableOptions } from "./utils";
export * as utils from "./utils";
import { SimpleEventEmitter } from "./eventemitter";
declare abstract class LangfuseCoreStateless {
    private secretKey;
    private publicKey;
    baseUrl: string;
    private flushAt;
    private flushInterval;
    private requestTimeout;
    private removeDebugCallback?;
    private debugMode;
    private pendingPromises;
    private release;
    protected _events: SimpleEventEmitter;
    protected _flushTimer?: any;
    protected _retryOptions: RetriableOptions;
    abstract fetch(url: string, options: LangfuseFetchOptions): Promise<LangfuseFetchResponse>;
    abstract getLibraryId(): string;
    abstract getLibraryVersion(): string;
    abstract getPersistedProperty<T>(key: LangfusePersistedProperty): T | undefined;
    abstract setPersistedProperty<T>(key: LangfusePersistedProperty, value: T | null): void;
    constructor(params: {
        publicKey: string;
        secretKey?: string;
    } & LangfuseCoreOptions);
    protected getCommonEventProperties(): any;
    on(event: string, cb: (...args: any[]) => void): () => void;
    debug(enabled?: boolean): void;
    /***
     *** Handlers for each object type
     ***/
    protected traceStateless(body: CreateLangfuseTraceBody): string;
    protected eventStateless(body: CreateLangfuseEventBody): string;
    protected spanStateless(body: CreateLangfuseSpanBody): string;
    protected generationStateless(body: CreateLangfuseGenerationBody): string;
    protected scoreStateless(body: CreateLangfuseScoreBody): string;
    protected updateSpanStateless(body: UpdateLangfuseSpanBody): string;
    protected updateGenerationStateless(body: UpdateLangfuseGenerationBody): string;
    protected _getDataset(name: GetLangfuseDatasetParams["datasetName"]): Promise<GetLangfuseDatasetResponse>;
    getDatasetRun(params: GetLangfuseDatasetRunParams): Promise<GetLangfuseDatasetRunResponse>;
    createDatasetRunItem(body: CreateLangfuseDatasetRunItemBody): Promise<CreateLangfuseDatasetRunItemResponse>;
    createDataset(name: string): Promise<CreateLangfuseDatasetResponse>;
    /**
     * Creates a dataset item. Upserts the item if it already exists.
     * @param body The body of the dataset item to be created.
     * @returns A promise that resolves to the response of the create operation.
     */
    createDatasetItem(body: CreateLangfuseDatasetItemBody): Promise<CreateLangfuseDatasetItemResponse>;
    getDatasetItem(id: string): Promise<CreateLangfuseDatasetItemResponse>;
    protected _parsePayload(response: any): any;
    /***
     *** QUEUEING AND FLUSHING
     ***/
    protected enqueue(type: LangfuseObject, body: any): void;
    flushAsync(): Promise<any>;
    flush(): Promise<LangfuseFetchResponse>[];
    private getFetchOptions;
    private constructAuthorizationHeader;
    private fetchWithRetry;
    shutdownAsync(): Promise<void>;
    shutdown(): void;
    protected awaitAllQueuedAndPendingRequests(): Promise<void>;
}
export declare abstract class LangfuseWebStateless extends LangfuseCoreStateless {
    constructor(params: {
        publicKey: string;
    } & LangfuseCoreOptions);
    score(body: CreateLangfuseScoreBody): Promise<this>;
}
export declare abstract class LangfuseCore extends LangfuseCoreStateless {
    constructor(params: {
        publicKey: string;
        secretKey: string;
    } & LangfuseCoreOptions);
    trace(body?: CreateLangfuseTraceBody): LangfuseTraceClient;
    span(body: CreateLangfuseSpanBody): LangfuseSpanClient;
    generation(body: CreateLangfuseGenerationBody): LangfuseGenerationClient;
    event(body: CreateLangfuseEventBody): LangfuseEventClient;
    score(body: CreateLangfuseScoreBody): this;
    getDataset(name: string): Promise<{
        id: string;
        name: string;
        projectId: string;
        items: Array<{
            id: string;
            input: any;
            expectedOutput?: any;
            sourceObservationId?: string | null;
            link: (obj: LangfuseObservationClient, runName: string) => Promise<{
                id: string;
            }>;
        }>;
    }>;
    _updateSpan(body: UpdateLangfuseSpanBody): this;
    _updateGeneration(body: UpdateLangfuseGenerationBody): this;
}
export declare abstract class LangfuseObjectClient {
    readonly client: LangfuseCore;
    readonly id: string;
    readonly traceId: string;
    readonly observationId: string | null;
    constructor({ client, id, traceId, observationId, }: {
        client: LangfuseCore;
        id: string;
        traceId: string;
        observationId: string | null;
    });
    event(body: Omit<CreateLangfuseEventBody, "traceId" | "parentObservationId">): LangfuseEventClient;
    span(body: Omit<CreateLangfuseSpanBody, "traceId" | "parentObservationId">): LangfuseSpanClient;
    generation(body: Omit<CreateLangfuseGenerationBody, "traceId" | "parentObservationId">): LangfuseGenerationClient;
    score(body: Omit<CreateLangfuseScoreBody, "traceId" | "parentObservationId">): this;
    getTraceUrl(): string;
}
export declare class LangfuseTraceClient extends LangfuseObjectClient {
    constructor(client: LangfuseCore, traceId: string);
    update(body: Omit<CreateLangfuseTraceBody, "id">): this;
}
declare abstract class LangfuseObservationClient extends LangfuseObjectClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
}
export declare class LangfuseSpanClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
    update(body: Omit<UpdateLangfuseSpanBody, "spanId" | "traceId">): this;
    end(body?: Omit<UpdateLangfuseSpanBody, "spanId" | "endTime" | "traceId">): this;
}
export declare class LangfuseGenerationClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
    update(body: Omit<UpdateLangfuseGenerationBody, "generationId" | "traceId">): this;
    end(body?: Omit<UpdateLangfuseGenerationBody, "generationId" | "traceId" | "endTime">): this;
}
export declare class LangfuseEventClient extends LangfuseObservationClient {
    constructor(client: LangfuseCore, id: string, traceId: string);
}
export * from "./types";
export * from "./openapi/server";
