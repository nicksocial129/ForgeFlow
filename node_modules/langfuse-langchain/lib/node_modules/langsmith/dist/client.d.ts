export class Client {
    static getDefaultClientConfig(): {
        apiUrl: string;
        apiKey: string | undefined;
        webUrl: undefined;
    };
    constructor(config?: {});
    apiUrl: any;
    apiKey: any;
    webUrl: any;
    timeout_ms: any;
    caller: AsyncCaller;
    validateApiKeyIfHosted(): void;
    getHostUrl(): any;
    get headers(): {
        "x-api-key": string;
    };
    _get(path: any, queryParams: any): Promise<any>;
    _getPaginated(path: any, queryParams?: URLSearchParams): AsyncGenerator<any, void, unknown>;
    createRun(run: any): Promise<void>;
    updateRun(runId: any, run: any): Promise<void>;
    readRun(runId: any, { loadChildRuns }?: {
        loadChildRuns: boolean;
    }): Promise<any>;
    getRunUrl({ runId, run, projectOpts, }: {
        runId: any;
        run: any;
        projectOpts: any;
    }): Promise<string>;
    _loadChildRuns(run: any): Promise<any>;
    listRuns({ projectId, projectName, parentRunId, referenceExampleId, startTime, executionOrder, runType, error, id, limit, offset, query, filter, }: {
        projectId: any;
        projectName: any;
        parentRunId: any;
        referenceExampleId: any;
        startTime: any;
        executionOrder: any;
        runType: any;
        error: any;
        id: any;
        limit: any;
        offset: any;
        query: any;
        filter: any;
    }): AsyncGenerator<any, void, any>;
    shareRun(runId: any, { shareId }?: {
        shareId: any;
    }): Promise<string>;
    unshareRun(runId: any): Promise<void>;
    readRunSharedLink(runId: any): Promise<string | undefined>;
    createProject({ projectName, projectExtra, upsert, referenceDatasetId, }: {
        projectName: any;
        projectExtra: any;
        upsert: any;
        referenceDatasetId: any;
    }): Promise<any>;
    readProject({ projectId, projectName, }: {
        projectId: any;
        projectName: any;
    }): Promise<any>;
    _getTenantId(): Promise<any>;
    _tenantId: any;
    listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, }?: {
        projectIds: any;
        name: any;
        nameContains: any;
        referenceDatasetId: any;
        referenceDatasetName: any;
        referenceFree: any;
    }): AsyncGenerator<any, void, any>;
    deleteProject({ projectId, projectName, }: {
        projectId: any;
        projectName: any;
    }): Promise<void>;
    uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }: {
        csvFile: any;
        fileName: any;
        inputKeys: any;
        outputKeys: any;
        description: any;
        dataType: any;
        name: any;
    }): Promise<any>;
    createDataset(name: any, { description, dataType, }?: {
        description: any;
        dataType: any;
    }): Promise<any>;
    readDataset({ datasetId, datasetName, }: {
        datasetId: any;
        datasetName: any;
    }): Promise<any>;
    listDatasets({ limit, offset, datasetIds, datasetName, datasetNameContains, }?: {
        limit?: number | undefined;
        offset?: number | undefined;
        datasetIds: any;
        datasetName: any;
        datasetNameContains: any;
    }): AsyncGenerator<any, void, any>;
    deleteDataset({ datasetId, datasetName, }: {
        datasetId: any;
        datasetName: any;
    }): Promise<void>;
    createExample(inputs: any, outputs: any, { datasetId, datasetName, createdAt, exampleId }: {
        datasetId: any;
        datasetName: any;
        createdAt: any;
        exampleId: any;
    }): Promise<any>;
    createLLMExample(input: any, generation: any, options: any): Promise<any>;
    createChatExample(input: any, generations: any, options: any): Promise<any>;
    readExample(exampleId: any): Promise<any>;
    listExamples({ datasetId, datasetName, exampleIds, }?: {
        datasetId: any;
        datasetName: any;
        exampleIds: any;
    }): AsyncGenerator<any, void, any>;
    deleteExample(exampleId: any): Promise<void>;
    updateExample(exampleId: any, update: any): Promise<any>;
    evaluateRun(run: any, evaluator: any, { sourceInfo, loadChildRuns, }?: {
        loadChildRuns: boolean;
        sourceInfo: any;
    }): Promise<{
        id: any;
        run_id: any;
        key: any;
        score: any;
        value: any;
        correction: any;
        comment: any;
        feedback_source: {
            type: string;
            metadata: any;
        };
    }>;
    createFeedback(runId: any, key: any, { score, value, correction, comment, sourceInfo, feedbackSourceType, sourceRunId, feedbackId, }: {
        score: any;
        value: any;
        correction: any;
        comment: any;
        sourceInfo: any;
        feedbackSourceType?: string | undefined;
        sourceRunId: any;
        feedbackId: any;
    }): Promise<{
        id: any;
        run_id: any;
        key: any;
        score: any;
        value: any;
        correction: any;
        comment: any;
        feedback_source: {
            type: string;
            metadata: any;
        };
    }>;
    updateFeedback(feedbackId: any, { score, value, correction, comment, }: {
        score: any;
        value: any;
        correction: any;
        comment: any;
    }): Promise<void>;
    readFeedback(feedbackId: any): Promise<any>;
    deleteFeedback(feedbackId: any): Promise<void>;
    listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, }?: {
        runIds: any;
        feedbackKeys: any;
        feedbackSourceTypes: any;
    }): AsyncGenerator<any, void, any>;
}
import { AsyncCaller } from "./utils/async_caller.js";
