/**
 * Get a unique name for the module, rather than parent class implementations.
 * Should not be subclassed, subclass lc_name above instead.
 */
export function get_lc_unique_name(serializableClass: any): any;
export class Serializable {
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    static lc_name(): string;
    constructor(kwargs: any, ..._args: any[]);
    /**
     * The final serialized identifier for the module.
     */
    get lc_id(): any[];
    /**
     * A map of secrets, which will be omitted from serialization.
     * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
     * Values are the secret ids, which will be used when deserializing.
     */
    get lc_secrets(): undefined;
    /**
     * A map of additional attributes to merge with constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the attribute values, which will be serialized.
     * These attributes need to be accepted by the constructor as arguments.
     */
    get lc_attributes(): undefined;
    /**
     * A map of aliases for constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the alias that will replace the key in serialization.
     * This is used to eg. make argument names match Python.
     */
    get lc_aliases(): undefined;
    lc_kwargs: any;
    toJSON(): {
        lc: number;
        type: string;
        id: any[];
    } | {
        lc: number;
        type: string;
        id: any[];
        kwargs: import("./map_keys.js").SerializedFields;
    };
    toJSONNotImplemented(): {
        lc: number;
        type: string;
        id: any[];
    };
}
