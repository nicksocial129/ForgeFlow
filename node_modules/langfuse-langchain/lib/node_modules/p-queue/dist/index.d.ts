declare var _default: typeof PQueue;
/**
Promise queue with concurrency control.
*/
declare class PQueue {
    constructor(options: any);
    _intervalCount: number;
    _intervalEnd: number;
    _pendingCount: number;
    _resolveEmpty: () => void;
    _resolveIdle: () => void;
    _carryoverConcurrencyCount: any;
    _isIntervalIgnored: boolean;
    _intervalCap: any;
    _interval: any;
    _queue: any;
    _queueClass: any;
    set concurrency(arg: any);
    get concurrency(): any;
    _timeout: any;
    _throwOnTimeout: boolean;
    _isPaused: boolean;
    get _doesIntervalAllowAnother(): boolean;
    get _doesConcurrentAllowAnother(): boolean;
    _next(): void;
    _resolvePromises(): void;
    _onResumeInterval(): void;
    _timeoutId: NodeJS.Timeout | undefined;
    _isIntervalPaused(): boolean;
    _tryToStartAnother(): boolean;
    _intervalId: NodeJS.Timer | undefined;
    _initializeIntervalIfNeeded(): void;
    _onInterval(): void;
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue(): void;
    _concurrency: any;
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    add(fn: any, options?: {}): Promise<any>;
    /**
    Same as `.add()`, but accepts an array of sync or async functions.

    @returns A promise that resolves when all functions are resolved.
    */
    addAll(functions: any, options: any): Promise<any[]>;
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start(): this;
    /**
    Put queue execution on hold.
    */
    pause(): void;
    /**
    Clear the queue.
    */
    clear(): void;
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */
    onEmpty(): Promise<any>;
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    onIdle(): Promise<any>;
    /**
    Size of the queue.
    */
    get size(): any;
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
    sizeBy(options: any): any;
    /**
    Number of pending promises.
    */
    get pending(): number;
    /**
    Whether the queue is currently paused.
    */
    get isPaused(): boolean;
    /**
    Set the timeout for future operations.
    */
    set timeout(arg: any);
    get timeout(): any;
}
export { dist as __moduleExports, _default as default };
