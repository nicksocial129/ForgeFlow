import { Langfuse } from 'langfuse';
export { Langfuse } from 'langfuse';
import { BaseCallbackHandler } from 'langchain/callbacks';
import { AIMessage } from 'langchain/schema';

class CallbackHandler extends BaseCallbackHandler {
  constructor(params) {
    super();
    this.name = "CallbackHandler";
    if ("root" in params) {
      this.langfuse = params.root.client;
      this.rootObservationId = params.root.observationId ?? undefined;
      this.traceId = params.root.traceId;
    } else {
      this.langfuse = new Langfuse({
        ...params,
        persistence: "memory"
      });
    }
    this.userId = params.userId;
    this.version = params.version;
  }
  async flushAsync() {
    return this.langfuse.flushAsync();
  }
  async shutdownAsync() {
    return this.langfuse.shutdownAsync();
  }
  debug(enabled = true) {
    this.langfuse.debug(enabled);
  }
  async handleNewToken(token, runId) {
    console.log("New token:", token, "with ID:", runId);
  }
  getTraceId() {
    return this.traceId;
  }
  getTraceUrl() {
    return this.traceId ? `${this.langfuse.baseUrl}/trace/${this.traceId}` : undefined;
  }
  getLangchainRunId() {
    return this.topLevelObservationId;
  }
  async handleRetrieverError(err, runId, parentRunId) {
    try {
      console.log("Retriever error:", err, runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        level: "ERROR",
        statusMessage: err.toString(),
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata) {
    try {
      console.log("Chain start with Id:", runId);
      this.generateTrace(chain, runId, parentRunId, tags, metadata);
      this.langfuse.span({
        id: runId,
        traceId: this.traceId,
        parentObservationId: parentRunId ?? this.rootObservationId,
        name: chain.id.at(-1)?.toString(),
        metadata: this.joinTagsAndMetaData(tags, metadata),
        input: inputs,
        startTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleAgentAction(action, runId, parentRunId) {
    try {
      console.log("Agent action:", runId);
      this.langfuse.span({
        id: runId,
        parentObservationId: parentRunId,
        traceId: this.traceId,
        endTime: new Date(),
        input: action,
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleAgentEnd(action, runId, parentRunId) {
    try {
      console.log("Agent finish:", runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        endTime: new Date(),
        output: action,
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleChainError(err, runId, parentRunId) {
    try {
      console.log("Chain error:", err, runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        level: "ERROR",
        statusMessage: err.toString(),
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  generateTrace(serialized, runId, parentRunId, tags, metadata) {
    if (!this.traceId) {
      this.langfuse.trace({
        id: runId,
        name: serialized.id.at(-1)?.toString(),
        metadata: this.joinTagsAndMetaData(tags, metadata),
        userId: this.userId,
        version: this.version
      });
      this.traceId = runId;
    }
    this.topLevelObservationId = parentRunId ? this.topLevelObservationId : runId;
  }
  async handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {
    console.log("Generation start:", runId);
    this.generateTrace(llm, runId, parentRunId, tags, metadata);
    const modelParameters = {};
    const invocationParams = extraParams?.["invocation_params"];
    for (const [key, value] of Object.entries({
      temperature: invocationParams?.temperature,
      max_tokens: invocationParams?.max_tokens,
      top_p: invocationParams?.top_p,
      frequency_penalty: invocationParams?.frequency_penalty,
      presence_penalty: invocationParams?.presence_penalty,
      request_timeout: invocationParams?.request_timeout
    })) {
      if (value !== undefined && value !== null) {
        modelParameters[key] = value;
      }
    }
    let extractedModelName;
    if (extraParams) {
      const params = extraParams.invocation_params;
      extractedModelName = params.model;
    }
    this.langfuse.generation({
      id: runId,
      traceId: this.traceId,
      name: llm.id.at(-1)?.toString(),
      startTime: new Date(),
      metadata: this.joinTagsAndMetaData(tags, metadata),
      parentObservationId: parentRunId ?? this.rootObservationId,
      prompt: messages,
      model: extractedModelName,
      modelParameters: modelParameters,
      version: this.version
    });
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {
    try {
      console.log("ChatModel start:", runId);
      this.handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata);
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleChainEnd(outputs, runId, parentRunId) {
    try {
      console.log("Chain end:", runId, parentRunId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        output: outputs,
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata) {
    try {
      console.log("LLM start:", runId);
      this.handleGenerationStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata);
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata) {
    try {
      console.log("Tool start:", runId);
      this.langfuse.span({
        id: runId,
        parentObservationId: parentRunId,
        traceId: this.traceId,
        name: tool.id.at(-1)?.toString(),
        input: input,
        metadata: this.joinTagsAndMetaData(tags, metadata),
        startTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata) {
    try {
      console.log("Retriever start:", runId);
      this.langfuse.span({
        id: runId,
        parentObservationId: parentRunId,
        traceId: this.traceId,
        name: retriever.id.at(-1)?.toString(),
        input: query,
        metadata: this.joinTagsAndMetaData(tags, metadata),
        startTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleRetrieverEnd(documents, runId, parentRunId) {
    try {
      console.log("Retriever end:", runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        output: documents,
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleToolEnd(output, runId, parentRunId) {
    try {
      console.log("Tool end:", runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        output: output,
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleToolError(err, runId, parentRunId) {
    try {
      console.log("Tool error:", err, runId);
      this.langfuse._updateSpan({
        spanId: runId,
        traceId: this.traceId,
        level: "ERROR",
        statusMessage: err.toString(),
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleLLMEnd(output, runId, parentRunId) {
    try {
      console.log("LLM end:", runId, parentRunId);
      const lastResponse = output.generations[output.generations.length - 1][output.generations[output.generations.length - 1].length - 1];
      const llmUsage = output.llmOutput?.["tokenUsage"];
      this.langfuse._updateGeneration({
        generationId: runId,
        traceId: this.traceId,
        completion: !lastResponse.text && "message" in lastResponse && lastResponse["message"] instanceof AIMessage && lastResponse["message"].additional_kwargs ? lastResponse["message"].additional_kwargs : lastResponse.text,
        endTime: new Date(),
        usage: llmUsage,
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  async handleLLMError(err, runId, parentRunId) {
    try {
      console.log("LLM error:", err, runId);
      this.langfuse._updateGeneration({
        generationId: runId,
        traceId: this.traceId,
        level: "ERROR",
        statusMessage: err.toString(),
        endTime: new Date(),
        version: this.version
      });
    } catch (e) {
      console.log("Error:", e);
    }
  }
  joinTagsAndMetaData(tags, metadata) {
    if (tags) {
      const finalDict = {
        tags: tags
      };
      if (metadata) {
        return {
          ...finalDict,
          ...metadata
        };
      }
    }
    return metadata ?? {};
  }
}

export { CallbackHandler, CallbackHandler as default };
//# sourceMappingURL=index.mjs.map
